<project name="jif" default="jif" basedir=".">
    <description>
    Jif build file
  </description>



    <!-- ****************************************
       set global properties for this build
       ****************************************  -->

    <!-- The OS-specific native include directory. If we can't figure it out
       automatically, it may need to be set explicitly -->
    <!--  <property name="jif-runtime-native.java-include-dir"
                location="${jdk.home}/include/linux"/> -->

  <!-- set the prefix for accessing environment variables,
       BEFORE reading the properties file. -->
  <property environment="env" />

    <!-- Import properties file. -->
    <property file="${basedir}/config.properties" />
    <echo message="polyglot.home is ${polyglot.home}" level="verbose" />

    <!-- source directory -->
    <property name="src" location="${basedir}/src" />

    <!-- directory for class file targets -->
    <property name="classes" location="${basedir}/classes" />

    <!-- directory for shared libraries -->
    <property name="lib" location="${basedir}/lib" />

    <!-- signature source directory -->
    <property name="sig-src" location="${basedir}/sig-src" />

    <!-- directory for class file targets of signature source code -->
    <property name="sig-classes" location="${basedir}/sig-classes" />

    <!-- runtime source directory -->
    <property name="rt-src" location="${basedir}/rt-src" />

    <!-- directory for class file targets of runtime source code -->
    <property name="rt-classes" location="${basedir}/rt-classes" />

    <!-- library source directory (jif library source code) -->
    <property name="lib-src" location="${basedir}/lib-src" />

    <!-- directory for class file targets of library source code -->
    <property name="lib-classes" location="${basedir}/lib-classes" />

    <!-- distribution directory -->
    <property name="dist" location="${basedir}/dist" />

    <!-- binaries directory -->
    <property name="bin" location="${basedir}/bin" />

    <!-- jifc executable -->
    <property name="jifc" location="${bin}/jifc" />
    <property name="jif" location="${bin}/jif" />

    <!-- Set of source files to include in the distribution. -->
    <fileset id="dist-src-files" dir="${basedir}" defaultexcludes="yes">
        <include name="src/**" />
        <exclude name="src/jif/todo.txt" />
        <include name="rt-src/**" />
        <include name="lib-src/**" />
        <include name="sig-src/**" />
    </fileset>

    <!-- Set of class files that comprise the Jif compiler. -->
    <!-- (i.e., the contents of jif.jar.) -->
    <fileset id="dist-class-files" dir="${classes}">
        <include name="jif/**"/>
    </fileset>

    <!-- Polyglot distribution location -->
    <property name="polyglot.url.prefix"
            value="http://www.cs.cornell.edu/Projects/polyglot/src/polyglot-"/>
    <property name="polyglot.url.suffix"
            value="-src.zip"/>


    <!-- Polyglot classpath elements -->
    <condition property="polyglot-classes"
           value="${polyglot.home}/classes"
           else="">
    <isset property="polyglot.home" />
    </condition>
    <echo message="polyglot-classes is ${polyglot-classes}" level="verbose" />

    <condition property="polyglot-jar"
           value="${polyglot.home}/lib/polyglot.jar"
           else="">
    <isset property="polyglot.home" />
    </condition>
    <echo message="polyglot-jar is ${polyglot-jar}" level="verbose" />

    <condition property="ppg-jar"
           value="${polyglot.home}/lib/ppg.jar"
           else="">
    <isset property="polyglot.home" />
    </condition>
    <echo message="ppg-jar is ${ppg-jar}" level="verbose" />

    <condition property="javacup-jar"
           value="${polyglot.home}/lib/java_cup.jar"
           else="">
    <isset property="polyglot.home" />
    </condition>
    <echo message="javacup-jar is ${javacup-jar}" level="verbose" />

    <condition property="jflex-jar"
           value="${polyglot.home}/lib/jflex.jar"
           else="">
    <isset property="polyglot.home" />
    </condition>
    <echo message="jflex-jar is ${jflex-jar}" level="verbose" />

    <condition property="polyglot.home" value="">
    <not><isset property="polyglot.home" /></not>
    </condition>

    <!-- the standard classpath -->
    <path id="standard.classpath">
        <pathelement location="${classes}" />
        <pathelement path="${java.class.path}" />
        <fileset dir="${lib}">
            <include name="*.jar" />
            <exclude name="jif*.jar" />
        </fileset>
    <pathelement path="${polyglot-classes}" />
    <pathelement path="${polyglot-jar}" />
    <pathelement path="${ppg-jar}" />
    <pathelement path="${javacup-jar}" />
    <pathelement path="${jflex-jar}" />
    </path>

    <property name="standard.classpath" refid="standard.classpath" />
    <echo message="standard.classpath is ${standard.classpath}" level="verbose" />

    <!-- establish the os -->
    <condition property="os.isWindows">
        <os family="windows" />
    </condition>
    <condition property="os.isUnix">
        <os family="unix" />
    </condition>
    <condition property="os.unsupported-os">
        <and>
            <not>
                <os family="windows" />
            </not>
            <not>
                <os family="unix" />
            </not>
        </and>
    </condition>

    <!-- ****************************************
       Clean up targets and other admin tasks
       ****************************************  -->
    <target name="clean" depends="dust" description="clean up">
        <!-- Delete the ${classes} and ${dist} directory trees -->
        <delete dir="${classes}" />
        <delete dir="${dist}" />
        <delete includeemptydirs="true">
            <fileset dir="${basedir}/tests">
                <include name="**/*.class" />
                <include name="**/*.java" />
                <include name="**/*~" />
                <include name="pthOutput*/**/*" />
            </fileset>
            <fileset dir="${basedir}/tests">
                <include name="pthOutput*" />
            </fileset>
            <fileset dir="${basedir}/examples">
                <include name="**/*.class" />
                <include name="battleship/**/*.java" />
            </fileset>
        </delete>
    </target>

    <target name="dust" description="clean up the generated runtime, sig, and lib">
        <!-- Delete the ${classes} and ${dist} directory trees -->
        <delete dir="${sig-classes}" />
        <delete dir="${rt-classes}" />
        <delete dir="${lib-classes}" />
        <delete includeemptydirs="true">
            <fileset dir="${lib}">
                <include name="jifrt.jar" />
                <include name="jifsig.jar" />
                <include name="jiflib.jar" />
            </fileset>
        </delete>
    </target>

    <target name="clean-jars" description="Cleans up the jars">
        <delete includeemptydirs="true">
            <fileset dir="${lib}">
                <include name="jifrt.jar" />
                <include name="jifsig.jar" />
                <include name="jiflib.jar" />
            </fileset>
        </delete>
    </target>

    <target name="clobber" depends="clean" description="removes all generated files">
        <delete includeemptydirs="true">
            <fileset dir="${src}">
                <include name="**/Grm.java" />
                <include name="**/sym.java" />
                <include name="**/Lexer_c.java" />
                <include name="**/*_ppg.cup" />
            </fileset>
            <fileset dir="${rt-src}">
                <include name="jif/native/*.o" />
                <include name="jif/native/jif_runtime_*.h" />
            </fileset>
            <fileset dir="${lib}">
                <include name="*jifrt.*" />
                <include name="jif.jar" />
                <include name="jifrt.jar" />
                <include name="jifsig.jar" />
                <include name="jiflib.jar" />
            </fileset>
        </delete>
        <delete file="${jifc}" />
        <delete file="${jifc}.bat" />
        <delete file="${bin}/splitc" />
    </target>

    <!-- initialize the build -->
    <target name="init">
        <!-- Create the time stamp -->
        <tstamp />
        <!-- Create the build directory structures used by compile -->
        <mkdir dir="${classes}" />
        <mkdir dir="${sig-classes}" />
        <mkdir dir="${rt-classes}" />
        <mkdir dir="${lib-classes}" />
    </target>



    <!-- ****************************************
       Configuration
       ****************************************  -->
    <target name="configure" description="Configure jif">
        <antcall target="check-classpath" />
    <antcall target="jifc-executable" />
        <antcall target="jif-executable-bat" />
        <chmod file="${jif}" perm="a+x"/>
        <chmod file="${jifc}" perm="a+x"/>
    </target>

    <target name="check-classpath" description="Check the classpath contains the appropriate directories/jars">
        <available classname="polyglot.main.Main"
               classpathref="standard.classpath"
               property="cp_existence.polyglot"/>
        <available classname="java_cup.Main"
               classpathref="standard.classpath"
               property="cp_existence.java_cup"/>
        <available classname="jflex.Main"
               classpathref="standard.classpath"
               property="cp_existence.jflex"/>
        <available classname="polyglot.ext.param.ExtensionInfo"
               classpathref="standard.classpath"
               property="cp_existence.polyglot.param"/>

        <condition property="jdk_home.defined">
            <isset property="jdk.home" />
        </condition>
        <fail unless="cp_existence.polyglot"
          message="The polyglot classes must be on the classpath. Try adding polyglot.jar to the classpath."/>
        <fail unless="cp_existence.java_cup"
          message="The java_cup classes must be on the classpath. Try adding java_cup.jar to the classpath."/>
        <fail unless="cp_existence.jflex"
          message="The JFlex classes must be on the classpath. Try adding jflex.jar to the classpath."/>
        <fail unless="cp_existence.polyglot.param"
          message="The Polyglot param extension must be compiled."/>
        <fail unless="jdk_home.defined"
          message="The JDK home (usually environment variable JAVA_HOME) must be defined."/>
    </target>

    <!-- Configures Eclipse's .classpath file. -->
    <target name="eclipse" depends="eclipse-check"
        unless="eclipse.up-to-date"
        description="Configures Eclipse's .classpath file">
    <condition property="tools.jar-entry"
        value="&lt;classpathentry kind=&quot;lib&quot; path=&quot;${jdk.home}/lib/tools.jar&quot;/&gt;"
        else="">
        <available file="${jdk.home}/lib/tools.jar" />
    </condition>
    <copy file="eclipse/classpath.in" tofile=".classpath">
        <filterset>
        <filter token="TOOLS.JAR" value="${tools.jar-entry}" />
        </filterset>
    </copy>
    </target>

    <target name="eclipse-check">
    <uptodate property="eclipse.up-to-date" targetfile=".classpath"
            srcfile="eclipse/classpath.in" />
    </target>

    <!-- Create jifc script if needed -->
    <target name="jifc-executable">
    <copy file="${jifc}.in" tofile="${jifc}">
        <filterset>
        <filter token="POLYGLOT" value="${polyglot.home}" />
        </filterset>
    </copy>
    </target>

    <!-- Create jif.bat and jifc.bat if needed -->
    <target name="jif-executable-bat" 
            if="os.isWindows">
        <concat destfile="${jifc}.bat" append="no">
@echo off
rem DO NOT EDIT - This file was automatically generated.

set CMD_LINE_ARGS=%1
if ""%1""=="""" goto doneStart
shift
:setupArgs
if ""%1""=="""" goto doneStart
set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1
shift
goto setupArgs
:doneStart
sh ${jifc} %CMD_LINE_ARGS%
    </concat>
        <concat destfile="${jif}.bat" append="no">
@echo off
rem DO NOT EDIT - This file was automatically generated.

set CMD_LINE_ARGS=%1
if ""%1""=="""" goto doneStart
shift
:setupArgs
if ""%1""=="""" goto doneStart
set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1
shift
goto setupArgs
:doneStart
sh ${jif} %CMD_LINE_ARGS%
    </concat>
    </target>

    <!-- ****************************************
       Jif targets
       ****************************************  -->

    <target name="jif" depends="jif-base,jif-runtime,jif-sig,jif-lib" description="Build the Jif compiler and libraries"/>

    <target name="jif-base" depends="init,configure,eclipse">
        <antcall target="standard-ext">
            <param name="ext" value="jif" />
            <param name="ext.basedir" value="${basedir}" />
            <param name="parser.type" value="ppg" />
        </antcall>
        
        <!-- Copy jif.ppg to the classes dir so that it's included in the jar
             for others to use. -->
        <copy file="${src}/jif/parse/jif.ppg" todir="${classes}/jif/parse" />
    </target>

    <!-- The Jif signatures for standard java classes, e.g. java.lang.Object -->
    <target name="jif-sig" depends="jif-base,jif-runtime" description="compile the signature classes">
        <mkdir dir="${sig-classes}" />
        <apply executable="${jifc}" 
               parallel="false" 
               failonerror="true" 
               dest="${basedir}" 
               relative="true" 
               skipemptyfilesets="true" 
               vmlauncher="false">
            <arg value="-e" />
            <arg value="-d" />
            <arg value="sig-classes" />
            <arg value="-sourcepath" />
            <arg value="sig-src" />
            <!--
            <arg value="-rdebug" />
            -->
        <arg value="-classpath" />
            <arg path="${java.class.path}" prefix="&quot;" suffix="&quot;" />
            <srcfile />
            <fileset dir="${basedir}" includes="sig-src/**/Object.jif" />
            <mapper type="regexp" from="^sig-src(.*)\.jif" to="sig-classes\1\.class" />
        </apply>

        <apply executable="${jifc}" 
               parallel="true" 
               failonerror="true" 
               dest="${basedir}"
               relative="true" 
               skipemptyfilesets="true" 
               vmlauncher="false">
            <arg value="-e" />
            <arg value="-d" />
            <arg value="sig-classes" />
            <arg value="-sourcepath" />
            <arg value="sig-src" />
        <arg value="-classpath" />
            <arg path="${java.class.path}" prefix="&quot;" suffix="&quot;" />
            <srcfile />
            <fileset dir="${basedir}" includes="sig-src/**/*.jif" />
            <mapper type="regexp" from="^sig-src(.*)\.jif" to="sig-classes\1\.class" />
        </apply>
    </target>


    <!-- Jif library code, e.g. jif.util.List -->
    <target name="jif-lib" depends="jif-base,jif-sig" description="compile the jif library code">
        <mkdir dir="${lib-classes}" />
        <apply executable="${jifc}" 
               parallel="true" 
               failonerror="true" 
               dest="${basedir}"
               relative="true" 
               skipemptyfilesets="true" 
               vmlauncher="false">
            <arg value="-e" />
            <arg value="-d" />
            <arg value="lib-classes" />
            <arg value="-sourcepath" />
            <arg value="lib-src" />
        <arg value="-e" />
        <arg value="-classpath" />
            <arg path="${java.class.path}" prefix="&quot;" suffix="&quot;" />
            <!--      
      <arg value="-report" />
      <arg value="debug=1" />
-->
            <srcfile />
            <fileset dir="${basedir}" includes="lib-src/**/*.jif" />
            <mapper type="regexp" from="^lib-src(.*)\.jif" to="lib-classes\1\.class" />
        </apply>
    </target>


    <target name="jif-runtime" depends="init,configure" description="compile the jif runtime">
        <mkdir dir="${rt-classes}" />
        <javac source="1.7" target="1.7" srcdir="${rt-src}" destdir="${rt-classes}" encoding="UTF-8" debug="on" includes="**">
            <classpath>
                <pathelement location="${sig-classes}" />
                <pathelement location="${lib-classes}" />
                <path refid="standard.classpath" />
            </classpath>
        </javac>

        <antcall target="jif-runtime-native" />
    </target>

    <!--
         Although jif.skip-native isn't explicitly defined in this build file,
         the jif-runtime-native target is guarded by jif.skip-native to allow
         the user to avoid compiling the Jif runtime native code by defining
         jif.skip-native externally.
    -->
    <target name="jif-runtime-native"
            description="compile the jif runtime native code"
            unless="jif.skip-native">
        <!-- Compile the headers for jif.lang.NativePM -->
        <mkdir dir="${rt-classes}/jif/native" />

        <!-- Compile the headers for jif.runtime.FileSystem and jif.runtime.Runtime -->
        <javah class="jif.runtime.FileSystem,jif.runtime.Runtime" destdir="${rt-src}/jif/native" force="yes">
            <classpath>
                <pathelement location="${rt-classes}" />
                <path refid="standard.classpath" />
            </classpath>
        </javah>

        <fail if="os.unsupported-os" message="Cannot compile the native runtime code. This is not a supported OS." />

        <!-- Make sure we can find the appropriate OS specific native include directory -->
        <condition property="jif-runtime-native.java-include-dir" value="${jdk.home}/include/${env.OSTYPE}">
            <and>
                <not>
                    <isset property="jif-runtime-native.java-include-dir" />
                </not>
                <isset property="env.OSTYPE" />
                <available file="${jdk.home}/include/${env.OSTYPE}" />
            </and>
        </condition>
        <condition property="jif-runtime-native.java-include-dir" value="${jdk.home}/include/linux">
            <and>
                <not>
                    <isset property="jif-runtime-native.java-include-dir" />
                </not>
                <available file="${jdk.home}/include/linux" />
            </and>
        </condition>
        <condition property="jif-runtime-native.java-include-dir" value="${jdk.home}/include/solaris">
            <and>
                <not>
                    <isset property="jif-runtime-native.java-include-dir" />
                </not>
                <available file="${jdk.home}/include/solaris" />
            </and>
        </condition>
        <condition property="jif-runtime-native.java-include-dir" value="${jdk.home}/include/win32">
            <and>
                <not>
                    <isset property="jif-runtime-native.java-include-dir" />
                </not>
                <available file="${jdk.home}/include/win32" />
            </and>
        </condition>
        <condition property="jif-runtime-native.java-include-dir" value="${jdk.home}/include">
            <and>
                <not>
                    <isset property="jif-runtime-native.java-include-dir" />
                </not>
                <available file="${jdk.home}/include/jni.h" />
            </and>
        </condition>
        <available file="${jif-runtime-native.java-include-dir}" property="jif-runtime-native.java-include-dir.available" />
        <fail unless="jif-runtime-native.java-include-dir.available">
Cannot find the OS-specific directory in ${jdk.home}/include to include.
Please try setting the property "jif-runtime-native.java-include-dir" to be the absolute path of this directory.
    </fail>
        <property name="jif-runtime-native.java-include-dir.location" location="${jif-runtime-native.java-include-dir}" />

        <antcall target="jif-runtime-native-unix" />
        <antcall target="jif-runtime-native-windows" />
    </target>

    <!-- compile the jif runtime native code for unix -->
    <target name="jif-runtime-native-unix" if="os.isUnix">

        <condition property="jif-native-unix.sharedflag" value="-shared">
            <os name="linux" />
        </condition>
        <condition property="jif-native-unix.sharedflag" value="-G">
            <os name="solaris" />
        </condition>
        <condition property="jif-native-unix.sharedflag" value="-dynamiclib">
            <os name="Mac OS X" />
        </condition>
        <condition property="jif-native-unix.sharedflag" value="-shared">
            <not>
                <isset property="jif-native-unix.sharedflag" />
            </not>
        </condition>

        <condition property="jif-native-unix.library" value="libjifrt.jnilib">
            <os name="Mac OS X" />
        </condition>
        <condition property="jif-native-unix.library" value="libjifrt.so">
            <not>
                <isset property="jif-native-unix.library" />
            </not>
        </condition>

        <apply executable="g++" 
               failonerror="true" 
               dest="${lib}" 
               skipemptyfilesets="true" 
               vmlauncher="false">
            <arg value="${jif-native-unix.sharedflag}" />
            <arg value="-fPIC" />
            <arg value="-I." />
            <arg value="-I" />
            <arg path="${jdk.home}/include" />
            <arg value="-I" />
            <arg path="${jif-runtime-native.java-include-dir.location}" />
            <arg value="-I" />
            <arg path="${jif-runtime-native.java-include-dir.location}/${env.OSTYPE}" />
            <arg value="-I" />
            <arg path="${jif-runtime-native.java-include-dir.location}/linux" />
            <arg value="-I" />
            <arg path="${jif-runtime-native.java-include-dir.location}/solaris" />
            <srcfile />
            <arg value="-o" />
            <targetfile />
            <fileset dir="${rt-src}" includes="jif/native/rt_unix.cpp" />
            <mapper type="merge" to="${jif-native-unix.library}" />
        </apply>
    </target>

    <!-- compile the jif runtime native code for windows -->
    <target name="jif-runtime-native-windows" if="os.isWindows">
        <echo>Compiling windows runtime</echo>
        <apply executable="g++" 
               failonerror="true"
               dest="${rt-src}" 
               skipemptyfilesets="true" 
               parallel="false" 
               vmlauncher="false">
            <arg value="-c" />
            <arg value="-I" />
            <arg path="${jdk.home}/include" />
            <arg value="-I" />
            <arg path="${jif-runtime-native.java-include-dir.location}" />
            <arg value="-I" />
            <arg path="${jif-runtime-native.java-include-dir.location}/${env.OSTYPE}" />
            <arg value="-I" />
            <arg path="${jif-runtime-native.java-include-dir.location}/win32" />
            <srcfile />
            <arg value="-o" />
            <targetfile />
            <fileset dir="${rt-src}">
                <include name="jif/native/rt_win.cpp" />
                <include name="jif/native/winac.cpp" />
            </fileset>
            <mapper type="glob" from="*.cpp" to="*.o" />
        </apply>

        <apply executable="g++" 
               failonerror="true" 
               dest="${lib}" 
               skipemptyfilesets="true" 
               parallel="true" 
               vmlauncher="false">
            <arg value="-o" />
            <targetfile />
            <arg value="-shared" />
            <arg value="-Wl,--export-all-symbols" />
            <arg value="-Wl,--add-stdcall-alias" />
            <srcfile />
            <arg value="-luser32" />
            <arg value="-ladvapi32" />
            <arg value="-luuid" />
            <arg value="-lnetapi32" />
            <fileset dir="${rt-src}">
                <include name="jif/native/*.o" />
            </fileset>
            <mapper type="merge" to="jifrt.dll" />
        </apply>
    </target>



  <!--
  ****************************************************************************
    Version-management targets
  ****************************************************************************
  -->

  <target name="bump-version">
    <antcall target="bump-patch" />
  </target>

  <target name="bump-major">
    <propertyfile file="${basedir}/version.properties">
      <entry key="version.major" type="int" operation="+" value="1"
          pattern="0" />
      <entry key="version.minor" type="int" value="0" />
      <entry key="version.patch" type="int" value="0" />
    </propertyfile>

    <!-- Reread version info and regenerate version files -->
    <antcall target="configure-buildstring" />
    <antcall target="gen-version" />
  </target>

  <target name="bump-minor">
    <propertyfile file="${basedir}/version.properties">
      <entry key="version.minor" type="int" operation="+" value="1"
          pattern="0" />
      <entry key="version.patch" type="int" value="0" />
    </propertyfile>

    <!-- Reread version info and regenerate version files -->
    <antcall target="configure-buildstring" />
    <antcall target="gen-version" />
  </target>

  <target name="bump-patch">
    <propertyfile file="${basedir}/version.properties">
      <entry key="version.patch" type="int" operation="+" value="1"
          pattern="0" />
    </propertyfile>

    <!-- Reread version info and regenerate version files -->
    <antcall target="configure-buildstring" />
    <antcall target="gen-version" />
  </target>

  <!--
  ____________________________________________________________________________
    Version-management helper targets.
  -->

  <target name="configure-buildstring" depends="configure-version"
      unless="jif.version.build">
    <tstamp>
      <format property="now" timezone="America/New_York"
          pattern="yyyy-MM-dd HH:mm:ss z" />
    </tstamp>
    <tstamp>
      <format property="year" timezone="America/New_York"
          pattern="yyyy" />
    </tstamp>
    <property name="jif.version.build" value="${jif.version} (${now})" />
  </target>

  <target name="configure-version" unless="jif.version">
    <property file="${basedir}/version.properties" prefix="jif" />
    <property name="jif.version"
        value="${jif.version.major}.${jif.version.minor}.${jif.version.patch}"/>
  </target>

  <!-- Generates version files in the source tree. -->
  <target name="gen-version">
    <antcall target="configure-buildstring" />
    <antcall target="gen-version-java" />
  </target>

  <!-- Puts version information into the Java sources. -->
  <target name="gen-version-java"
      depends="configure-buildstring">
  <!--
    Puts version information into the Java sources for one of the compilers.

    Parameters:
      name.human - Human-readable version of the name of the extension.
      name.code - Source-code version of the name of the extension.
  -->
    <echo file="${src}/jif/Version.java">package jif;

/**
 * Jif version information.
 *
 * DO NOT EDIT THIS CLASS BY HAND!  This is automatically generated by Ant.  If
 * you wish to change the version number, run one of the following:
 *
 *   ant bump-version  (Bumps the version number.)
 *   ant bump-major    (Bumps the major version number.)
 *   ant bump-minor    (Bumps the minor version number.)
 *   ant bump-patch    (Bumps the patch level.)
 */
public class Version extends polyglot.main.Version {
  @Override
  public String name() {
    return "jif";
  }

  @Override
  public int major() {
    return ${jif.version.major};
  }

  @Override
  public int minor() {
    return ${jif.version.minor};
  }

  @Override
  public int patch_level() {
    return ${jif.version.patch};
  }

  @Override
  public String toString() {
    return "${jif.version.build}";
  }
}
</echo>
  </target>



    <!-- ****************************************
       Javadoc and distribution targets
       ****************************************  -->

    <target name="jar" depends="jif">
        <jar jarfile="${lib}/jif.jar">
            <fileset refid="dist-class-files"/>
        </jar>
        <jar jarfile="${lib}/jifrt.jar" basedir="${rt-classes}" includes="jif/**" />
        <jar jarfile="${lib}/jifsig.jar" basedir="${sig-classes}" includes="jif/**, java/**" />
        <jar jarfile="${lib}/jiflib.jar" basedir="${lib-classes}" includes="jif/**" />
    </target>


    <target name="javadoc" depends="jif-base">
        <javadoc sourcepath="${src}" destdir="${basedir}/doc/jifc-api" defaultexcludes="yes" classpathref="standard.classpath">
            <packageset dir="${src}" defaultexcludes="yes">
                <include name="**" />
            </packageset>
        </javadoc>
        <javadoc sourcepath="${src}" destdir="${basedir}/doc/rt-api" defaultexcludes="yes" classpathref="standard.classpath">
            <packageset dir="${rt-src}" defaultexcludes="yes">
                <include name="**" />
            </packageset>
        </javadoc>
    </target>

    <!-- generate the Jif distribution -->
    <target name="dist"
            description="generate the distribution"
            depends="download-polyglot,configure-version">
        <!-- download-polyglot should have created the distribution directory
             already. -->

        <!-- Check out Jif from Git. -->
        <antcall target="git-clone">
            <param name="name" value="jif"/>
            <param name="root" value="${basedir}"/>
        </antcall>

        <!-- Configure the scratch copy. -->
        <concat destfile="${dist}/jif/config.properties" append="no">
            jdk.home=${jdk.home}
        </concat>

        <!-- Copy Polyglot jars into the scratch copy. -->
        <copy todir="${dist}/jif/lib">
            <fileset dir="${dist}/polyglot/lib">
                <include name="polyglot.jar"/>
                <include name="ppg.jar"/>
                <include name="pth.jar"/>
                <include name="jflex.jar"/>
                <include name="java_cup.jar"/>
            </fileset>
        </copy>

        <!-- Create the distribution zip in the scratch copy. -->
        <antcall target="sub-ant-dist">
            <param name="sub-ant.dir" value="jif"/>
            <param name="sub-ant.target" value="dist.zip"/>
        </antcall>

        <!-- Move the distribution zip out of the scratch directory. -->
        <move todir="${basedir}"
                file="${dist}/jif/jif-${jif.version}.zip"/>
    </target>

    <!--
        Downloads and extracts Polyglot to ${dist}/polyglot.
    -->
    <target name="download-polyglot"
            depends="get-polyglot-download-version">
        <property name="polyglot.download.url"
                value="${polyglot.url.prefix}${polyglot.download.version}${polyglot.url.suffix}"/>
        <get src="${polyglot.download.url}" dest="${dist}/polyglot.zip"
                verbose="on"/>
        <unzip src="${dist}/polyglot.zip" dest="${dist}"/>
        <move file="${dist}/polyglot-${polyglot.download.version}-src"
                tofile="${dist}/polyglot"/>
    </target>

    <!--
        Asks the user for the version of Poylglot to build against.
    
        ${polyglot.download.version} will be the version of Polyglot to be
        downloaded.
    -->
    <target name="get-polyglot-download-version"
            depends="configure-dependency-versions">
        <input message="Polyglot version to download?"
                defaultvalue="${polyglot.version}"
                addproperty="polyglot.download.version"/>
    </target>

    <!--
        Configures properties for dependency versions.
    -->
    <target name="configure-dependency-versions">
        <!-- Reset the distribution directory -->
        <delete dir="${dist}" />
        <mkdir dir="${dist}" />

        <!--
            Generate code that will determine the Polyglot version. This is
            done this way because we won't have Polyglot's build.properties
            file if we're only building against polyglot.jar.
        -->
        <echo file="${dist}/VersionInfo.java">
import polyglot.frontend.JLVersion;

public class VersionInfo {
  public static void main(String[] args) {
    JLVersion ver = new JLVersion();
    System.out.print(ver.major() + "." + ver.minor() + "." + ver.patch_level());
  }
}
</echo>
      <javac
              srcdir="${dist}"
              destdir="${dist}"
              includes="VersionInfo.java"
              classpathref="standard.classpath"/>
  
      <!-- Get Polyglot version. -->
      <java classname="VersionInfo" outputproperty="polyglot.version">
        <classpath>
          <pathelement location="${dist}"/>
          <path refid="standard.classpath"/>
        </classpath>
      </java>
    </target>

    <target name="dist.zip" depends="configure-buildstring">
        <!-- Create the distribution directory -->
        <mkdir dir="${dist}" />

        <!-- Clobber everything so we're in a clean state -->
        <antcall target="clobber" />

        <!-- Copy files over. -->
        <copy todir="${dist}" includeEmptyDirs="no">
            <!-- Source code -->
            <fileset refid="dist-src-files"/>

            <!-- Other files -->
            <fileset dir="${basedir}" defaultexcludes="yes">
                <!-- Scripts -->
                <include name="bin/jif" />
                <include name="bin/jifc.in" />
                <include name="bin/jc" />

                <!-- Examples (only include battleship at the moment) -->
                <include name="examples/battleship/**" />
                <include name="examples/*" />

                <!-- Test programs & principals -->
                <include name="tests/*" />
                <include name="tests/labelparam/*" />
                <exclude name="tests/directory/**" />
                <exclude name="tests/BASELINE-RESULTS" />
                <include name="tests/jif/principals/**" />

                <!-- Miscellaneous -->
                <include name="LICENSE.LGPL" />
                <include name="CHANGES" />
                <include name="build.xml" />
                <include name="config.properties.in" />
                <include name="eclipse/classpath.in"/>
            </fileset>
        </copy>

        <!-- Generate files from "*.in" templates. -->
        <copy todir="${dist}">
            <fileset dir="${basedir}" includes="*.in"/>
            <mapper type="glob" from="*.in" to="*"/>
            <filterset>
                <filter token="YEAR" value="${year}"/>
                <filter token="VERSION" value="${jif.version}"/>
                <filter token="POLYGLOT_VERSION"
                        value="${polyglot.download.version}"/>
            </filterset>
        </copy>

        <!-- Create the Javadoc, and copy the documentation -->
        <antcall target="javadoc" />
        <copy todir="${dist}" includeEmptyDirs="no">
            <fileset dir="${basedir}" defaultexcludes="yes">
                <include name="doc/*api/**" />
                <include name="doc/*.html" />
                <include name="doc/*.css" />
            </fileset>
        </copy>

        <!-- Create jif.jar and copy all the jars over -->
        <antcall target="jar" />
        <copy todir="${dist}" includeEmptyDirs="no">
            <fileset dir="${basedir}" defaultexcludes="yes">
                <include name="lib/*.jar" />
            </fileset>
        </copy>

        <antcall target="make.tar" />
    </target>

    <target name="rmdir">
        <delete failonerror="false" includeemptydirs="true" dir="${dir}" />
    </target>

    <target name="make.tar" depends="configure-version"
            description="make the tar file">
        <property name="tardir" location="${basedir}/jif-${jif.version}" />
        <property name="tarfile" location="${tardir}.zip" />
        <antcall target="rmdir">
            <param name="dir" value="${tardir}" />
        </antcall>
        <move file="${dist}" tofile="${tardir}" />
        <zip destfile="${tarfile}" basedir="${basedir}" includes="jif-${jif.version}/**"
             excludes="*/classes/**" />
        <move file="${tardir}" tofile="${dist}" />
    </target>

    <!-- ****************************************
       "Reusable" targets
       ****************************************  -->

    <!-- compile a single extension.
       @param ${ext}         the name of the extension
       @param ${ext.basedir} the base directory of the extension
    -->
    <target name="compile-ext">
        <javac source="1.7" target="1.7" srcdir="${ext.basedir}/src" destdir="${classes}" encoding="UTF-8" debug="on" includes="${ext}/**">
            <classpath refid="standard.classpath" />
        </javac>
    </target>

    <!-- Build a PPG parser based on parameters supplied to the target.
       @param parser.dir    The directory, relative to $basedir, in which
                            the PPG file is located.
       @param ppg.file      The name of the PPG file.
       @param cup.file      The name of the CUP file to output.
       @param parser.class  The name to be passed to CUP with -parser.
       @param symbol.class  The name to be passed to CUP with -symbols.
   -->
    <target name="ppg-parser" depends="ppg-parser-deps" unless="ppg.parser.up-to-date">
        <java classname="ppg.PPG" fork="true" dir="${parser.dir}" output="${parser.dir}/${cup.file}" failonerror="true">
            <classpath refid="standard.classpath" />
            <arg line="${ppg.file}" />
        </java>
        <antcall target="cup-parser" />
    </target>

    <!-- Set the property ppg.parser.up-to-date if the parser is in fact
       up to date.  Called by the ppg-parser target.
   -->
    <target name="ppg-parser-deps">
        <dependset>
            <srcfileset dir="${parser.dir}" includes="${ppg.file}" />
            <targetfileset dir="${parser.dir}">
                <include name="${cup.file}" />
                <include name="${parser.class}.java" />
                <include name="${symbol.class}.java" />
            </targetfileset>
        </dependset>
        <condition property="ppg.parser.up-to-date">
            <and>
                <available file="${parser.dir}/${cup.file}" />
                <available file="${parser.dir}/${parser.class}.java" />
                <available file="${parser.dir}/${symbol.class}.java" />
            </and>
        </condition>
    </target>

    <!-- Build a CUP parser based on parameters supplied to the target.
       @param parser.dir    The directory, relative to $basedir, in which
                            the CUP file is located.
       @param parser.class  The name to be passed to CUP with -parser.
       @param symbol.class  The name to be passed to CUP with -symbols.
       @param cup.file      The name of the CUP file.
   -->
    <target name="cup-parser" depends="cup-parser-using-jar" unless="cup.parser.up-to-date">
    </target>

    <!-- The following target builds a cup parser using the version of
       cup already sitting in the java_cup.jar file. This is needed to
       allow the building of cup to be bootstrapped. -->
    <target name="cup-parser-using-jar" depends="cup-parser-deps" unless="cup.parser.up-to-date">
        <java classname="java_cup.Main" fork="true" dir="${parser.dir}" failonerror="true">
            <classpath refid="standard.classpath" />
            <arg line="-parser ${parser.class} -symbols ${symbol.class} ${cup.file}" />
        </java>
    </target>

    <!-- Set the property cup.parser.up-to-date if the parser is in fact
       up to date.  Called by the cup-parser-using-jar target.
   -->
    <target name="cup-parser-deps">
        <dependset>
            <srcfileset dir="${parser.dir}" includes="${cup.file}" />
            <targetfileset dir="${parser.dir}">
                <include name="${parser.class}.java" />
                <include name="${symbol.class}.java" />
            </targetfileset>
        </dependset>
        <condition property="cup.parser.up-to-date">
            <and>
                <available file="${parser.dir}/${parser.class}.java" />
                <available file="${parser.dir}/${symbol.class}.java" />
            </and>
        </condition>
    </target>

    <!-- Build a JFlex lexer based on parameters supplied to the target.
       @param lexer.dir     The directory, relative to $basedir, in which
                            the JFlex file is located.
       @param lexer.class   The name of the lexer as declared with %class
                            in the JFlex file.
       @param jflex.file    The name of the JFlex file.
   -->
    <target name="jflex-lexer" depends="jflex-lexer-deps" unless="jflex.lexer.up-to-date">
        <java classname="jflex.Main" fork="true" dir="${lexer.dir}" failonerror="true">
            <classpath refid="standard.classpath" />
            <arg line="--noinputstreamctor" />
            <arg line="${jflex.file}" />
        </java>
    </target>

    <!-- Set the property jflex.lexer.up-to-date if the lexer is in fact
       up to date.  Called by the jflex-lexer target.
   -->
    <target name="jflex-lexer-deps">
        <dependset>
            <srcfileset dir="${lexer.dir}" includes="${jflex.file}" />
            <targetfileset dir="${lexer.dir}" includes="${lexer.class}.java" />
        </dependset>
        <available property="jflex.lexer.up-to-date" file="${lexer.dir}/${lexer.class}.java" />
    </target>


    <!-- Build the quasi-quote parser and lexer for an extension, assuming the
       standard names and places.
       @param ext    The extension name.
   -->
    <target name="standard-ext-qq">
        <antcall target="jflex-lexer">
            <param name="lexer.dir" value="${ext.basedir}/src/${ext}/qq" />
            <param name="lexer.class" value="Lexer_c" />
            <param name="jflex.file" value="qq.flex" />
        </antcall>
        <antcall target="ppg-parser">
            <param name="parser.dir" value="${ext.basedir}/src/${ext}/qq" />
            <param name="ppg.file" value="qq.ppg" />
            <param name="cup.file" value="qq_ppg.cup" />
            <param name="parser.class" value="Grm" />
            <param name="symbol.class" value="sym" />
        </antcall>
    </target>

    <!-- Build the PPG parser for an extension, assuming that
       it is located in the standard place and named
       the standard name that we usually use.
       @param ext    The extension name.
   -->
    <target name="standard-ext-ppg-parser">
        <antcall target="ppg-parser">
            <param name="parser.dir" value="${ext.basedir}/src/${ext}/parse" />
            <param name="ppg.file" value="${ext}.ppg" />
            <param name="cup.file" value="${ext}_ppg.cup" />
            <param name="parser.class" value="Grm" />
            <param name="symbol.class" value="sym" />
        </antcall>
    </target>

    <!-- Build the CUP parser for an extension, assuming that
       it is located in the standard place and named
       the standard name that we usually use.
       @param ext    The extension name.
   -->
    <target name="standard-ext-cup-parser">
        <antcall target="cup-parser">
            <param name="parser.dir" value="${ext.basedir}/src/${ext}/parse" />
            <param name="cup.file" value="${ext}.cup" />
            <param name="parser.class" value="Grm" />
            <param name="symbol.class" value="sym" />
        </antcall>
    </target>

    <!-- Build the lexer for an extension, assuming that
       they it is located in the standard place and named
       the standard name that we usually use.
       @param ext    The extension name.
   -->
    <target name="standard-ext-lexer">
        <antcall target="jflex-lexer">
            <param name="lexer.dir" value="${ext.basedir}/src/${ext}/parse" />
            <param name="lexer.class" value="Lexer_c" />
            <param name="jflex.file" value="${ext}.flex" />
        </antcall>
    </target>

    <target name="standard-ext-qq-dep" if="has-qq">
        <antcall target="standard-ext-qq" />
    </target>

    <!-- Build a standard extension
       @param ext          The name of the extension.
       @param ext.basedir  The base directory of the extension.
       @param parser.type  Either "cup" or "ppg".
       @param has-qq       Pass in iff the extension has a qq package.
   -->
    <target name="standard-ext">
        <antcall target="standard-ext-lexer" />
        <antcall target="standard-ext-${parser.type}-parser" />
        <antcall target="standard-ext-qq-dep" />
        <antcall target="compile-ext" />
    </target>

    <!--
        Clones a fresh copy of a project from Git into ${dist}.
    
        Parameters:
            root - the Git URL to check out
            name - the name of the destination in ${dist}.
    -->
    <target name="git-clone">
        <!-- First, clone. -->
        <exec executable="git" failonerror="true">
            <arg value="clone" />
            <arg value="-q" />
            <arg value="${root}" />
            <arg value="${dist}/${name}" />
        </exec>
    </target>
  
    <!--
        Runs an Ant target in the ${dist} scratch area.
    
        Parameters:
            sub-ant.dir - the subdirectory in ${dist} in which to find the
                          build.xml file.
            sub-ant.target - the target to run.
    -->
    <target name="sub-ant-dist">
        <ant inheritAll="false"
                antfile="${dist}/${sub-ant.dir}/build.xml"
                dir="${dist}/${sub-ant.dir}"
                target="${sub-ant.target}">
            <!-- Hack: pass down the downloaded Polyglot version in case we are
                 building a distribution. -->
            <property name="polyglot.download.version"
                    value="${polyglot.download.version}"/>
        </ant>
    </target>

</project>

<!-- vim: ts=4 sw=4 ai et
-->

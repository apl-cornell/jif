/*
 * @(#)Class.java	1.107 00/02/02
 *
 * Copyright 1994-2000 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * This software is the proprietary information of Sun Microsystems, Inc.  
 * Use is subject to license terms.
 * 
 */

package java.lang;

//  import java.lang.reflect.Member;
//  import java.lang.reflect.Field;
//  import java.lang.reflect.Method;
//  import java.lang.reflect.Constructor;
//  import java.lang.reflect.Modifier;
//  import java.io.InputStream;
//  import java.io.ObjectStreamClass;
//  import java.io.ObjectStreamField;


public final
    class Class /*implements java.io.Serializable*/ {
    private static int __JIF_SIG_OF_JAVA_CLASS$20030619 = 0;


	//    private static native void registerNatives();
//      static {
//          registerNatives();
//      }


    /*
     * Constructor. Only the Java Virtual Machine creates Class
     * objects.
     */
    private Class() {}

    public String{this} toString() {
        return (isInterface() ? "interface " : (isPrimitive() ? "" : "class "))
            + getName();
    }

    public native static Class{className} forName(String className) 
                throws (ClassNotFoundException);

    public native static Class forName(String name, boolean initialize,
				Object loader)
        throws (ClassNotFoundException);

    /** Called after security checks have been made. */
//      private static native Class forName0(String name, boolean initialize,
//  					 ClassLoader loader)
//  	throws (ClassNotFoundException);


//      public Object newInstance() 
//          throws (InstantiationException, IllegalAccessException)
//      {
//  	if (System.getSecurityManager() != null) {
//  	    checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
//  	}
//  	return newInstance0();
//      }

//      private native Object newInstance0()
//          throws (InstantiationException, IllegalAccessException);
//      public native boolean isInstance(Object obj);

      public native boolean{this} isAssignableFrom(Class{this} cls);
      public native boolean{this} isInterface();
      public native boolean{this} isArray();
      public native boolean{this} isPrimitive();
      public native String{this} getName();


//      public ClassLoader getClassLoader() {
//          ClassLoader cl = getClassLoader0();
//          if (cl == null)
//              return null;
//          SecurityManager sm = System.getSecurityManager();
//          if (sm != null) {
//              ClassLoader ccl = ClassLoader.getCallerClassLoader();
//              if (ccl != null && ccl != cl && !cl.isAncestor(ccl)) {
//                  sm.checkPermission(ClassLoader.getGetClassLoaderPerm());
//              }
//          }
//          return cl;
//      }


//      private native ClassLoader getClassLoader0();


//      public native Class getSuperclass();


//      public Package getPackage() {
//          return Package.getPackage(this);
//      }


//      public native Class[] getInterfaces();


//      public native Class getComponentType();


//      public native int getModifiers();


//      public native Object[] getSigners();
        

//      native void setSigners(Object[] signers);


//      public native Class getDeclaringClass();


//      public native Class[] getClasses();
//  //      public Class[] getClasses() {
//  //  	// be very careful not to change the stack depth of this
//  //  	// checkMemberAccess call for security reasons 
//  //  	// see java.lang.SecurityManager.checkMemberAccess
//  //          checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());

//  //  	// Privileged so this implementation can look at DECLARED classes,
//  //  	// something the caller might not have privilege to do.  The code here
//  //  	// is allowed to look at DECLARED classes because (1) it does not hand
//  //  	// out anything other than public members and (2) public member access
//  //  	// has already been ok'd by the SecurityManager.

//  //  	Class[] result = (Class[]) java.security.AccessController.doPrivileged
//  //  	    (new java.security.PrivilegedAction() {
//  //  	        public Object run() {
//  //  		    java.util.List list = new java.util.ArrayList();
//  //  		    Class currentClass = Class.this;
//  //  		    while (currentClass != null) {
//  //  			Class[] members = currentClass.getDeclaredClasses();
//  //  			for (int i = 0; i < members.length; i++) {
//  //  			    if (Modifier.isPublic(members[i].getModifiers())) {
//  //  				list.add(members[i]);
//  //  			    }
//  //  			}
//  //  			currentClass = currentClass.getSuperclass();
//  //  		    }
//  //  		    return list.toArray(new Class[0]);
//  //  		}
//  //  	    });

//  //          return result;
//  //      }


//      public Field[] getFields() throws (SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
//          return getFields0(Member.PUBLIC);
//      }


//      public Method[] getMethods() throws (SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
//          return getMethods0(Member.PUBLIC);
//      }


//      public Constructor[] getConstructors() throws (SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
//          return getConstructors0(Member.PUBLIC);
//      }


//      public Field getField(String name)
//          throws (NoSuchFieldException, SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
//          return getField0(name, Member.PUBLIC);
//      }


//      public Method getMethod(String name, Class[] parameterTypes)
//          throws (NoSuchMethodException, SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
//          return getMethod0(name, parameterTypes, Member.PUBLIC);
//      }


//      public Constructor getConstructor(Class[] parameterTypes)
//          throws (NoSuchMethodException, SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.PUBLIC, ClassLoader.getCallerClassLoader());
//          return getConstructor0(parameterTypes, Member.PUBLIC);
//      }


//      public Class[] getDeclaredClasses() throws (SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
//          return getDeclaredClasses0();
//      }


//      public Field[] getDeclaredFields() throws (SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
//          return getFields0(Member.DECLARED);
//      }


//      public Method[] getDeclaredMethods() throws (SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
//          return getMethods0(Member.DECLARED);
//      }


//      public Constructor[] getDeclaredConstructors() throws (SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
//          return getConstructors0(Member.DECLARED);
//      }


//      public Field getDeclaredField(String name)
//          throws (NoSuchFieldException, SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
//          return getField0(name, Member.DECLARED);
//      }


//      public Method getDeclaredMethod(String name, Class[] parameterTypes)
//          throws (NoSuchMethodException, SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
//          return getMethod0(name, parameterTypes, Member.DECLARED);
//      }


//      public Constructor getDeclaredConstructor(Class[] parameterTypes)
//          throws (NoSuchMethodException, SecurityException) {
//  	// be very careful not to change the stack depth of this
//  	// checkMemberAccess call for security reasons 
//  	// see java.lang.SecurityManager.checkMemberAccess
//          checkMemberAccess(Member.DECLARED, ClassLoader.getCallerClassLoader());
//          return getConstructor0(parameterTypes, Member.DECLARED);
//      }


//      public InputStream getResourceAsStream(String name) {
//          name = resolveName(name);
//          ClassLoader cl = getClassLoader0();
//          if (cl==null) {
//              // A system class.
//              return ClassLoader.getSystemResourceAsStream(name);
//          }
//          return cl.getResourceAsStream(name);
//      }


//      public java.net.URL getResource(String name) {
//          name = resolveName(name);
//          ClassLoader cl = getClassLoader0();
//          if (cl==null) {
//              // A system class.
//              return ClassLoader.getSystemResource(name);
//          }
//          return cl.getResource(name);
//      }


//      private static RuntimePermission getPDperm;


//      private static java.security.ProtectionDomain allPermDomain;


//      public java.security.ProtectionDomain getProtectionDomain() {
//          SecurityManager sm = System.getSecurityManager();
//          if (sm != null) {
//              if (getPDperm == null)
//                  getPDperm = new RuntimePermission("getProtectionDomain");
//              sm.checkPermission(getPDperm);
//          }
//          java.security.ProtectionDomain pd = getProtectionDomain0();
//          if (pd == null) {
//              if (allPermDomain == null) {
//                  java.security.Permissions perms = 
//                      new java.security.Permissions();
//                  perms.add(new java.security.AllPermission());
//                  allPermDomain = 
//                      new java.security.ProtectionDomain(null, perms);
//              }
//              pd = allPermDomain;
//          }
//          return pd;
//      }


//      private native java.security.ProtectionDomain getProtectionDomain0();


//      native void setProtectionDomain0(java.security.ProtectionDomain pd);


//      /*
//       * Return the Virtual Machine's Class object for the named
//       * primitive type.
//       */
//      static native Class getPrimitiveClass(String name);


//      /*
//       * Check if client is allowed to access members.  If access is denied,
//       * throw a SecurityException.
//       *
//       * Be very careful not to change the stack depth of this checkMemberAccess
//       * call for security reasons reasons see
//       * java.lang.SecurityManager.checkMemberAccess
//       *
//       * <p> Default policy: allow all clients access with normal Java access
//       * control.
//       */
//      private void checkMemberAccess(int which, ClassLoader ccl) {
//          SecurityManager s = System.getSecurityManager();
//          if (s != null) {
//              s.checkMemberAccess(this, which);
//  	    ClassLoader cl = getClassLoader0();
//              if ((ccl != null) && (ccl != cl) && 
//                    ((cl == null) || !cl.isAncestor(ccl))) {
//  		String name = this.getName();
//  		int i = name.lastIndexOf('.');
//  		if (i != -1) {
//  		    s.checkPackageAccess(name.substring(0, i));
//  		}
//  	    }
//  	}
//      }

//      private String resolveName(String name) {
//          if (name == null) {
//              return name;
//          }
//          if (!name.startsWith("/")) {
//              Class c = this;
//              while (c.isArray()) {
//                  c = c.getComponentType();
//              }
//              String baseName = c.getName();
//              int index = baseName.lastIndexOf('.');
//              if (index != -1) {
//                  name = baseName.substring(0, index).replace('.', '/')
//                      +"/"+name;
//              }
//          } else {
//              name = name.substring(1);
//          }
//          return name;
//      }


//      private native Field[] getFields0(int which);
//      private native Method[] getMethods0(int which);
//      private native Constructor[] getConstructors0(int which);
//      private native Field getField0(String name, int which);
//      private native Method getMethod0(String name, Class[] parameterTypes,
//          int which);
//      private native Constructor getConstructor0(Class[] parameterTypes,
//          int which);
//      private native Class[] getDeclaredClasses0();


//      private static final long serialVersionUID = 3206093459760846163L;


//      private static final ObjectStreamField[] serialPersistentFields = 
//          ObjectStreamClass.NO_FIELDS;
}


# pth test script
#
# This file is a test script for pth (Polyglot Test Harness). It
# conforms to the following grammar.
#
#      ScriptFile   ::= CompilerTest+
#      CompilerTest ::= ExtClassName ["CmdLineArgs"] { FileTest [; FileTest]* }
#      FileTest     ::= Filenames [Description] [FailureSet]
#      Filenames    ::= Filename [Filename]*
#      Description  ::= LitString
#      FailureSet   ::= Failure [, Failure]*
#      Failure      ::= ( ErrorKind )
#                    |  ( ErrorKind, "RegExp" )
#                    |  ( "RegExp" )
#                    |  ( )
#      ErrorKind    :   one of, or a unique prefix of one of the following
#                       strings: "Warning", "Internal Error", "I/O Error",
#                       "Lexical Error", "Syntax Error", "Semantic Error"
#                       or "Post-compiler Error".
#      Filename     :   the name of a file. Is interpreted from the
#                       directory where pth is run.
#      LitString    :   a literal string, enclosed in quotes.
#      RegExp       :   a regular expression, as in java.util.regex;
#                       is always enclosed in quotes.
#      CmdLineArgs  :   additional command line args for the Polyglot
#                       compiler; is always enclosed in quotes.
#
# When invoking this script, it will probably be necessary to supply
# an appropriate class path, to make sure that pth can find the Jif compiler.
#    $ pth pthScript -cp "../classes:../lib-classes:../lib/jif.jar:../lib/jiflib.jar:."

jif.ExtensionInfo  "-sigcp ../sig-classes:../lib/jifsig.jar -rtcp ../rt-classes:../lib/jifrt.jar" {
        OwnedObject.jif;
        LabeledObject.jif;
        TestPrincipal.jif;
        TestClosure.jif;
	A.jif ;
	Account.jif ;
	ActsFor1.jif ;
	ActsFor2.jif ;
	ActsFor3.jif ;
	ActsFor4.jif ;
	ActsFor5.jif ;
	ActsFor6.jif ;
	ActsFor7.jif (Semantic, "not less restrictive");
	ActsFor8.jif ;
	ActsFor9.jif (Semantic, "actsfor .* can only be used");
	ActsFor10.jif ;
	ActsFor11.jif (Semantic, "not less restrictive");
	ActsFor12.jif (Semantic, "not less restrictive");
	ActsFor13.jif ;
	ActsFor14.jif ;
	ActsFor15.jif (Semantic, "not less restrictive");
	ActsFor16.jif (Semantic, "Only a final access path"),
		      (Semantic, "Only a final access path");
	ActsFor17.jif (Semantic, "Non-final local variable"),
		      (Semantic, "Non-final local variable");
	ArgLabel1.jif ;
	ArgLabelSubst.jif ;
	ArgLabelSubst2.jif ;
	Array.jif ;
	Array1.jif (Semantic, "not a subtype") ;
	Array2.jif ;
	Array3.jif ;
	ArrayLeak.jif (Semantic, "not a subtype") ;
	ArrayLeak2.jif (Semantic, "not a subtype") ;
	Authority01.jif ;
	Authority02.jif ;
	Authority03.jif ;
	Authority04.jif (Semantic, "type of a dynamic principal must be"),
	                (Semantic, "type of a dynamic principal must be") ;
	Authority05.jif (Semantic, "Cannot cast the expression of type"),
	                (Semantic, "Cannot cast the expression of type"),
	                (Semantic, "Cannot cast the expression of type");
	Authority06.jif ;
	Authority07.jif ;
	BadNullExcept1.jif (Semantic, "NullPointerException.*must .* be caught") ;
	BadNullExcept2.jif (Semantic, "NullPointerException.*must .* be caught") ;
	BadNullExcept3.jif (Semantic, "NullPointerException.*must .* be caught") ;
	BadNullExcept4.jif (Semantic, "ArrayIndex.*Exception.*must .* be caught") ;
	BadNullExcept5.jif (Semantic, "NullPointerException.*must .* be caught") ;
	BadNullExcept6.jif (Semantic, "ArrayIndex.*Exception.*must .* be caught") ;
	BadNullExcept7.jif (Semantic, "NullPointerException.*must .* be caught") ;
	Binary.jif ;
	Call1.jif ;
	Call2.jif ;
	Call3.jif (Semantic, "The caller must have the authority of the principal") ;
	Call4.jif (Semantic, "The caller must have the authority of the principal") ;
	Call5.jif (Semantic, "The caller must have the authority of the principal") ;
	Call6.jif ;
	Call7.jif ;
	Call8.jif ;
	Call9.jif (Semantic, "The principal .* must act for") ;
	Call10.jif (Semantic, "The principal .* must act for") ;
	Call11.jif (Semantic, "The principal .* must act for") ;
	Call12.jif ;
	Call13.jif ;
	Call14.jif ;
	cat.jif ;
	Catch01.jif (Semantic, "Label of .* exceptions .* not less restrictive");
	Catch02.jif (Semantic, "Label .* not less restrictive");
	Catch03.jif (Semantic, "Label .* not less restrictive");
	clientEmptyList.jif ;
	clientList.jif ;
	clientPairList.jif ;
	Complex.jif ;
	CondExpr.jif ;
	CondExpr2.jif ; 
	CondExpr3.jif (Semantic, "not a subtype") ; 
	CondExpr4.jif (Semantic, "not a subtype") ; 
	CondExpr5.jif ; 
	CondExpr6.jif (Semantic, "not a subtype") ; 
	ConditionalLeak.jif (Semantic, "not a subtype") ;
	Constraints1.jif ;
	Constraints3.jif ;
	Constraints5.jif ;
	ConstructorTest.jif ;
	Declassify.jif ;
	Default1.jif ;
	Deref.jif ;
	Deref2.jif ;
	DuplicateClass.jif (Semantic, "Duplicate class");
	Dyn1.jif ;
	Dyn2.jif ;
	Dyn4.jif ;
	Dyn5.jif ;
	Dyn6.jif ;
	Dyn7.jif ;
	DynPrin1.jif ;
	DynPrin2.jif (Semantic, "Non-final.*access path");
	DynPrin3.jif (Semantic, "type .*must be .*principal");
	DynPrin4.jif (Semantic, "Cannot access field .* non-reference");
	DynPrin5.jif (Semantic, "type .*must be .*principal");
	DynPrin6.jif (Semantic, "Field.*is not final");
	DynPrin7.jif ;
	DynPrin8.jif (Syntax);
	DynPrin9.jif ;
	DynPrin10.jif ; 
	DynPrin11.jif (Semantic, "actual argument is more restrictive");
	DynLabel1.jif ;
	DynLabel2.jif (Semantic, "Non-final.*access path"), (Semantic, "Non-final.*access path");
	DynLabel3.jif (Semantic, "Field.*is not final"), (Semantic, "Field.*is not final");
	DynLabel4.jif (Semantic, "type .*must be .*label");
	DynLabel5.jif (Semantic, "type .*must be .*label");
	DynLabel6.jif (Semantic, "Cannot access field .* non-reference type");
	DynLabel7.jif (Syntax);
	EmptyList.jif List.jif;
	EmptyList2.jif ;
	Exc.jif ;
	Exc2.jif ;
	FieldLeak.jif (Semantic) ;
	FieldParam1.jif  ;
	FieldParam2.jif  ;
	FileTester.jif ;
	For1.jif ;
	Hierarchy1.jif ;
	Heapsort.jif ;
	Hello.jif ;
	HiRefLowField.jif (Semantic, "Label .* not less restrictive");
	If1.jif ;
	Implicit.jif ;
	Implicit2.jif ;
	IntPair.jif ;
	InterfaceTest.jif ;
#	InvariantClass.jif (Semantic, "Invariant class .* cannot extend covariant class");
#	InvariantClass1.jif (Semantic, "not a subtype");
#	InvariantClass2.jif (Semantic, "Covariant class .* cannot extend invariant class");
	InvariantClass3.jif;
#	InvariantClass4.jif (Semantic, "not a subtype");
#	InvariantClass4a.jif ;
#	InvariantClass5.jif ;
#	InvariantClass6.jif (Semantic, "not a subtype");
#	InvariantClass7.jif (Semantic, "Invariant class .* cannot implement covariant interface");
#	InvariantClass8.jif (Semantic, "Invariant class .* cannot implement covariant interface");
#	InvariantClass9.jif (Semantic, "Covariant class .* cannot extend invariant class");
	InvariantThis1.jif ;
	InvariantThis2.jif (Semantic, "can not contain .*this");
	InvariantThis3.jif (Semantic, "can not contain .*this");
	InvariantThis4.jif (Semantic, "can not contain .*this");
	LabelIf1.jif ;
	LabelIf2.jif (Semantic, "only be used in an if statement");
	LabelIf3.jif (Semantic, "only be used in an if statement");
	LabelIf4.jif ;
	LabelIf5.jif ;
	LabelIf6.jif (Semantic, "not less restrictive");
	LabelIf6a.jif (Semantic, "not less restrictive");
	LabelIf7.jif (Semantic, "not less restrictive");
	LabelIf7a.jif (Semantic, "not less restrictive");
	LabelIf8.jif (Semantic, "not less restrictive");
	LabelIf9.jif (Semantic, "not less restrictive");
	LabelIf10.jif (Semantic, "NullPointerException.*declared");
	LabelIf11.jif  (Semantic, "must .* final access path"), (Semantic, "must .* final access path");
	LabelIf12.jif ;
	List.jif ;
	List2.jif ;
	ListTest.jif ;
	Main1.jif (Warning, "signature of.*main method.*should either be"),
                  (Semantic, "Only one static method named \"main\" allowed per class");
	Main2.jif ;
	MyInteger.jif ;
	NewLabel.jif ;
	NewLabel2.jif ;
	NewLabel3.jif (Semantic, "not representable at runtime");
	NewLabel4.jif (Semantic, "not representable at runtime");
	NullExcept1.jif ;
	NullExcept2.jif ;
	NullExcept3.jif ;
	NullExcept4.jif ;
	NullExcept5.jif ;
	NullExcept6.jif ;
	NullExcept7.jif ;
	NullExcept8.jif ;
	NullExcept9.jif ;
	NullExcept10.jif ;
	NullExcept11.jif (Semantic, "NullPointerException.*must .* be caught") ;
	NullExcept12.jif (Semantic, "NullPointerException.*must .* be caught") ;
	NullExcept13.jif (Semantic, "NullPointerException.*must .* be caught") ;
	NullExcept14.jif ;
	NullExcept15.jif (Semantic, "NullPointerException.*must .* be caught") ;
	NullExcept16.jif ;
	NullExcept17.jif (Semantic, "NullPointerException.*must .* be caught") ;
	PairList.jif  List.jif;
	PairList2.jif ;
	Params1.jif ;
	Params1Test.jif ;
	Params1TestTest.jif ;
	Params2.jif ;
	Params3.jif ;
	Params4.jif ;
	Params5.jif ;
	Params6.jif ;
	Params7.jif ;
	Params8.jif ;
	Params9.jif ;
	Params10.jif ;
	Params11.jif ;
	Params12.jif ;
	Params13.jif ;
	Params14.jif (Semantic, "not instantiate .* invariant .* parameter with .* non-invariant");
	Params15.jif ; 
	Params16.jif ;
	Params17.jif ;
	Params18.jif ;
	Params19.jif ; //(Semantic, "not a subtype"); // I think there is an instantiation missing in this test case!
	Params20.jif ;
	Params21.jif ;
	Params22.jif (Semantic, "cannot be more restrictive");
	Params22a.jif (Semantic, "cannot be less restrictive");
	Params23.jif ;
	Params24.jif (Semantic, "static field cannot use .* label parameter");
	Params25.jif (Semantic, "Cannot use .* in this scope");
	Params26.jif (Semantic, "Could not find field");
	Params27.jif (Semantic, "Can not instantiate .* with a non-label");
	Params28.jif (Semantic, "Can not instantiate .* with a non-label");
	Params29.jif (Semantic, "Can not instantiate .* with a non-principal");
	Params30.jif (Semantic, "Can not instantiate .* with a non-principal");
	Params31.jif (Semantic, "Cannot instantiate from a non-polymorphic type");
	Params32.jif (Semantic, "Too many parameters");
	Params33.jif (Semantic, "Wrong number of actual parameters");
	Params34.jif ;
	Params35.jif (Semantic, "Illegal principal parameter");
	ParamsActsFor.jif ;
	Password.jif ;
	Password2.jif ;
	Poly.jif ;
	Protected.jif ;
	Recursive.jif ;
	RuntimeParams01.jif ;
	RuntimeParams02.jif ;
	RuntimeParams03.jif ;
	RuntimeParams04.jif (Semantic, "does not .* support .* array of a parameterized type");
	RuntimeParams05.jif (Semantic, "does not .* support .* array of a parameterized type");
	RuntimeParams06.jif (Semantic, "does not .* support .* array of a parameterized type");
	RuntimeParams07.jif ;
	RuntimeParams08.jif (Semantic, "Cannot override");
	RuntimeParams09.jif ;
	RuntimeParams10.jif (Semantic, "Cannot override");
	RuntimeParams11.jif (Semantic, "Cannot override");
	RuntimeParams12.jif (Semantic, "Cannot override");
	RuntimeParams13.jif (Semantic, "Cannot override");
	RuntimeParams14.jif (Semantic, "Cannot cast to a parameterized Java class");
	RuntimeParams15.jif (Semantic, "Cannot perform instanceof on a parameterized Java class");
	RuntimeParams16.jif ;
	RuntimeParams17.jif (Semantic, "not less restrictive");
	RuntimeParams18.jif (Semantic, "not less restrictive");
	RuntimeParams19.jif (Semantic, "not less restrictive");
	RuntimeParams20.jif (Semantic, "not less restrictive");
	RuntimeParams21.jif (Semantic, "not less restrictive");
	RuntimeParams22.jif (Semantic, "Calling context does not have enough authority");
	RuntimeParams22a.jif (Semantic, "Calling context does not have enough authority");
	RuntimeParams23.jif (Semantic, "NullPointerException.*must either be caught"),
                            (Semantic, "NullPointerException.*must either be caught"),
                            (Semantic, "NullPointerException.*must either be caught"),
                            (Semantic, "NullPointerException.*must either be caught"),
                            (Semantic, "NullPointerException.*must either be caught"),
                            (Semantic, "NullPointerException.*must either be caught"),
                            (Semantic, "NullPointerException.*must either be caught"),
                            (Semantic, "NullPointerException.*must either be caught");
	RuntimeParams24.jif (Semantic, "The type of a dynamic label");
	RuntimeParams24a.jif (Semantic, "The type of a dynamic principal");
	RuntimeParams24b.jif (Semantic, "Can not instantiate a label parameter with a non-label");
	RuntimeParams24c.jif (Semantic, "The type of a dynamic principal");
	RuntimeParams24d.jif (Semantic, "Can not instantiate .* with a non-principal");
	RuntimeParams25.jif (Syntax);
//KNOWN BAD: needs a fix in Polyglot	RuntimeParams26.jif (Semantic, "@@@@@"); // should be an initialization error
	Simple.jif ;
	Simple2.jif ;
	Simple3.jif ;
	Simple4.jif ;
	StaticField.jif;
	StaticMethod.jif;
	StaticThis1.jif (Semantic, "this.*cannot be used in a static context");
	StaticThis2.jif (Semantic, "this.*cannot be used in a static context");
	StaticThis3.jif (Semantic, "this.*cannot be used in a static context");
	StaticThis4.jif (Semantic, "this.*cannot be used in a static context");
	StaticThis5.jif (Semantic, "this.*cannot be used in a static context");
	StaticThis6.jif ;
	StringTester.jif ;
	SubtypeChecker1.jif (Semantic, "not a subtype") ;
	SubtypeChecker2.jif ;
	SubtypeChecker3.jif (Semantic, "not a subtype") ;
	SubtypeChecker4.jif (Semantic, "Subclasses of java.lang.Throwable can not have parameters") ;
	Super1.jif (Semantic, "Constructor .* is inaccessible") ;
	Super2.jif ;
	Super3.jif (Semantic, "first statement .* must be .* constructor call") ;
	Super4.jif (Semantic, "first statement .* must be .* constructor call") ;
	Super5.jif ;
	Super6.jif (Semantic, "Final field.*must be initialized") ;
	Super7.jif (Semantic, "requires .* authority .* principal");
	Super8.jif (Semantic, "requires .* authority .* principal");
	SwitchLabel.jif (Semantic, "not representable at runtime");
	SwitchLabel2.jif (Semantic, "not representable at runtime");
	SwitchLabel3.jif (Semantic, "not representable at runtime");
	SwitchLabel4.jif;
	This1.jif ;
#	This2.jif ;
	ToString.jif (Semantic, "Cannot coerce"), (Semantic, "Cannot coerce") ;
	User1.jif ;
	Vec.jif ;
	While.jif ;
}

class DirLookup[label L] {

 static int {} x;
	/*
	static LookupResult{*lb} lookup{*lb}(label{*lb} lb, DirNode{*lb} d, DirPath[L]{*lb} path)
	{
		return lookup(d, path, 0, lb, lb);
	}
	*/

// problem: the result should have a more restrictive label in general than
// {*lb}. The caller cannot in fact predict what the label is. The result is
// always a LookupResult, so knowing the pointer to the answer *doesn't* in
// fact communicate new information. Problem is that we have no way to capture
// that. The language seems to need tuples or some way to say that
// LookupResults are special and can *only* be distinguished via their fields.
// If we write the code using a while loop, a different problem bites us. We
// can pull the LookupResult creation out to the top so its pointer is
// untainted, but we need to be able to assign 'final' variables (e.g., the
// accumulated label) on each loop iteration.  The Jif compiler needs to do
// some kind of SSA conversion to allow these assignments to be done soundly.

/*
	static LookupResult{*prev; *lb} lookup{*lb}(DirNode{*lb} d, DirPath[L]{*lb} path, int i, label{*lb} lb, label{*lb} prev)
	{
		final label retl = new label{*d.label_; L; *lb; *prev};
		int n = path.components.length;
		String nm = path.components[i];
		if (d.contains(nm)) {
			Object o = null;
			try {
				o = d.get(nm);
			} catch (Exception canthappen) {}
			if (i == n-1)
				return new LookupResult(retl, o);

			if (o instanceof DirNode) {
				final DirNode d2 = (DirNode) o;
				return lookup(d2, path, i+1, lb, retl);
			} else {
				return new LookupResult(retl, null);
			}
		} else {
			return new LookupResult(retl, null);
		}
	}
*/

	static LookupResult{*lb; L} lookup2{*lb}(label{*lb} lb, DirNode{*lb} d, DirPath[L]{*lb} path)
	{
		final label retl = new label{L; *lb};
		final DirNode{*retl} cur = d;
		Object{*retl} o = cur;
		try {
			int n = path.components.length;
			int i = 0;
			while (i < n) {
				// invariant:  cur       :   DirNode{*retl}
				//             o         :   Object {*retl}
				//             {L; *lb} <=   {*retl}

				String{L} nm = path.components[i];
				o = null;

				if (cur.contains(nm)) {
					try {
						o = cur.get(nm);                      // now      o : {*retl ; *cur.label_; L}
						retl = new label {*retl; *cur.label_} // restores o : {*retl}
					} catch (Exception canthappen) {}

					if (i == n-1) break;

					if (o instanceof DirNode) {
						cur = (DirNode) o;                    // still have cur : {*retl}
					} else {
						o = null;
						break;
					}
				}
				i++;
			}
		} catch (RuntimeException e) { throw new Error(); }

		return new LookupResult(retl, o); // ok if invariant holds
	}

}
// vim: ts=4 sw=4

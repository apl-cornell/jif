class DirLookup[label L] {

   

  


 static int {} x;
	/*
	static LookupResult{*lb} lookup{*lb}(label{*lb} lb, DirNode{*lb} d, DirPath[L]{*lb} path)
	{
		return lookup(d, path, 0, lb, lb);
	}
	*/

// problem: the result should have a more restrictive label in general than
// {*lb}. The caller cannot in fact predict what the label is. The result is
// always a LookupResult, so knowing the pointer to the answer *doesn't* in
// fact communicate new information. Problem is that we have no way to capture
// that. The language seems to need tuples or some way to say that
// LookupResults are special and can *only* be distinguished via their fields.
//
// If we write the code using a while loop (see lookup2), a different problem
// bites us. We can pull the LookupResult creation out to the top so its
// pointer is untainted, but we need to be able to assign 'final' variables
// (e.g., the accumulated label) on each loop iteration.  The Jif compiler
// needs to do some kind of SSA conversion to allow these assignments to be
// done soundly.

/*
	static LookupResult{*prev; *lb} lookup{*lb}(DirNode{*lb} d, DirPath[L]{*lb} path, int i, label{*lb} lb, label{*lb} prev)
	{
		final label retl = new label{*d.label_; L; *lb; *prev};
		int n = path.components.length;
		String nm = path.components[i];
		if (d.contains(nm)) {
			Object o = null;
			try {
				o = d.get(nm);
			} catch (Exception canthappen) {}
			if (i == n-1)
				return new LookupResult(retl, o);

			if (o instanceof DirNode) {
				final DirNode d2 = (DirNode) o;
				return lookup(d2, path, i+1, lb, retl);
			} else {
				return new LookupResult(retl, null);
			}
		} else {
			return new LookupResult(retl, null);
		}
	}
*/


    class Invariant[label retll] {
        label{retll} retl;
        DirNode{*retl} cur;

        //invariant {*retl} <= {retll};
        invariant retll <= retl;

        Invariant(label{retll} l, DirNode{*l} cur_) 
            where {retll} <= {*l} {
                retl=l;
                cur=cur_;
        }
    }

	static LookupResult{*lb; L} lookup2{*lb}(label{*lb} lb, DirNode{*lb} d, DirPath[L]{*lb} path) {
		final label{*lb} retl = new label{L; *lb};
		final DirNode{*retl} cur = d;
        label dummy = new label {};
		Object{*retl} o = cur;

		try {
			int n = path.components.length;
			int i = 0;
            Invariant[*lb; L] inv_mutable = new Invariant(retl, cur);
			while (i < n) {
                final Invariant inv = inv_mutable;
				// invariant:  cur       :   DirNode{*retl}

				String{L; *lb; *inv.retl} nm = path.components[i];

                if (!inv.cur.contains(nm)) return null;

                try {
                    final Object{L; *lb; *inv.retl} o2 = inv.cur.get(nm);
                    final label retl2 = new label {L; *lb; *inv.retl; *inv.cur.label_} // restores o : {*retl}

                    if (i == n-1) return new LookupResult(inv.retl, o2);

                    if (!o instanceof DirNode) throw new Error();

                    final DirNode{*retl2} cur2 = (DirNode)o2;

                    inv_mutable = new Invariant(retl2, cur2);

                    i++;
                } catch (Exception canthappen) {}
			}
		} catch (RuntimeException e) { throw new Error(); }

		return new LookupResult(retl, o); // ok if invariant holds
	}

}
// vim: ts=4 sw=4

/**
 * This class represents a Ship in the BattleShip game.
 *
 * A ship has a length, a coordinate for the bottom left position, and 
 * a flag indicating whether the ship is laid out horizontally or vertically.  
 *
 * It is parameterized by the label L, which is the level of information 
 * that the ship contains.
 */
public class Ship[label L] implements JifObject[{_->_;*<-*}] {
    /**
     * The bottom left position of the ship. ( i.e., minimum 
     * values of x and y coords that the ship covers)
     */
    final Coordinate[{_->_;*<-*}]{_->_;*<-*} pos;
    
    /**
     * Length of the ship.
     */  
    final int{_->_;*<-*} length;

    /**
     * Is the ship horizontal? If so, then it covers coords from
     * (pos.x, pos.y) to (pos.x+length-1, pos.y); otherwise from
     * (pos.x, pos.y) to (pos.x, pos.y+length-1).
     */
    final boolean{_->_;*<-*} isHorizontal;

    public Ship{_->_;*<-*}(Coordinate[{_->_;*<-*}]{_->_;*<-*} pos, int{_->_;*<-*} len, boolean{_->_;*<-*} isHoriz) {
        this.pos = pos;
        this.length = len;
        this.isHorizontal = isHoriz;
    }

    /**
     * Does the ship cover the co-ordinate coord?
     */
    public boolean{_->_;*<-*} covers{_->_;*<-*}(Coordinate[{_->_;*<-*}]{_->_;*<-*} coord) {
		Coordinate[{_->_;*<-*}]{_->_;*<-*} pos = this.pos;
		if (coord == null || pos == null) 
			return false;

		if (isHorizontal) {
			return coord.y == pos.y && 
			pos.x <= coord.x && 
			coord.x < pos.x + length;
		}
		else {
			return coord.x == pos.x && 
			pos.y <= coord.y && 
			coord.y < pos.y + length;
		}	
    }

    /**
     * Does this Ship intersect with the Ship ship?
     */
    public boolean{_->_;*<-*} intersects{_->_;*<-*}(Ship[{_->_;*<-*}]{_->_;*<-*} ship) {
		if (ship == null) return false;

		Coordinate[{_->_;*<-*}]{_->_;*<-*} c = this.pos;
		for (int i = 0; i < length && c != null; i++) {
			if (ship.covers(c)) 
			return true;

			if (isHorizontal) {
			c = new Coordinate[{_->_;*<-*}](c.x+1, c.y);
			}
			else {
			c = new Coordinate[{_->_;*<-*}](c.x, c.y+1);
			}
		}
		return false;
    }

    public String{_->_;*<-*} toString(){
		return null;
		//Coordinate[{_->_;*<-*}]{_->_;*<-*} pos = this.pos;
		//Coordinate[{_->_;*<-*}]{_->_;*<-*} end = null;
	
		//if (pos == null) pos = new Coordinate[{_->_;*<-*}](0,0);

		//if (isHorizontal)
		//	end = new Coordinate[{_->_;*<-*}](pos.x + length, pos.y);
		//else 
		//	end = new Coordinate[{_->_;*<-*}](pos.x, pos.y + length);

		//return pos.toString() + " to " + end.toString();
    }

    public int{_->_;*<-*} hashCode() {
		return true;
		//Coordinate[{_->_;*<-*}] pos = this.pos;
		//if (pos == null) pos = new Coordinate[{_->_;*<-*}](0,0);
		//return 
		//	pos.hashCode() ^ 
		//	(4007 * length) ^ 
		//	(isHorizontal ? 1861 : 2713);
    }

    public boolean equals(label lbl, IDComparable[{*->*;_<-_}] o) {
		if (o == null || !(o instanceof Ship[{_->_;*<-*}])) {
			return false;
		}
	    Ship[{_->_;*<-*}] that = (Ship[{_->_;*<-*}])o;
	    // use local variables to allow the NullPointerException
		// analysis to work.
		Coordinate[{_->_;*<-*}] thispos = this.pos;
		Coordinate[{_->_;*<-*}] thatpos = that.pos;
	    return this.length == that.length && 
		       this.isHorizontal == that.isHorizontal &&
		       (thispos == thatpos || 
		       (thispos != null && thispos.equals(lbl, thatpos)));
    }
    
    public boolean equals(IDComparable[{_->_;*<-*}] o) {
        return equals(new label {_->_;*<-*}, o);
    }
    
}



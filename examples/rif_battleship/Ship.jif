/**
 * This class represents a Ship in the BattleShip game.
 *
 * A ship has a length, a coordinate for the bottom left position, and 
 * a flag indicating whether the ship is laid out horizontally or vertically.  
 *
 * It is parameterized by the label L, which is the level of information 
 * that the ship contains.
 */
public class Ship[label L] implements JifObject[{_->_;*<-*}] {
    /**
     * The bottom left position of the ship. ( i.e., minimum 
     * values of x and y coords that the ship covers)
     */
    final Coordinate[{}]{} pos;
    
    /**
     * Length of the ship.
     */  
    final int{_->_;*<-*} length;

    /**
     * Is the ship horizontal? If so, then it covers coords from
     * (pos.x, pos.y) to (pos.x+length-1, pos.y); otherwise from
     * (pos.x, pos.y) to (pos.x, pos.y+length-1).
     */
    final boolean{_->_;*<-*} isHorizontal;

    public Ship{}(Coordinate[{}]{} pos, int{} len, boolean{} isHoriz) {
        this.pos = pos;
        this.length = len;
        this.isHorizontal = isHoriz;
    }

    /**
     * Does the ship cover the co-ordinate coord?
     */
    public boolean{} covers{}(Coordinate[{}]{} coord) {
		Coordinate[{}]{} pos = this.pos;
		if (coord == null || pos == null) 
			return false;

		if (isHorizontal) {
			return coord.y == pos.y && 
			pos.x <= coord.x && 
			coord.x < pos.x + length;
		}
		else {
			return coord.x == pos.x && 
			pos.y <= coord.y && 
			coord.y < pos.y + length;
		}	
    }

    /**
     * Does this Ship intersect with the Ship ship?
     */
    public boolean{} intersects{}(Ship[{}]{} ship) {
		if (ship == null) return false;

		Coordinate[{}]{} c = this.pos;
		for (int i = 0; i < length && c != null; i++) {
			if (ship.covers(c)) 
			return true;

			if (isHorizontal) {
			c = new Coordinate[{}](c.x+1, c.y);
			}
			else {
			c = new Coordinate[{}](c.x, c.y+1);
			}
		}
		return false;
    }

    public String{_->_;*<-*} toString(){
		return null;
		//Coordinate[{_->_;*<-*}]{_->_;*<-*} pos = this.pos;
		//Coordinate[{_->_;*<-*}]{_->_;*<-*} end = null;
	
		//if (pos == null) pos = new Coordinate[{_->_;*<-*}](0,0);

		//if (isHorizontal)
		//	end = new Coordinate[{_->_;*<-*}](pos.x + length, pos.y);
		//else 
		//	end = new Coordinate[{_->_;*<-*}](pos.x, pos.y + length);

		//return pos.toString() + " to " + end.toString();
    }

    public int{_->_;*<-*} hashCode() {
		return 0;
		//Coordinate[{_->_;*<-*}] pos = this.pos;
		//if (pos == null) pos = new Coordinate[{_->_;*<-*}](0,0);
		//return 
		//	pos.hashCode() ^ 
		//	(4007 * length) ^ 
		//	(isHorizontal ? 1861 : 2713);
    }

    public boolean{} equals(label lbl, IDComparable[{}] o) {
		if (o == null || !(o instanceof Ship[{}])) {
			return false;
		}
	    Ship[{}] that = (Ship[{}])o;
	    // use local variables to allow the NullPointerException
		// analysis to work.
		Coordinate[{}] thispos = this.pos;
		Coordinate[{}] thatpos = that.pos;
	    return this.length == that.length && 
		       this.isHorizontal == that.isHorizontal &&
		       (thispos == thatpos || 
		       (thispos != null && thispos.equals(lbl, thatpos)));
    }
    
    public boolean equals(IDComparable[{_->_;*<-*}] o) {
        return equals(new label {_->_;*<-*}, o);
    }
    
}



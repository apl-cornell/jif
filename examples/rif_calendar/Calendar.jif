/**
 * This class implements the calendar of user O.
 * For each event in this calendar, its slot is tagged with Ls and its description is tagged with Ld.
 */

public class Calendar[principal O, label Ls, label Ld] {

private final principal{rif[q0*:{_}];rifi[q1*:{}]} owner = O;
// List of events (shared or not shared).
private rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} eventList;
// List of shared events that have been requested by O and await to be accepted by the other user.
private rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} requestEvents;
// List of shared events that wait to be accepted by O.
private rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} pendingEvents;
// List of canceled events. We assume users are interested in keeping a log of canceled events.
private rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} canceledEvents;

public Calendar() {
    this.eventList = new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
    this.requestEvents = new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
    this.pendingEvents = new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
    this.canceledEvents = new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
}

public principal{rif[q0*:{_}];rifi[q1*:{}]} getOwner() {
    return this.owner;
}

public rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} getEventList() {
    return this.eventList;
}

// Add event e in eventList.
public void addEvent{rif[q0*:{_}];rifi[q1*:{}]}(Event[{*ls},{*ld},{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} e,
label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld) 
{
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} l2 = this.eventList;
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}] l;
    l = reclassify(l2,f9);
    Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} n;
    try{	
    n=l.add(e,ls,ld);
    e.setNode(n);}
	catch (NullPointerException impossible) {}
}

// Add requested shared event e in requestEvents list.
public void addRequestEvent{rif[q0*:{_}];rifi[q1*:{}]}(Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} e)
{
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} l2 = this.requestEvents;
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}] l;
    l = reclassify(l2,f9);
    Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} n;
    try{
    n=l.add(e,Ls,Ld);
    e.setNode(n);}
    catch (NullPointerException impossible) {}
}

// Add pending shared event e in pendingEvents list.
public void addPendingEvent{rif[q0*:{_}];rifi[q1*:{}]}(Event[{*ls},{*ld},{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} e,
label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
{
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} l2 = this.pendingEvents;
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}] l;
    l = reclassify(l2,f9);
    Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} n;
    try{	
    n=l.add(e,ls,ld);
	e.setNode(n);}
	catch (NullPointerException impossible) {}
}

// Pending shared event se is accepted by the other user. We remove se from pendingEvents list, 
// we create a copy of se with the proper label, and we add this copy in eventList.
public void acceptPendingEvent{rif[q0*:{_}];rifi[q1*:{}]}(Event[{*ls},{*ld},{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} se,
label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
where tr(ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}, ls<=ld, tr(ls,f7)<=tr(Ls,f7), tr(ld,f7)<=tr(Ld,f7),
tr(tr(Ls,f7),f9)<={rif[q0*:{_}];rifi[q1*:{}]}
{
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} pe2 = this.pendingEvents;
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}] pe = reclassify(pe2,f9);
    Event[new label tr(Ls,f7),{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} dne;

    try{
	Event[{*ls},{*ld},{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(se,f9);
	pe.remove(reclassify(e2.getNode(),f9));
	Date[{*ls}]{tr({*ls},f9)} d= reclassify(e2.getDate(),f9);
	Date[new label tr(Ls,f7)]{tr({Ls},f7)} date = 
		new Date[new label tr(Ls,f7)](reclassify(d.getDay(),f7),reclassify(d.getMonth(),f7), reclassify(d.getYear(),f7));
	TimeOfDay[{*ls}]{tr({*ls},f9)} t = reclassify(e2.getTime(),f9);
	TimeOfDay[new label tr(Ls,f7)]{tr({Ls},f7)} time = 
		new TimeOfDay[new label tr(Ls,f7)](reclassify(t.getHour(),f7),reclassify(t.getMinute(),f7));
	Event[new label tr(Ls,f7),{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} ne = 
		new Event[new label tr(Ls,f7),{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}](
		date, time, 
		reclassify(e2.getDuration(),f7), 
		reclassify(e2.getDescription(),f7), reclassify(e2.getCreatorCalNode(),f7),
		reclassify(e2.getCreatorCal(),f7), reclassify(e2.getCreator(),f7));
	dne = reclassify(ne,f9);
	dne.setBond(reclassify(e2.getBond(),f7));
    dne.setSharedBetween(reclassify(e2.getSharedBetween(),f7));
	addEvent(ne,new label tr(Ls,f7),new label tr(Ld,f7));
    }catch (NullPointerException impossible) {}
}

// Accept requested shared event se. We remove se from requestEvents list, we create a copy of se with the 
// proper label, and we add this copy in eventList.
public void requestedEventAccepted{rif[q0*:{_}];rifi[q1*:{}]}(Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} se)
where tr(Ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}
{
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} re2 = this.requestEvents;
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}] re = reclassify(re2,f9);
    try{
	Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(se,f9);
	re.remove(reclassify(e2.getNode(),f9));
	Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} e = reclassify(se,f7);
	Date[Ls]{tr({Ls},f7)} d= reclassify(e.getDate(),f7);
	Date[new label tr(Ls,f7)]{tr({Ls},f7)} date = 
		new Date[new label tr(Ls,f7)](reclassify(d.getDay(),f7),reclassify(d.getMonth(),f7), reclassify(d.getYear(),f7));
	TimeOfDay[Ls]{tr({Ls},f7)} t = reclassify(e.getTime(),f7);
	TimeOfDay[new label tr(Ls,f7)]{tr({Ls},f7)} time = 
		new TimeOfDay[new label tr(Ls,f7)](reclassify(t.getHour(),f7),reclassify(t.getMinute(),f7));
	Event[new label tr(Ls,f7),{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} ne = 
		new Event[new label tr(Ls,f7),{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}](
		date, time, 
		reclassify(e.getDuration(),f7), 
		reclassify(e.getDescription(),f7), reclassify(e.getCreatorCalNode(),f7),
		reclassify(e.getCreatorCal(),f7),reclassify(e.getCreator(),f7));
	ne.setBond(reclassify(e.getBond(),f7));
    ne.setSharedBetween(reclassify(e.getSharedBetween(),f7));			
	addEvent(ne,new label tr(Ls,f7),new label tr(Ld,f7));
    }catch (NullPointerException impossible) {}
}

// Cancel shared event se. We remove se from eventList, we create a copy of se with the proper label,
// and we add it in canceledEvents list.
public rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ld},f7)} cancelEvent
{rif[q0*:{_}];rifi[q1*:{}]}(Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} se)
where tr(tr(Ls,f7),f9)<={rif[q0*:{_}];rifi[q1*:{}]}
{
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f9);
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} ce2 = this.canceledEvents;
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}] ce = reclassify(ce2,f9);
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ld},f7)} sb = null;
    try{
	Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(se,f9);
	el.remove(reclassify(e2.getNode(),f9));
	Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({tr({Ls},f7)},f8)} e = reclassify(se,f8);
	Date[{tr({Ls},f7)}]{tr({tr({Ls},f7)},f8)} d= reclassify(e.getDate(),f8);
	Date[{tr({tr({Ls},f7)},f8)}]{tr({tr({Ls},f7)},f8)} date = 
		new Date[{tr({tr({Ls},f7)},f8)}](reclassify(d.getDay(),f8),reclassify(d.getMonth(),f8), reclassify(d.getYear(),f8));
	TimeOfDay[{tr({Ls},f7)}]{tr({tr({Ls},f7)},f8)} t = reclassify(e.getTime(),f8);
	TimeOfDay[{tr({tr({Ls},f7)},f8)}]{tr({tr({Ls},f7)},f8)} time = 
		new TimeOfDay[{tr({tr({Ls},f7)},f8)}](reclassify(t.getHour(),f8),reclassify(t.getMinute(),f8));
	Event[{tr({tr({Ls},f7)},f8)},{tr({tr({Ld},f7)},f8)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({tr({Ls},f7)},f8)} ne = 
		new Event[{tr({tr({Ls},f7)},f8)},{tr({tr({Ld},f7)},f8)},{rif[q0*:{_}];rifi[q1*:{}]}](
		date, time, 
		reclassify(e.getDuration(),f8), 
		reclassify(e.getDescription(),f8), reclassify(e.getCreatorCalNode(),f8),
		reclassify(e.getCreatorCal(),f8),reclassify(e.getCreator(),f8));
	Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} n;
	n=ce.add(ne, new label tr(tr(Ls,f7),f8), new label tr(tr(Ls,f7),f8));
	ne.setNode(n);
	sb = e.getSharedBetween();
}catch (NullPointerException impossible) {}
return sb;
}

// Given the reference number bond of a shared event, find this event in requestEvents list.
public Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} findRequestedEvent 
{rif[q0*:{_}];rifi[q1*:{}]}(int{rif[q0*:{_}];rifi[q1*:{}]} bond)
{
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} re2 = this.requestEvents;
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}] re = reclassify(re2,f9);
    int size;
    Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} fe=null;
    int i;
    try{
    size=re.getSize();
    Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = re.getHead();
	for (i=0;i<size;i++) {
		try{
			final Node[{rif[q0*:{_}];rifi[q1*:{}]}] nd = n;
			if (nd.La <= Ls){
				Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}] e = (Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]) nd.getData();
				if (e.getBond() == bond) 
					fe=e;
			}
			n=n.getNext();

		}catch (ClassCastException e) { throw new Error("ClassCastException at findRequestedEvent!");  }
	}
    }catch (NullPointerException impossible) {}
    return fe;
}

// Given the reference number bond of an accepted shared event, find this event in eventList.
public Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)}  findAcceptedEvent
{rif[q0*:{_}];rifi[q1*:{}]}	(int{rif[q0*:{_}];rifi[q1*:{}]} bond)
where tr(tr(Ls,f7),f9)<={rif[q0*:{_}];rifi[q1*:{}]}		
{
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f9);
	int size;
	Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} fe=null;
	int i;
	try{
	size=el.getSize();
	Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = el.getHead();
	for (i=0;i<size;i++) {
		try{
			final Node[{rif[q0*:{_}];rifi[q1*:{}]}] nd = n;
			if (nd.La <= new label {tr({Ls},f7)}){
				Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} de = 
					(Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]) nd.getData();
				Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} e =
                    reclassify(de,f9); 
				if (e.getBond() == bond) 
					fe=e;
			}
			n=n.getNext();

		}catch (ClassCastException e1) { throw new Error("ClassCastException at findAcceptedEvent!"); }
	}
	}catch (NullPointerException e2) {throw new Error("NullPointerException at findAcceptedEvent!");}
	return fe;
}

public String{rif[q0*:{_}];rifi[q1*:{}]} toString {rif[q0*:{_}];rifi[q1*:{}]} () 
{
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f9);
	String{rif[q0*:{_}];rifi[q1*:{}]} output=null;
	int size;
	int i;
	try{
	size=el.getSize();
	Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = el.getHead();
	for (i=0;i<size;i++) {
		try{
			final Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} nd = n;
			if (new label tr(nd.La,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]} && 
				new label tr(nd.Lb,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]}){
				Object{rif[q0*:{_}];rifi[q1*:{}]} e = reclassify(nd.getData(),f9);
				Event[nd.La,nd.Lb,{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} de =
                    (Event[nd.La,nd.Lb,{rif[q0*:{_}];rifi[q1*:{}]}]) e;
				if (output==null) output = de.toString()+ "\n";
				else output = output + de.toString() + "\n";
			}
			n=n.getNext();

		}catch (ClassCastException impossible) { }
	}
	}catch (NullPointerException impossible) {}		
	return output;
}

// Publicize the slot of event pe, which is created and owned by just this user.
public Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f1)} publicizeSlot {rif[q0*:{_}];rifi[q1*:{}]}
(Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} pe)
where tr(Ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}
{
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f9);
	Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f1)} ne = null;
	try{
		Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(pe,f9);
		el.remove(reclassify(e2.getNode(),f9));
		Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f1)} e = reclassify(pe,f1);
		Date[Ls]{tr({Ls},f1)} d= reclassify(e.getDate(),f1);
		Date[{tr({Ls},f1)}]{tr({Ls},f1)} date = 
			new Date[{tr({Ls},f1)}](reclassify(d.getDay(),f1),reclassify(d.getMonth(),f1), reclassify(d.getYear(),f1));
		TimeOfDay[Ls]{tr({Ls},f1)} t = reclassify(e.getTime(),f1);
		TimeOfDay[{tr({Ls},f1)}]{tr({Ls},f1)} time = 
			new TimeOfDay[{tr({Ls},f1)}](reclassify(t.getHour(),f1),reclassify(t.getMinute(),f1));
		ne = new Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}](
			date, time, 
			reclassify(e.getDuration(),f1), 
			e.getDescription(), reclassify(e.getCreatorCalNode(),f1),
			reclassify(e.getCreatorCal(),f1), reclassify(e.getCreator(),f1));
		addEvent(ne,new label tr(Ls,f1),Ld);
	}catch (NullPointerException impossible) {}
	return ne;
}

// Hide the slot of event pe, which is created and owned by just this user.
public Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} hideSlot {rif[q0*:{_}];rifi[q1*:{}]}
(Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f1)} pe)
where tr(tr(Ls,f1),f9)<={rif[q0*:{_}];rifi[q1*:{}]}, tr(tr(Ls,f1),f2)<=Ls, tr(Ls,f2)<=Ls, Ls<=Ld
{
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f9);
	Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} ne = null;
	try{
		Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(pe,f9);
		el.remove(reclassify(e2.getNode(),f9));
		Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} e = reclassify(pe,f2);
		if (e==null) throw new Error("Null event");
		Date[{tr({Ls},f1)}]{Ls} d= reclassify(e.getDate(),f2);
		if (d==null) throw new Error("Null date");
		Date[Ls]{Ls} date = 
			new Date[Ls](reclassify(d.getDay(),f2),reclassify(d.getMonth(),f2), reclassify(d.getYear(),f2));
		TimeOfDay[{tr({Ls},f1)}]{Ls} t = reclassify(e.getTime(),f2);
		if (t==null) throw new Error("Null time");
		TimeOfDay[Ls]{Ls} time = 
			new TimeOfDay[Ls](reclassify(t.getHour(),f2),reclassify(t.getMinute(),f2));
		ne = new Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}](
			date, time, 
			reclassify(e.getDuration(),f2), 
			e.getDescription(), e.getCreatorCalNode(),
			e.getCreatorCal(),e.getCreator());
		addEvent(ne, Ls, Ld);
	}catch (NullPointerException impossible) {}
	return ne;
}

// Collect all events (from eventList) whose slot is publicized, without including the description.
public String{rif[q0*:{_}];rifi[q1*:{}]} takePubView {rif[q0*:{_}];rifi[q1*:{}]} () {
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f9);
	String{rif[q0*:{_}];rifi[q1*:{}]} output=null;
	int size;
	int i;
	try{
	size=el.getSize();
	Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = el.getHead();
	for (i=0;i<size;i++) {
		try{
			final Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} nd = n;
			if (nd.La <= new label tr(Ls, f1)){
				if (new label tr(nd.La,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]} && 
					new label tr(nd.Lb,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]} &&
					new label tr(nd.La,f6) <= new label {rif[q0*:{_}];rifi[q1*:{}]}){
					Object{rif[q0*:{_}];rifi[q1*:{}]} e = reclassify(nd.getData(),f9);
					Event[nd.La,nd.Lb,{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} de =
                        (Event[nd.La,nd.Lb,{rif[q0*:{_}];rifi[q1*:{}]}]) e;
                    // Method toStringf6 converts event de into a string, ommiting the description.
                    // If, by mistake, the implementation of toStringf6 was not ommiting the description,
                    // then the program would not be type correct.
					if (output==null) output = de.toStringf6()+ "\n";
					else output = output + de.toStringf6() + "\n";
				}
			}
			n=n.getNext();

		}catch (ClassCastException impossible) { throw new Error("ClassCastException at takePubView!"); }
	}
	}catch (NullPointerException impossible) {}
	return output;
}

// Check if event ereq has a conflict with any of the events in eventList.
public boolean{Ls;*ls} rejectOnConflict {rif[q0*:{_}];rifi[q1*:{}]} (Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} ereq,
label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
{
	boolean{Ls;*ls} result=false;
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f9:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
	rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f9);
	int size;
	int i;
	int{Ls;*ls} eStart;
	int{Ls;*ls} eFinish;
	try{
	if (ereq==null) throw new Error("Null ereq");
	Date[ls]{*ls} ereqDt = ereq.getDate();
	TimeOfDay[ls]{*ls} ereqT = ereq.getTime();
	int{*ls} reqStart = ereqT.getHour()*60+ereqT.getMinute();
	int{*ls} reqFinish = reqStart+ ereq.getDuration();
	if (el==null) throw new Error("Null el");
	size=el.getSize();
	Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = el.getHead();
	for (i=0;i<size;i++) {
		try{
			final Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} nd = n;
			if (nd.La <= Ls && Ls <= nd.La){
				Object{Ls} ue = nd.getData();
				Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} e = (Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]) ue;
				if (e==null) throw new Error("Null e");
				TimeOfDay[Ls]{Ls} eT = e.getTime();
				Date[Ls]{Ls} eDt = e.getDate();
				if (eT==null) throw new Error("Null eT");			
				eStart = eT.getHour()*60+eT.getMinute();
				eFinish = eStart+ e.getDuration();
				if (eDt==null || ereqDt==null) throw new Error("Null eDt or ereqDt");
				if (eDt.getYear()==ereqDt.getYear() && 
					eDt.getMonth()==ereqDt.getMonth() &&
					eDt.getDay()==ereqDt.getDay() && 
					(eStart<=reqStart && reqStart<=eFinish ||
					 reqStart<=eStart && eStart<=reqFinish)){
					result=true;
				}
			}
			n=n.getNext();

		}catch (ClassCastException impossible) { throw new Error("ClassCastException at rejectOnConflict!"); }
	}
	}catch (NullPointerException impossible) {}
	return result;
}

}

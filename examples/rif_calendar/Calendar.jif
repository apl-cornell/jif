public class Calendar[principal O, label Ls, label Ld] {//policy for cal is {rif[q0*:{_}];rifi[q1*:{O},q2:{},f7:q1->q2]}
//the current state of Ls and Ld is O for conf and integ,

	private final principal{rif[q0*:{_}];rifi[q1*:{}]} owner = O;
	private rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} eventList;
	private rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} requestEvents;
	private rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} pendingEvents;
	private rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} canceledEvents;

	public Calendar() {
		this.eventList = new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
		this.requestEvents = new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
		this.pendingEvents = new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
		this.canceledEvents = new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
	}

	public principal{rif[q0*:{_}];rifi[q1*:{}]} getOwner() {
		return this.owner;
	}

	public rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} getEventList() {
		return this.eventList;
	}

	public void addEvent{rif[q0*:{_}];rifi[q1*:{}]}(Event[{*ls},{*ld},{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} e, label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld) 
	{
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} l2 = this.eventList;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] l; //does not type-check if rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} l;
		l = reclassify(l2,f3);
		Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} n;
		try{	n=l.add(e,ls,ld);  //make this change to all methods!!!
			e.setNode(n);}
		catch (NullPointerException impossible) { 
			// lt will never be null, and so nothing is learned by this declassification
		}
	}

	//the server creates one copy of a requested shared event for every participant with individual conf/integ policies
	public void addRequestEvent{rif[q0*:{_}];rifi[q1*:{}]}(Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} e){
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} l2 = this.requestEvents;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] l;
		l = reclassify(l2,f3);
		Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} n;
		try{	n=l.add(e,Ls,Ld);
			e.setNode(n);}
		catch (NullPointerException impossible) {}
	}

	public void addPendingEvent{rif[q0*:{_}];rifi[q1*:{}]}(Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} e){
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} l2 = this.pendingEvents;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] l;
		l = reclassify(l2,f3);
		Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} n;
		try{	n=l.add(e,Ls,Ld);
			e.setNode(n);}
		catch (NullPointerException impossible) {}
	}

//inconsistent syntax of tr(L,f)!!!

	public Object{rif[q0*:{_}];rifi[q1*:{}]} acceptPendingEvent{rif[q0*:{_}];rifi[q1*:{}]}(Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} se)
		where tr(Ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}, Ls<=Ld
	{
  		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} pe2 = this.pendingEvents;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] pe = reclassify(pe2,f3);
		Object{rif[q0*:{_}];rifi[q1*:{}]} p = null;
		try{
			Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(se,f9);
			pe.remove(reclassify(e2.getNode(),f9));
			Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} e = reclassify(se,f7);
			Date[Ls]{tr({Ls},f7)} d= reclassify(e.getDate(),f7);
			Date[new label tr(Ls,f7)]{tr({Ls},f7)} date = 
				new Date[new label tr(Ls,f7)](reclassify(d.getDay(),f7),reclassify(d.getMonth(),f7), reclassify(d.getYear(),f7));
			TimeOfDay[Ls]{tr({Ls},f7)} t = reclassify(e.getTime(),f7);
			TimeOfDay[new label tr(Ls,f7)]{tr({Ls},f7)} time = 
				new TimeOfDay[new label tr(Ls,f7)](reclassify(t.getHour(),f7),reclassify(t.getMinute(),f7));
			Event[new label tr(Ls,f7),{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} ne = 
				new Event[new label tr(Ls,f7),{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}](
				date, time, 
				reclassify(e.getDuration(),f7), 
				reclassify(e.getDescription(),f7), 
				reclassify(e.getCreatorCal(),f7), reclassify(e.getCreator(),f7));
			ne.setBond(reclassify(e.getBond(),f7));
		  ne.setSharedBetween(reclassify(e.getSharedBetween(),f7));
			addEvent(ne,new label tr(Ls,f7),new label tr(Ld,f7));
			p=reclassify(e2.getCreatorCal(),f9);
		}catch (NullPointerException impossible) {}
		return p;
	}

	public void requestedEventAccepted{rif[q0*:{_}];rifi[q1*:{}]}(Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} se)
		where tr(Ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}
	{
  		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} re2 = this.requestEvents;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] re = reclassify(re2,f3);
		try{
			Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(se,f9);
			re.remove(reclassify(e2.getNode(),f9));
			Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} e = reclassify(se,f7);
			Date[Ls]{tr({Ls},f7)} d= reclassify(e.getDate(),f7);
			Date[new label tr(Ls,f7)]{tr({Ls},f7)} date = 
				new Date[new label tr(Ls,f7)](reclassify(d.getDay(),f7),reclassify(d.getMonth(),f7), reclassify(d.getYear(),f7));
			TimeOfDay[Ls]{tr({Ls},f7)} t = reclassify(e.getTime(),f7);
			TimeOfDay[new label tr(Ls,f7)]{tr({Ls},f7)} time = 
				new TimeOfDay[new label tr(Ls,f7)](reclassify(t.getHour(),f7),reclassify(t.getMinute(),f7));
			Event[new label tr(Ls,f7),{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} ne = 
				new Event[new label tr(Ls,f7),{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}](
				date, time, 
				reclassify(e.getDuration(),f7), 
				reclassify(e.getDescription(),f7), 
				reclassify(e.getCreatorCal(),f7),reclassify(e.getCreator(),f7));
			ne.setBond(reclassify(e.getBond(),f7));
		  ne.setSharedBetween(reclassify(e.getSharedBetween(),f7));			
			addEvent(ne,new label tr(Ls,f7),new label tr(Ld,f7));
		}catch (NullPointerException impossible) {}
	}

	//assume se is a shared event
	public rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ld},f7)} cancelEvent
		{rif[q0*:{_}];rifi[q1*:{}]}(Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} se)
		where tr(tr(Ls,f7),f9)<={rif[q0*:{_}];rifi[q1*:{}]}

	{
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f3);
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} ce2 = this.canceledEvents;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] ce = reclassify(ce2,f3);
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ld},f7)} sb = null;
		try{
			Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(se,f9);
			el.remove(reclassify(e2.getNode(),f9));
			Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({tr({Ls},f7)},f8)} e = reclassify(se,f8);
			Date[{tr({Ls},f7)}]{tr({tr({Ls},f7)},f8)} d= reclassify(e.getDate(),f8);  //it does not work with Date[{tr({Ls},f7)}]{tr({se},f8)} d
			Date[{tr({tr({Ls},f7)},f8)}]{tr({tr({Ls},f7)},f8)} date = 
				new Date[{tr({tr({Ls},f7)},f8)}](reclassify(d.getDay(),f8),reclassify(d.getMonth(),f8), reclassify(d.getYear(),f8));
			TimeOfDay[{tr({Ls},f7)}]{tr({tr({Ls},f7)},f8)} t = reclassify(e.getTime(),f8);
			TimeOfDay[{tr({tr({Ls},f7)},f8)}]{tr({tr({Ls},f7)},f8)} time = 
				new TimeOfDay[{tr({tr({Ls},f7)},f8)}](reclassify(t.getHour(),f8),reclassify(t.getMinute(),f8));
			Event[{tr({tr({Ls},f7)},f8)},{tr({tr({Ld},f7)},f8)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({tr({Ls},f7)},f8)} ne = 
				new Event[{tr({tr({Ls},f7)},f8)},{tr({tr({Ld},f7)},f8)},{rif[q0*:{_}];rifi[q1*:{}]}](
				date, time, 
				reclassify(e.getDuration(),f8), 
				reclassify(e.getDescription(),f8), 
				reclassify(e.getCreatorCal(),f8),reclassify(e.getCreator(),f7));
			Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} n;
			n=ce.add(ne, new label tr(tr(Ls,f7),f8), new label tr(tr(Ls,f7),f8));
			ne.setNode(n);
			sb = e.getSharedBetween();
		}catch (NullPointerException impossible) {}
		return sb;
	}

	public Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} findRequestedEvent{rif[q0*:{_}];rifi[q1*:{}]}(int{rif[q0*:{_}];rifi[q1*:{}]} bond){
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} re2 = this.requestEvents;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] re = reclassify(re2,f3);
		int size;
		Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} fe=null;
		int i;
		try{
		size=re.getSize();
		Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = re.getHead();
		for (i=0;i<size;i++) {
			try{
				final Node[{rif[q0*:{_}];rifi[q1*:{}]}] nd = n;
				if (nd.La <= Ls){
					Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}] e = (Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]) nd.getData();
					if (e.getBond() == bond) 
						fe=e;
				}
				n=n.getNext();

			}catch (ClassCastException e) { throw new Error("ClassCastException 4 !");  }
		}
		}catch (NullPointerException impossible) {}
		return fe;
	}

	public Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)}  findAcceptedEvent {rif[q0*:{_}];rifi[q1*:{}]}
		(int{rif[q0*:{_}];rifi[q1*:{}]} bond)
		where tr(tr(Ls,f7),f9)<={rif[q0*:{_}];rifi[q1*:{}]}		
		{
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f3);
		int size;
		Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} fe=null;
		int i;
		try{
		size=el.getSize();
		Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = el.getHead();
		for (i=0;i<size;i++) {
			try{
				final Node[{rif[q0*:{_}];rifi[q1*:{}]}] nd = n;
				if (nd.La <= new label {tr({Ls},f7)}){
					Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f7)} de = 
						(Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]) nd.getData();
					Event[{tr({Ls},f7)},{tr({Ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} e = reclassify(de,f9); 
					if (e.getBond() == bond) 
						fe=e;
				}
				n=n.getNext();

			}catch (ClassCastException e1) { throw new Error("ClassCastException at findAcceptedEvent !"); }
		}
		}catch (NullPointerException e2) {throw new Error("NullPointerException at findAcceptedEvent !");}
		return fe;
	}

	public String{rif[q0*:{_}];rifi[q1*:{}]} toString {rif[q0*:{_}];rifi[q1*:{}]} () {
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f3);
		String{rif[q0*:{_}];rifi[q1*:{}]} output=null;
		int size;
		int i;
		try{
		size=el.getSize();
		Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = el.getHead();
		for (i=0;i<size;i++) {
			try{
				final Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} nd = n;
				if (new label tr(nd.La,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]} && 
					new label tr(nd.Lb,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]}){
					Object{rif[q0*:{_}];rifi[q1*:{}]} e = reclassify(nd.getData(),f9);
					Event[nd.La,nd.Lb,{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} de = (Event[nd.La,nd.Lb,{rif[q0*:{_}];rifi[q1*:{}]}]) e;
					if (output==null) output = de.toString()+ "\n";
					else output = output + de.toString() + "\n";
				}
				n=n.getNext();

			}catch (ClassCastException impossible) { }
		}
		}catch (NullPointerException impossible) {}		
		return output;
	}

	//applied only to events created and owned by just this user!
	public Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f1)} publicizeSlot{rif[q0*:{_}];rifi[q1*:{}]}
	(Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} pe)
	where tr(Ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}
	{
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f3);
		Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f1)} ne = null;
		try{
			Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(pe,f9);
			el.remove(reclassify(e2.getNode(),f9));
			Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f1)} e = reclassify(pe,f1);
			Date[Ls]{tr({Ls},f1)} d= reclassify(e.getDate(),f1);
			Date[{tr({Ls},f1)}]{tr({Ls},f1)} date = 
				new Date[{tr({Ls},f1)}](reclassify(d.getDay(),f1),reclassify(d.getMonth(),f1), reclassify(d.getYear(),f1));
			TimeOfDay[Ls]{tr({Ls},f1)} t = reclassify(e.getTime(),f1);
			TimeOfDay[{tr({Ls},f1)}]{tr({Ls},f1)} time = 
				new TimeOfDay[{tr({Ls},f1)}](reclassify(t.getHour(),f1),reclassify(t.getMinute(),f1));
			ne = new Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}](
				date, time, 
				reclassify(e.getDuration(),f1), 
				e.getDescription(), 
				reclassify(e.getCreatorCal(),f1), reclassify(e.getCreator(),f1));
			addEvent(ne,new label tr(Ls,f1),Ld);
		}catch (NullPointerException impossible) {}
		return ne;
	}

	//this could be implimented by assigning the event to a more restricted event, without the use of transition.
	//But in this case you need to know the more restrictive type and include the correct where-restriction.
	//This case does not work if the same transition may create different automata when applied to different values. 
	//applied only to events created and owned by just this user!
	public Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} hideSlot{rif[q0*:{_}];rifi[q1*:{}]}
	(Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({Ls},f1)} pe)
	where tr(tr(Ls,f1),f9)<={rif[q0*:{_}];rifi[q1*:{}]}, tr(tr(Ls,f1),f2)<=Ls, tr(Ls,f2)<=Ls, Ls<=Ld
	{
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f3);
		Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} ne = null;
		try{
			Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}] e2 = reclassify(pe,f9);
			el.remove(reclassify(e2.getNode(),f9));
			Event[{tr({Ls},f1)},Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} e = reclassify(pe,f2);
			if (e==null) throw new Error("Null event");
			Date[{tr({Ls},f1)}]{Ls} d= reclassify(e.getDate(),f2);
			if (d==null) throw new Error("Null date");
			Date[Ls]{Ls} date = 
				new Date[Ls](reclassify(d.getDay(),f2),reclassify(d.getMonth(),f2), reclassify(d.getYear(),f2));
			TimeOfDay[{tr({Ls},f1)}]{Ls} t = reclassify(e.getTime(),f2);
			if (t==null) throw new Error("Null time");
			TimeOfDay[Ls]{Ls} time = 
				new TimeOfDay[Ls](reclassify(t.getHour(),f2),reclassify(t.getMinute(),f2));
			ne = new Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}](
				date, time, 
				reclassify(e.getDuration(),f2), 
				e.getDescription(), 
				e.getCreatorCal(),e.getCreator());
			addEvent(ne, Ls, Ld);
		}catch (NullPointerException impossible) {}
		return ne;
	}

	public String{rif[q0*:{_}];rifi[q1*:{}]} takePubView {rif[q0*:{_}];rifi[q1*:{}]} () {
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f3);
		String{rif[q0*:{_}];rifi[q1*:{}]} output=null;
		int size;
		int i;
		try{
		size=el.getSize();
		Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = el.getHead();
		for (i=0;i<size;i++) {
			try{
				final Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} nd = n;
				if (nd.La <= new label tr(Ls, f1)){
					if (new label tr(nd.La,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]} && 
						new label tr(nd.Lb,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]} &&
						new label tr(nd.La,f6) <= new label {rif[q0*:{_}];rifi[q1*:{}]}){
						Object{rif[q0*:{_}];rifi[q1*:{}]} e = reclassify(nd.getData(),f9);
						Event[nd.La,nd.Lb,{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} de = (Event[nd.La,nd.Lb,{rif[q0*:{_}];rifi[q1*:{}]}]) e;
						if (output==null) output = de.toStringf6()+ "\n";
						else output = output + de.toStringf6() + "\n";
					}
				}
				n=n.getNext();

			}catch (ClassCastException impossible) { throw new Error("ClassCastException at takePubView!"); }
		}
		}catch (NullPointerException impossible) {}
		return output;
	}

	public boolean{Ls;*ls} rejectOnConflict {rif[q0*:{_}];rifi[q1*:{}]} 
	(Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} ereq, label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
	{
		boolean{Ls;*ls} result=false;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{O},q1:{_},f3:q0->q1];rifi[q1*:{}]} el2 = this.eventList;
		rifList[{rif[q0*:{_}];rifi[q1*:{}]}] el = reclassify(el2,f3);
		int size;
		int i;
		int{Ls;*ls} eStart;
		int{Ls;*ls} eFinish;
		try{
		if (ereq==null) throw new Error("Null ereq");
		Date[ls]{*ls} ereqDt = ereq.getDate();
		TimeOfDay[ls]{*ls} ereqT = ereq.getTime();
		int{*ls} reqStart = ereqT.getHour()*60+ereqT.getMinute();
		int{*ls} reqFinish = reqStart+ ereq.getDuration();
		if (el==null) throw new Error("Null el");
		size=el.getSize();
		Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = el.getHead();
		for (i=0;i<size;i++) {
			try{
				final Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} nd = n;
				if (nd.La <= Ls && Ls <= nd.La){
					Object{Ls} ue = nd.getData();
					Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]{Ls} e = (Event[Ls,Ld,{rif[q0*:{_}];rifi[q1*:{}]}]) ue;
					if (e==null) throw new Error("Null e");
					TimeOfDay[Ls]{Ls} eT = e.getTime();
					Date[Ls]{Ls} eDt = e.getDate();
					if (eT==null) throw new Error("Null eT");			
					eStart = eT.getHour()*60+eT.getMinute();
					eFinish = eStart+ e.getDuration();
					if (eDt==null || ereqDt==null) throw new Error("Null eDt or ereqDt");
					if (e.getAutoReject() && eDt.getYear()==ereqDt.getYear() && 
						eDt.getMonth()==ereqDt.getMonth() &&
						eDt.getDay()==ereqDt.getDay() && 
						(eStart<=reqStart && reqStart<=eFinish ||
						 reqStart<=eStart && eStart<=reqFinish)){
						result=true;
					}
				}
				n=n.getNext();

			}catch (ClassCastException impossible) { throw new Error("ClassCastException at rejectOnConflict!"); }
		}
		}catch (NullPointerException impossible) {}
		return result;
	}
	

}


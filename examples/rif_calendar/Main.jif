/*To compile: ~/Desktop/jif/bin/jifc -simpleoutput -classpath ~/Desktop/jif/tests *.jif */
/*To run: ~/Desktop/jif/bin/jif -classpath ~/Desktop/jif/tests Main */

import java.io.PrintStream;
import jif.runtime.Runtime;

public class Main {

	final public static void main{rif[q0*:{_}];rifi[q1*:{}]}
                     (principal{rifi[q1*:{}]} p, String args[]) : {rifi[q1*:{}]}
		 throws (NullPointerException)
    {

		final label lbl = new label {rif[q1*:{p},q2:{_},f0:q1->q2];rifi[q1*:{p},q2:{},f4:q1->q2]};
        PrintStream[{rif[q1*:{_}];rifi[q1*:{}]}]{rif[q1*:{_}];rifi[q1*:{}]} out = null;
        PrintStream[{rif[q1*:{_}];rifi[q1*:{}]}]{rif[q1*:{p},q2:{_},f0:q1->q2];rifi[q1*:{p},q2:{},f4:q1->q2]} outinit = null;
        PrintStream[{rif[q1*:{_}];rifi[q1*:{}]}]{rif[q1*:{p},q2:{_},f0:q1->q2];rifi[q1*:{}]} out2 = null;
        Runtime[p,lbl]{rif[q1*:{p},q2:{_},f0:q1->q2];rifi[q1*:{p},q2:{},f4:q1->q2]} tryruntime;
        try {
            tryruntime = Runtime[p,lbl].getRuntime();
        }
        catch (SecurityException e) {
            throw new Error("channel is null 1 !");
        }

        try {
            outinit = tryruntime==null?null:tryruntime.stdout(new label {rif[q1*:{_}];rifi[q1*:{}]});
        }
        catch (SecurityException e) {
            throw new Error("channel is null 2 !");
        }
          
        out2 = reclassify(outinit,f4);

        out = reclassify(out2,f0);

		if (out == null) throw new NullPointerException("Null output");

		out.println("Welcome to rif-Calendar!");

		Server{rif[q0*:{_}];rifi[q1*:{}]} srv = new Server();

		//f9 is a transition used in list operations
		//transition f3 may or may not exist in lsA and lsB, depending on the choice of the corresponding user!
  		final label lsA = new label {rif[q1*:{Alice},q2:{_},q3:{_},f1:q1->q2,f2:q2->q1,f3:q1->q3,f9:q1->q3,f9:q2->q3,f6:q2->q3];
									rifi[q1*:{Alice},q2:{},q3:{Alice},q4:{},f7:q1->q2,f8:q2->q3,f9:q1->q4,f9:q2->q4,f6:q1->q4,f3:q1->q4]};
		final label ldA = new label {rif[q1*:{Alice},q2:{_},f9:q1->q2];
									rifi[q1*:{Alice},q2:{},q3:{Alice},q4:{},f7:q1->q2,f8:q2->q3,f9:q1->q4,f9:q2->q4]};
		final label ln = new label {rif[q0*:{_}];rifi[q1*:{}]};
		Calendar calA = srv.createCalendar(Alice,lsA,ldA);
		Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} calNodeA = new Node(calA, ln, lsA, ldA,Alice);


		final label lsB = new label {rif[q1*:{Bob},q2:{_},q3:{_},f1:q1->q2,f2:q2->q1, f9:q1->q3,f9:q2->q3,f6:q2->q3];
									rifi[q1*:{Bob},q2:{},q3:{Bob},q4:{},f7:q1->q2,f8:q2->q3,f9:q1->q4,f9:q2->q4,f6:q1->q4,f3:q1->q4]};
		final label ldB = new label {rif[q1*:{Bob},q2:{_},f9:q1->q2];
									rifi[q1*:{Bob},q2:{},q3:{Bob},q4:{},f7:q1->q2,f8:q2->q3,f9:q1->q4,f9:q2->q4]};
		Calendar calB = srv.createCalendar(Bob,lsB,ldB);
        Node[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} calNodeB = new Node(calB, ln, lsB, ldB,Bob);

		//These are labels for shared events (from Bob to Alice). They should not include an f3 transition.
		final label lsBA = new label {rif[q1*:{Alice,Bob},q2:{_},q3:{_},f1:q1->q2,f2:q2->q1,f3:q1->q3,f9:q1->q3,f9:q2->q3,f6:q2->q3];
						   rifi[q0*:{Bob},q1:{Bob},q2:{},q3:{Bob},q4:{},f7:q1->q2,f8:q2->q3,f9:q1->q4,f9:q2->q4,f6:q1->q4,f3:q1->q4,
							     		  q5:{Alice},q6:{},q7:{Alice},q8:{},f7:q5->q6,f8:q6->q7,f9:q5->q8,f9:q6->q8,f6:q5->q8,f3:q5->q8,
										  f4:q0->q1,f5:q0->q5,f9:q0->q4]};
		final label ldBA = new label {rif[q1*:{Alice,Bob},q2:{_},f9:q1->q2];
							rifi[q0*:{Bob},q1:{Bob},q2:{},q3:{Bob},q4:{},f7:q1->q2,f8:q2->q3,f9:q1->q4,f9:q2->q4,
							     		  q5:{Alice},q6:{},q7:{Alice},q8:{},f7:q5->q6,f8:q6->q7,f9:q5->q8,f9:q6->q8,
										  f4:q0->q1,f5:q0->q5,f9:q0->q4]};

		//Once an object is created, its label is created with it. So, object and label are unseparable.
		//If we want to change the label of the object, then we need to create a new copy and attach the desired label.

		Event[lsA,ldA,ln]{*lsA} eA = new Event[lsA,ldA,ln](new Date[lsA](23, 8, 2014), new TimeOfDay[lsA](10, 30), 30, "Meeting with Chris", calNodeA, calA, Alice);
		srv.addEvent(calA, eA, Alice, lsA, ldA);
		Event[{tr({*lsA},f1)},ldA,ln]{tr({*lsA},f1)} peA = srv.publicizeSlot(calA, eA, Alice, lsA, ldA);
		eA = new Event[lsA,ldA,ln](new Date[lsA](16, 9, 2014), new TimeOfDay[lsA](16, 15), 60, "Doctor appointment", calNodeA, calA, Alice);
		srv.addEvent(calA, eA, Alice, lsA, ldA);
		srv.publicizeSlot(calA, eA, Alice, lsA, ldA);
		eA = new Event[lsA,ldA,ln](new Date[lsA](5, 10, 2014), new TimeOfDay[lsA](9, 30), 15, "Meeting with Chris", calNodeA, calA, Alice);
		srv.addEvent(calA, eA, Alice, lsA, ldA);
		eA.setAutoReject(true);

		Event[lsB,ldB,ln]{*lsB} eB = new Event[lsB,ldB,ln](new Date[lsB](15, 10, 2014), new TimeOfDay[lsB](14, 30), 30, "Go to barbershop", calNodeB, calB, Bob);
		srv.addEvent(calB, eB, Bob, lsB,ldB);
		eB = new Event[lsB,ldB,ln](new Date[lsB](18, 10, 2014), new TimeOfDay[lsB](15, 45), 15, "Buy present for John", calNodeB, calB, Bob);
		srv.addEvent(calB, eB, Bob, lsB,ldB);

		out.println("Calendar of Alice");
		out.println(srv.printCalendar(calA, Alice, lsA, ldA));
		out.println("Calendar of Bob");
		out.println(srv.printCalendar(calB, Bob, lsB, ldB));

		out.println("Public view of Alice");
		out.println(srv.takePubView(calA, Alice, lsA, ldA));
		srv.hideSlot(calA, peA, Alice, lsA, ldA);
		out.println("Public view of Alice");
		out.println(srv.takePubView(calA, Alice, lsA, ldA));

		Event[lsBA,ldBA,ln]{*lsBA} eBs = new Event[lsBA,ldBA,ln](new Date[lsBA](10, 11, 2014), new TimeOfDay[lsBA](18, 10), 60, "Visit parents", calNodeB, calB, Bob);
	  	Event[lsA,ldA,ln]{*lsA} eAs = srv.requestSharedEvent(calB, calA, eBs, Bob, Alice, lsBA, ldBA, lsB, ldB, lsA, ldA, 19871);
		srv.acceptSharedEvent(calA, eAs, Alice, lsA, ldA);
		//else System.out.println("Automatic rejection: "+e.toString()+"\n");

		eBs = new Event[lsBA,ldBA,ln](new Date[lsBA](5, 10, 2014), new TimeOfDay[lsBA](9, 20), 20, "Visit aunts", calNodeB, calB, Bob);
		eAs = srv.requestSharedEvent(calB, calA, eBs, Bob, Alice, lsBA, ldBA, lsB, ldB, lsA, ldA, 19872);
		if (reclassify(eAs,f9) != null)
			srv.acceptSharedEvent(calA, eAs, Alice, lsA, ldA);
		else out.println("Automatic rejection: Visit aunts\n");

		eBs = new Event[lsBA,ldBA,ln](new Date[lsBA](20, 2, 2010), new TimeOfDay[lsBA](8, 15), 120, "Go for cinema", calNodeB, calB, Bob);
		eAs = srv.requestSharedEvent(calB, calA, eBs, Bob, Alice, lsBA, ldBA, lsB, ldB, lsA, ldA, 19873);
		srv.acceptSharedEvent(calA, eAs, Alice, lsA, ldA);
		//else System.out.println("Automatic rejection: "+e.toString()+"\n");

		eBs = new Event[lsBA,ldBA,ln](new Date[lsBA](30, 1, 2015), new TimeOfDay[lsBA](21, 30), 120, "Go to concert", calNodeB, calB, Bob);
		eAs = srv.requestSharedEvent(calB, calA, eBs, Bob, Alice, lsBA, ldBA, lsB, ldB, lsA, ldA, 19874);
		srv.acceptSharedEvent(calA, eAs, Alice, lsA, ldA);
		//else System.out.println("Automatic rejection: "+e.toString()+"\n");

		out.println("Calendar of Alice");
		out.println(srv.printCalendar(calA, Alice, lsA, ldA));
		out.println("Calendar of Bob");
		out.println(srv.printCalendar(calB, Bob, lsB, ldB));

		srv.cancelEvent(calA, 19871, Alice, lsA, ldA);     //both Alice and Bob should be able to cancel their shared events

		out.println("Calendar of Alice");
		out.println(srv.printCalendar(calA, Alice, lsA, ldA));
		out.println("Calendar of Bob");
		out.println(srv.printCalendar(calB, Bob, lsB, ldB));

	}

}


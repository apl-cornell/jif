/**
 * This method implements the server of the shared calendar.
 */

public class Server {

// List of calendars
private rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} calList;

public Server() {
    this.calList = new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
}

public Calendar[O,ls,ld]{rif[q0*:{_}];rifi[q1*:{}]} createCalendar
{rif[q0*:{_}];rifi[q1*:{}]}(principal{rif[q0*:{_}];rifi[q1*:{}]} O, label{rif[q0*:{_}];rifi[q1*:{}]} ls,
label{rif[q0*:{_}];rifi[q1*:{}]} ld){
    Calendar[O,ls,ld]{rif[q0*:{_}];rifi[q1*:{}]} cal = new Calendar[O, ls, ld]();
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} cl = this.calList;
    if (cl == null) return null;
    cl.add(cal, new label {rif[q0*:{_}];rifi[q1*:{}]}, ls, ld, O);
    return cal;
}

public void addEvent {rif[q0*:{_}];rifi[q1*:{}]}
(Calendar[O,ls,ld]{rif[q0*:{_}];rifi[q1*:{}]} cal, Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} e, 
principal{rif[q0*:{_}];rifi[q1*:{}]} O, label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld){
    if (cal != null) cal.addEvent(e,ls,ld);
}

//If shared event se, with labels ls1 and ld1, has confict with an event in calendar cal2,
//of principal o2 and with labels ls2 and ld2, and if labels ls1 and ls2 allow this conflict
//to be declassified, then return true, else return false.
public boolean{rif[q0*:{_}];rifi[q1*:{}]} checkConflict {rif[q0*:{_}];rifi[q1*:{}]}
(Calendar[o2,ls2,ld2]{rif[q0*:{_}];rifi[q1*:{}]} cal2, Event[ls1,ld1,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls1} se,
label{rif[q0*:{_}];rifi[q1*:{}]} ls1, label{rif[q0*:{_}];rifi[q1*:{}]} ld1, principal{rif[q0*:{_}];rifi[q1*:{}]} o2,
label{rif[q0*:{_}];rifi[q1*:{}]} ls2, label{rif[q0*:{_}];rifi[q1*:{}]} ld2) 
{
    boolean{rif[q0*:{_}];rifi[q1*:{}]} result=false;
    try{
    if (new label tr(ls1,f3) <= new label {rif[q0*:{_}];rifi[q1*:{}]} &&
        new label tr(ls2,f3) <= new label {rif[q0*:{_}];rifi[q1*:{}]}){
        if (reclassify(cal2.rejectOnConflict(se,ls1,ld1),f3)) result=true;
    }
    }catch (NullPointerException impossible) {}
    return result;
}

//o1 requests shared event se from o2
public Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} requestSharedEvent
{rif[q0*:{_}];rifi[q1*:{}]}(Calendar[o1,ls1,ld1]{rif[q0*:{_}];rifi[q1*:{}]} cal1, 
Calendar[o2,ls2,ld2]{rif[q0*:{_}];rifi[q1*:{}]} cal2, Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} se,
principal{rif[q0*:{_}];rifi[q1*:{}]} o1, principal{rif[q0*:{_}];rifi[q1*:{}]} o2,
label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld,
label{rif[q0*:{_}];rifi[q1*:{}]} ls1, label{rif[q0*:{_}];rifi[q1*:{}]} ld1,
label{rif[q0*:{_}];rifi[q1*:{}]} ls2, label{rif[q0*:{_}];rifi[q1*:{}]} ld2,
int{rif[q0*:{_}];rifi[q1*:{}]} bond) 
where tr(ls1,f9)<=ls2, tr(ld1,f9)<=ld2, tr(tr(ls1,f9),f9)<=tr(ls1,f9), tr(ls1,f9)<=ld2, 
tr(ls1,f9)<={rif[q0*:{_}];rifi[q1*:{}]}, tr(ls2,f9)<={rif[q0*:{_}];rifi[q1*:{}]}, 
tr(ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}, ls1<=ld1, ls<=ls1, ld<=ld1
{
    Event[ls1,ld1,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls1} e1 = null;
    Event[ls1,ld1,{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} de1 = null;
    Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} e2 = null;
    Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} de2 = null;

    try{
    // Create a copy of se for the calendar of o1, and tagg it with the proper label.
    // We declassify references through f9, because we do not mind about null-pointer
    // exceptions leaking information, and thus, the pc is not contaminated with the
    // label of the used reference. We do not declassify the actual data in se through f9!
    Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({*ls},f9)} e = reclassify(se,f9);
    Date[ls]{tr({*ls},f9)} d1= reclassify(e.getDate(),f9);
    Date[ls1]{*ls1} date1 = 
        new Date[ls1](d1.getDay(), d1.getMonth(), d1.getYear());
    TimeOfDay[ls]{tr({*ls},f9)} t1 = reclassify(e.getTime(),f9);
    TimeOfDay[ls1]{*ls1} time1 = 
        new TimeOfDay[ls1](t1.getHour(), t1.getMinute());
    e1 = new Event[ls1,ld1,{rif[q0*:{_}];rifi[q1*:{}]}](
        date1, time1, 
        e.getDuration(), 
        e.getDescription(),e.getCreatorCalNode(),
        e.getCreatorCal(),e.getCreator());

    // Check if e (i.e se) is automatically rejected.
    if (checkConflict(cal2,e,ls,ld,o2,ls2,ld2)) return null;

    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} sharedBetween1 = 
        new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} sharedBetween2 = 
        new rifList[{rif[q0*:{_}];rifi[q1*:{}]}]();
    sharedBetween1.add((Object)o1, new label {*ld1});  sharedBetween1.add((Object)o2, new label {*ld1});
    sharedBetween2.add((Object)o1, new label {*ld2});  sharedBetween2.add((Object)o2, new label {*ld2});
    // Declasify the reference of copy e1.
    de1 = reclassify(e1,f9);
    de1.setBond(bond);
    de1.setSharedBetween(sharedBetween1);
    // Put the copy of se for o1 in the list of events that wait to be accepted by a second user.
    cal1.addRequestEvent(de1);

    // Create a copy of se for the calendar of o2, and tagg it with the proper label.
    Date[ls]{tr({*ls},f9)} d2= reclassify(e.getDate(),f9);
    Date[ls]{*ls} date2 = 
        new Date[ls](d2.getDay(),d2.getMonth(), d2.getYear());
    TimeOfDay[ls]{tr({*ls},f9)} t2 = reclassify(e.getTime(),f9);
    TimeOfDay[ls]{*ls} time2 = 
        new TimeOfDay[ls](t2.getHour(),t2.getMinute());
    e2 = new Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}](
        date2, time2, 
        e.getDuration(), 
        e.getDescription(), e.getCreatorCalNode(),
        e.getCreatorCal(),e.getCreator());
    de2 = reclassify(e2,f9);
    de2.setBond(bond);
    de2.setSharedBetween(sharedBetween2);
    // Put the copy of se for o2 in the list of events that wait to be accepted by o2.
    cal2.addPendingEvent(de2,ls,ld);
    }catch (NullPointerException impossible) {}
    return de2;
}

//o2 accepts pending shared event e
public void acceptSharedEvent {rif[q0*:{_}];rifi[q1*:{}]}
(Calendar[o2,ls2,ld2]{rif[q0*:{_}];rifi[q1*:{}]} cal2, Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} e,
principal{rif[q0*:{_}];rifi[q1*:{}]} o2,label{rif[q0*:{_}];rifi[q1*:{}]} ls2, label{rif[q0*:{_}];rifi[q1*:{}]} ld2,
label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
where tr(ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}, ls<=ld, tr(ld,f7)<=tr(ld2,f7), tr(tr(ls2,f7),f9)<={rif[q0*:{_}];rifi[q1*:{}]}
{
    try{
    Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({*ls},f9)} se = reclassify(e,f9);
    Node[{rif[q0*:{_}];rifi[q1*:{}]}]{{rif[q0*:{_}];rifi[q1*:{}]}} n1 = reclassify(se.getCreatorCalNode(),f9);
    final label ls1 = n1.Lb;
    final label ld1 = n1.Lc;
    final principal{rif[q0*:{_}];rifi[q1*:{}]} o1 = reclassify(se.getCreator(),f9);
    try{
    // Find calendar cal1 of the user that created this shared event se.
    Calendar[o1,ls1,ld1] cal1 = (Calendar[o1,ls1,ld1]) reclassify(se.getCreatorCal(),f9);
    // Accept se.
    cal2.acceptPendingEvent(e,ls,ld);
    int{rif[q0*:{_}];rifi[q1*:{}]} bond= reclassify(se.getBond(),f9);
    // Find the corresponing event e1 of se in cal1.
    Event[ls1,ld1,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls1} e1 = cal1.findRequestedEvent(bond);
    // e1 moved to accepted events.
    if (cal1 != null && new label tr(ls1,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]}) cal1.requestedEventAccepted(e1);
    }catch (ClassCastException impossible) { }
    }catch (NullPointerException impossible) {}
}


// User o cancels a shared event with reference number bond1. 
public void cancelEvent {rif[q0*:{_}];rifi[q1*:{}]}
(Calendar[o,ls,ld]{rif[q0*:{_}];rifi[q1*:{}]} cal, int {rif[q0*:{_}];rifi[q1*:{}]} bond1,
principal{rif[q0*:{_}];rifi[q1*:{}]} o,label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
where tr(tr(ls,f7),f9)<={rif[q0*:{_}];rifi[q1*:{}]}, tr(ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]},
tr(tr(ld,f7),f9)<={rif[q0*:{_}];rifi[q1*:{}]}
{
    try{
    // Find the shared event e with reference numbr bond1 in o's calendar.
    Event[{tr({*ls},f7)},{tr({*ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({*ls},f7)} e = cal.findAcceptedEvent(bond1);
    Event[{tr({*ls},f7)},{tr({*ld},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} se = reclassify(e,f9);
    int{rif[q0*:{_}];rifi[q1*:{}]} bond= reclassify(se.getBond(),f9);
    // Cancel e in o's calendar. Variable l contains the users that share e (sharedBetween).
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{tr({*ld},f7)} l = cal.cancelEvent(e);

    // For each user s in sharedBetween list l, and for each calendar cal2 in the list of calendars,
    // if the owner of cal2 is s, find the corresponding event (e2) of e in cal2 and cancel it.
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} dl = reclassify(l,f9);
    rifList[{rif[q0*:{_}];rifi[q1*:{}]}]{rif[q0*:{_}];rifi[q1*:{}]} cl = this.calList;
    int{rif[q0*:{_}];rifi[q1*:{}]} size=cl.getSize();
    int{rif[q0*:{_}];rifi[q1*:{}]} i;
    int li;
    int lsize= dl.getSize();
    Node[{rif[q0*:{_}];rifi[q1*:{}]}] ln = dl.getHead();
    for (li=0;li<lsize;li++) {	
    final Node[{rif[q0*:{_}];rifi[q1*:{}]}] lnd = ln;			
    if (lnd!= null && new label tr(lnd.La,f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]}){
    try{
    jif.lang.Principal{rif[q0*:{_}];rifi[q1*:{}]} s= (jif.lang.Principal) reclassify(lnd.getData(),f9);
    if (s != null && !s.equals(o)){
        Node[{rif[q0*:{_}];rifi[q1*:{}]}] n = cl.getHead();
        for (i=0;i<size;i++) {						
            final Node[{rif[q0*:{_}];rifi[q1*:{}]}] nd = n;
            if (nd != null && nd.La <= new label {rif[q0*:{_}];rifi[q1*:{}]}){
                try{
                final label ls2 = nd.Lb;
                final label ld2 = nd.Lc;
                final jif.lang.Principal o2 = nd.O;
                Calendar[o2,ls2,ld2]{rif[q0*:{_}];rifi[q1*:{}]} cal2= (Calendar[o2,ls2,ld2]) nd.getData();
                if(cal2!=null){
                    if (o2 != null && o2.equals(s) && new label tr(tr(ls2,f7),f9) <= new label {rif[q0*:{_}];rifi[q1*:{}]}){
                        Event[{tr({*ls2},f7)},{tr({*ld2},f7)},{rif[q0*:{_}];rifi[q1*:{}]}]{tr({*ls2},f7)} e2 
                            = cal2.findAcceptedEvent(bond);
                        cal2.cancelEvent(e2);
                    }
                }
                }catch (ClassCastException e1) { throw new Error("ClassCastException 1!"); }
            } 
            n=n.getNext();						
        } 
    }
    }catch (ClassCastException e2) {throw new Error("ClassCastException 2!"); }
    }
    ln=ln.getNext();			
    }
    }catch (NullPointerException e3) {throw new Error("NullPointerException 3!");}
}

public String{rif[q0*:{_}];rifi[q1*:{}]} printCalendar{rif[q0*:{_}];rifi[q1*:{}]}
(Calendar[o,ls,ld]{rif[q0*:{_}];rifi[q1*:{}]} cal, principal{rif[q0*:{_}];rifi[q1*:{}]} o,
label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
{
    return cal!=null?cal.toString():null;
}


// Publicize the slot of event e.
public Event[{tr({*ls},f1)},ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({*ls},f1)} publicizeSlot {rif[q0*:{_}];rifi[q1*:{}]}
(Calendar[o,ls,ld]{rif[q0*:{_}];rifi[q1*:{}]} cal, Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} e,
principal{rif[q0*:{_}];rifi[q1*:{}]} o, label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
where tr(ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}
{
    if (cal != null) return cal.publicizeSlot(e);
    else return null;
}

// Hide the slot of event e.
public Event[ls,ld,{rif[q0*:{_}];rifi[q1*:{}]}]{*ls} hideSlot{rif[q0*:{_}];rifi[q1*:{}]}
(Calendar[o,ls,ld]{rif[q0*:{_}];rifi[q1*:{}]} cal, Event[{tr({*ls},f1)},ld,{rif[q0*:{_}];rifi[q1*:{}]}]{tr({*ls},f1)} e,
principal{rif[q0*:{_}];rifi[q1*:{}]} o, label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
where tr(tr(ls,f1),f9)<={rif[q0*:{_}];rifi[q1*:{}]}, tr(tr(ls,f1),f2)<=ls, tr(ls,f2)<=ls, ls<=ld
{
    if (cal != null) return cal.hideSlot(e);
    else return null;
}

// Print all the publicized slots (not descriptions) of events in cal.
public String{rif[q0*:{_}];rifi[q1*:{}]} takePubView {rif[q0*:{_}];rifi[q1*:{}]}
(Calendar[o,ls,ld]{rif[q0*:{_}];rifi[q1*:{}]} cal, principal{rif[q0*:{_}];rifi[q1*:{}]} o, 
label{rif[q0*:{_}];rifi[q1*:{}]} ls, label{rif[q0*:{_}];rifi[q1*:{}]} ld)
{
    return cal!=null?cal.takePubView():null;
}

}


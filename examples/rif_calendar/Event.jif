public class Event[label Ls, label Ld, label Ln] {

	private Slot[Ls]{Ls} slot;
	private String{Ld} description;
	private Object{Ln} creatorCal;
	private principal{Ln} creator;
	private boolean{Ls} autoRejectOnConflict;
	private rifList[Ln]{Ld} sharedBetween; //the label of this may need to change due to the cancel operator
	private boolean{Ls} pubSlot;
	private final label{this} ls = Ls; //Ld may not be the same for all events, but Ls and Ld have the same integ
	private Node[Ln]{Ls} node;
	private int{Ls} bond=0;

	public Event(Date[Ls]{Ls} date, TimeOfDay[Ls]{Ls} time, int{Ls} duration, String{Ld} description, 
			Object{Ln} creatorCal, principal{Ln} creator) {
		this.slot = new Slot[Ls](date,time,duration);
		this.description = description;
		this.creatorCal = creatorCal;
		this.creator=creator;
		this.autoRejectOnConflict=false;
		this.sharedBetween=null;
		this.pubSlot=false;
		this.node = null;
	}

	public int{Ls} getBond() {
		return this.bond;
	}

	public void setBond{Ls}(int{Ls} b) {
		this.bond=b;
	}

	public Date[Ls]{Ls} getDate() {
		Slot[Ls]{Ls} s = this.slot;
		if (s != null) return s.getDate();
		else return null;
	}

	public void setDate{Ls}(Date[Ls]{Ls} date) {
		Slot[Ls]{Ls}  s = this.slot;
		if (s != null) s.setDate(date);
	}

	public TimeOfDay[Ls]{Ls} getTime() {
		Slot s = this.slot;
		if (s != null) return s.getTime();
		else return null;
	}

	public void setTime{Ls}(TimeOfDay[Ls]{Ls} time) {
		Slot[Ls]{Ls} s = this.slot;
		if (s != null) s.setTime(time);
	}

	public int{Ls} getDuration() {
		Slot[Ls]{Ls} s = this.slot;
		if (s != null) return s.getDuration();
		else return 0;
	}

	public void setDuration{Ls}(int{Ls} duration) {
		Slot[Ls]{Ls} s = this.slot;
		if (s != null) s.setDuration(duration);
	}

	public String{Ld} getDescription() {
		return description;
	}

	public void setDescription{Ld}(String{Ld} description) {
		this.description = description;
	}

	public principal{Ln} getCreator() {
		return creator;
	}

	public Object{Ln} getCreatorCal() {
		return creatorCal;
	}

	public void setAutoReject{Ls}(boolean{Ls} b){
		this.autoRejectOnConflict=b;
	}

	public boolean{Ls} getAutoReject(){
		return this.autoRejectOnConflict;
	}

	public rifList[Ln]{Ld} getSharedBetween() {
		return sharedBetween;
	}

	public void setSharedBetween{Ld}(rifList[Ln]{Ld} sharedBetween) {
		this.sharedBetween = sharedBetween;
	}

	public void setPubSlot{Ls}(boolean{Ls} b){
		this.pubSlot=b;
	}

	public boolean{Ls} getPubSlot(){
		return this.pubSlot;
	}

	public void setNode{Ls}(Node[Ln]{Ls} n) {
		this.node=n;
	}

	public Node[Ln]{Ls} getNode(){
		return this.node;
	}

	public String{rif[q0*:{_}];rifi[q1*:{}]} toString{rif[q0*:{_}];rifi[q1*:{}]}() 
	where tr(Ls,f9)<={rif[q0*:{_}];rifi[q1*:{}]}, tr(Ld,f9)<={rif[q0*:{_}];rifi[q1*:{}]}, tr(Ln,f9)<={rif[q0*:{_}];rifi[q1*:{}]}
	{
		String output;
		Slot{rif[q0*:{_}];rifi[q1*:{}]} s = reclassify(this.slot,f9);
		if (s==null) return null;
		Date{rif[q0*:{_}];rifi[q1*:{}]} dt = reclassify(s.getDate(),f9);
		TimeOfDay{rif[q0*:{_}];rifi[q1*:{}]} t = reclassify(s.getTime(),f9);
		if (dt ==null || t==null) return null;
		output = "Event [date=" + dt.toString() + ", time=" + t.toString() + ", duration="
				+ s.getDuration() + "mins, description=" + description + ", creator="
				+ PrincipalUtil.toString(creator) + "]";
		return reclassify(output,f9);
	}

}


/**
 * The class rifList is used to create lists of objects tagged with different labels.
 * Each node of a rifList contains a field for the object and a field for the (dynamic) label that tags this object.
 * For this implementation, a node may also contain fields for additional dynamic labels and principals.
 * These additional fields are used to instantiate parameters of the corresponding object. 
 */


public class rifList[label L] {

	private Node[L]{L} head;
	private Node[L]{L} last;
	private int{L} size;

	public rifList() {
		this.head = null;
		this.last = this.head;
		this.size = 0;
	}

	public Node[L]{L} add{L}(Object{*La} data, label{L} La)
		where L<=La
	{
		Node n = new Node[L](data,La);
		Node lst = this.last;
		if (lst == null){
			this.head = n;
			this.last = n;
			this.size++;
			return n;
		}
		lst.setNext(n);
		this.last=n;
		this.size++;
		return n;
	}

	public Node[L]{L} add{L}(Object{*La} data, label{L} La, label{L} Lb)
		where L<=La
	{
		Node n = new Node[L](data,La,Lb);
		Node lst = this.last;
		if (lst == null){
			this.head = n;
			this.last = n;
			this.size++;
			return n;
		}
		lst.setNext(n);
		this.last=n;
		this.size++;
		return n;
	}

  public Node[L]{L} add{L}(Object{*La} data, label{L} La, label{L} Lb, label{L} Lc, jif.lang.Principal{L} o)
		where L<=La
	{
		Node n = new Node[L](data,La,Lb,Lc,o);
		Node lst = this.last;
		if (lst == null){
			this.head = n;
			this.last = n;
			this.size++;
			return n;
		}
		lst.setNext(n);
		this.last=n;
		this.size++;
		return n;
	}

	public void remove{L}(Node[L]{L} nr){
		Node n = this.head;
		if (n == null) return;
		if (this.size == 1 && n==nr){
			this.head=null;
			this.last = this.head;
			this.size--;
			return;
		}
		if (n==nr){
			this.head = n.getNext();
			n.setNext(null);
			this.size--;
			return;
		}
		int i=0;
		Node nb = n;
		n = n.getNext();
		while (i<this.size){
			if (n == null) return;
			if (n==nr){
				if (n == this.last){
					this.last = nb;
				}
				nb.setNext(n.getNext());
				n.setNext(null);
				this.size--;
				return;
			}
			nb = n;
			n=n.getNext();
			i++;
		}
	}

	public int{L} getSize(){
		return this.size;
	}

	public Node[L]{L} getHead(){
		return this.head;
	}

}

import jif.util.*;


/**
 * This class represents a player in the BattleShip game.
 *
 * A player has a secret Board that contains Ships. The player
 * initially places Ships on the Board before the game starts.  During
 * the game the Player must both generate queries to ask the opponent
 * (the method getNextQuery()) and also process queries from the
 * opponent (the method processQuery()). Processing the opponents
 * query requires declassifying some information about the board. 
 *
 * This class also keeps track of which queries the opponent has
 * asked, to ensure the opponent doesn't repeat a query.
 *
 * This class is parameterized by the prinicipal P: the
 * principal that this Player class represents. The secret board is
 * instantiated with the label parameter {P:}; i.e., the information is
 * owned by the principal P.
 */
class Player[principal P] authority (P) {
    /**
     * This Board represents P's board. Pieces will be placed on it
     * during initialization.
     */
    private final Board[{P:}]{this} board; 
    // It's fine to make the reference to the board public, as all the
    // information contained in the board is labeled {P:}

    /**
     * Record which queries the opponent has made, to stop them from
     * repeating queries.
     */
    private final List[{}]{} opponentQueries;

    public Player() {
	board = new Board[{P:}]();
	opponentQueries = new LinkedList[{}]();
    }

    /**
     * Initialize the board by placing ships to cover numCovered coords.
     */
    void init{P:}(int{} numCovered) {
	// Here what we would do in a full system is make a call to
	// some non-Jif function, through the runtime interface, to
	// get the position of the ships to place. That function would
	// either return something random, or would implement some
	// strategy. Here, we fake it with some fixed positions for
	// ships.
	final Ship[{P:}][] myCunningStrategy = {
	    new Ship[{P:}](new Coordinate[{P:}](1, 1), 1, true),
	    new Ship[{P:}](new Coordinate[{P:}](1, 3), 2, false),
	    new Ship[{P:}](new Coordinate[{P:}](2, 2), 3, true),
	    new Ship[{P:}](new Coordinate[{P:}](3, 4), 4, false),
	    new Ship[{P:}](new Coordinate[{P:}](5, 6), 5, true),
	    new Ship[{P:}](new Coordinate[{P:}](5, 7), 6, false), 
	};

	Board[{P:}] board = this.board;
	int i = 0;
        for (int count = numCovered; count > 0 && board != null; ) {
	    try {
		Ship[{P:}] newPiece = myCunningStrategy[i++];
		if (newPiece != null && newPiece.length > count) {
		    // this ship is too long!
		    newPiece = new Ship[{P:}](newPiece.pos, 
					      count, 
					      newPiece.isHorizontal);
		}
		board.addShip(newPiece);
		count -= (newPiece==null?0:newPiece.length);
	    }
	    catch (ArrayIndexOutOfBoundsException ignored) {}
	    catch (IllegalArgumentException ignored) { 
		// two ships overlapped. Just try adding the next ship
		// instead.
	    }
        }
    }
    
    /**
     * Ask the next query to ask the opposing player.
     */
    public Coordinate[{}] getNextQuery{P:}() where authority(P) {
	// Here what we would do in a full system is make a call to
	// some non-Jif function, through the runtime interface, to
	// get the next coordinate to ask our opponent. We fake it
	// here by asking queries in a fixed order.

	Coordinate[{P:}] c = this.nextQuery;
	if (c == null) {
	    c = new Coordinate[{P:}](0,0);
	}

	// update nextQuery.
	try {
	    boolean direction = ((c.x + c.y)%2 == 0);
	    int newX = c.x + (direction?1:-1);
	    int newY = c.y + (direction?-1:1);
	    if (newX < 0) newX = 0;
	    if (newY < 0) newY = 0;
	    this.nextQuery = new Coordinate[{P:}](newX, newY);
	}
	catch (ArithmeticException ignored) {}

	// we now have our secret query c, which needs to be declassified.
	Coordinate[{}] d = new Coordinate[{}](declassify(c.x, {}),
					      declassify(c.y, {}));

	return d;
    }
    private Coordinate[{P:}]{P:} nextQuery = null;
    
    /**
     * Process the query of the opponent. Note that the method requires authority
     * to declassify the result of processing the query.
     *
     * @throws IllegalArgumentException if the opponent has asked the query already
     */
    public boolean{query} processQuery{}(Coordinate[{}]{} query) 
         throws (IllegalArgumentException{query}) 
         where authority (P) {

	Board[{P:}] brd = this.board; 
	List[{}] oppQueries = this.opponentQueries;
	if (brd == null || oppQueries == null || query == null) {
	    return false;
	}
	
	// test if the opponent asked this query already, and if not,
	// add it to our list of queries.
	if (oppQueries.contains(query)) {
	    throw new IllegalArgumentException("Opponent already asked the query " + query.toString());
	}
	try {
	    oppQueries.add(query);
	}
	catch (ClassCastException impossible) { }

	// put the query into the secret form. It would be nice to
	// have the parameter for Board covariant, but that would lead
	// to difficulties with the Board class, which requires an
	// invariant parameter.
	Coordinate[{P:}] q = new Coordinate[{P:}](query.x, query.y);

	// find the result.
	boolean result = brd.testPosition(q);
	
	// declassify the result
	return declassify(result, {query});
    }
}

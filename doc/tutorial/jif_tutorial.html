<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
	dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css">
<title>Jif Tutorial</title>
<script src="colorize.js" type="text/javascript"></script>
</head>

<body class="notes">

<h2>Jif: Adding Information Flow to Java</h2>

<a name="toc" id="toc"></a>
<!-- TOC START - ->
<h3>Table of Contents</h3>
<table width="100%">
	<tr>
		<td align="left">
		<div>
		<ul>
			<li><a href="#introduction" class="toc">1. Introduction</a></li>
			<li><a href="#download_and_install" class="toc">2. Download
			and Install</a></li>
			<li><a href="#quick_start">3. Quick Start</a>
			<ul>
				<li><a href="#writing_and_compiling_a_simple_swift_program">3.1
				Writing and compiling a simple Swift program</a></li>
				<li><a href="#testing_the_compiled_swift_program">3.2
				Testing the compiled Swift program</a></li>
				<li><a href="#deploying_the_swift_program">3.3 Deploying
				the Swift program</a>
			</ul>
			</li>
			<li><a href="#how_hello_works">4. How Hello.jif works</a>
			</li>
			<li><a href="#writing_a_bigger_swift_program">5. Writing a
			bigger Swift program</a></li>
			<li><a href="#authentication_and_authorization">6.
			Authentication and Authorization in Web Applications</a></li>
			<li><a href="api.html">7. Swift Runtime Library API</a></li>
			<li><a href="webilui.html">8. Swift UI Library API</a></li>			
		</ul>
		</div>
		</td>
		<td align="right"><img src="swift.jpg" /></td>
</table>
<!- - TOC END -->

<h3><a name="introduction" id="introduction">Introduction</a></h3>

<p>Jif is a security-typed programming language that extends Java with support for information flow control and access control, enforced at both compile time and run time.  The use of security types makes it easy to avoid many types of security bugs.  It also adds a whole new set of constraints to programs, which makes writing valid programs that much more difficult.</p>

<p> This tutorial provides an overview of the major features of Jif, and then walks through the implementation of a small example, demonstrating common pitfalls and solutions.</p>

<h3><a name="syntax_policies_labels" id="syntax_policies_labels">Syntax, Policies, Labels</a></h3>
<h4><a name="hello_world" id="hello_world">Hello World</a></h4>

<pre>
import java.io.PrintStream;
import jif.runtime.Runtime;

public class Hello
{
    public Hello() {}
    public static void main{}(principal{} pp, String[]{} args)
        throws (SecurityException)
    {
        Runtime[pp] runtime = Runtime[pp].getRuntime();
        try {
            PrintStream[{pp-&gt;}] out = runtime.out();
            out.println("Hello, world!");
        }
        catch (NullPointerException ignored) { }
    }
}
</pre>

<p>As this example shows, the syntax is mostly familiar if you know Java.  The major difference is in the addition of class label parameters and label values: the values contained in square brackets and curly braces.  Both of these will be described in detail, but a brief summary is given here.</p>

<p>Briefly, a class label parameter is provided after a class name in square brackets.  It's used much like Java generics, except with information flow information rather than class information.  For example, the Runtime class needs to know what user "owns" it; this is passed in as a parameter (pp, in this case).</p>

<p>A label is a descriptor of the security level of an object: who is allowed to read it, and who might have influenced it.  Every object has an associated label, and methods have several.  Not all of them are explicit, though: Jif has some inference capabilities, so it will do its best to find a suitable label for an object if none is given.</p>

<p> Note also the use of -&gt;; this is an ASCII-fied right arrow.  The unicode &rarr; is the preferred notation, but requires a unicode-aware editor.</p>

<h4><a name="principals" id="principals">Principals</h4>

<p>A principal represents some entity.  This may be a user in a multiuser system, or the client or server for a web application.  Security policies are given in terms of these principals.</p>

<p>A principal can delegate its authority to another principal.  This is a construct in Jif: the expression p actsfor q returns whether or not p acts for q.  This means that p is allowed to do anything q could; q trusts p to not abuse its power.  For example, in a web application, the user must trust the server, so it is reasonable to say that the server actsfor the client.</p>

<p>We can also construct principals from others: suppose Alice and Bob want to have indepedent authority, but want to allow a third principal to act for either of them.  The disjunctive principal "Alice, Bob" is exactly this: it actsfor both Alice and Bob.  Symmetrically, they can make a conjuctive principal "Alice & Bob" for which they can both act.</p>

<p>Finally, there is a top principal * or ⊤ which actsfor all principals, and a bottom principal _ or ⊥ for which all principals can act (thus, the principals form a lattice ordered by actsfor).</p>

<h4><a name="simple_user_defined_principals" id="simple_user_defined_principals">Simple User-defined Principals</a></h4>

<p>How do we make principals?  Jif provides a mechanism for the programmer to define arbitrary principals as special classes.</p>

<pre>
public class Alice extends ExternalPrincipal {
   public Alice() {
      super("Alice");
   }

   private static Alice{*&lt;-*} P;
   public static Principal getInstance{*&lt;-*}() {
      if (P == null) {
         P = new Alice();
      }
      return P;
   }
}
</pre>

<p>Any class to be used as a principal must implement the Principal interface.  ExternalPrincipal is one such implementation that provides useful defaults for testing; Abstractprincipal is a bit more general.</p>

<p>These will be described in more detail later; the key point is that principals are real objects that can be passed around like any other, as well as being used in policies.<p>

<h4><a name="policies" id="policies">Confidentiality Policies</a></h4>

<p> Security in Jif is determined by a <i>policy</i>.  A policy has an owner, and describes how secure the owner thinks the data is.  There are two types of policies: confidentiality and integrity.  As the names suggest, confidentiality determines who the owner thinks is allowed to see the data, and integrity determines who might have influenced it: a sort of "taint" tracker.</p>

<p> A confidentiality policy, written <code>o</code>&rarr;<code>r</code> or <code>o->r</code>, means that the user <code>o</code> (the owner) permits <code>r</code> to read the data.  Of course, <code>o</code> also allows itself to read it.  Further, any user that acts for <code>o</code> or <code>r</code> can read it, since these users are trusted by either <code>o</code> or <code>r</code>.  This policy also says that no other principals can read it; if another principal tries to read the data, this is a security violation.</p>

<p> A confidentiality policy owned by <code>o</code> also affects any principals <code>p</code> where <code>o actsfor p</code>.  Intuitively, if <code>o actsfor p</code>, then <code>p</code> trusts <code>o</code>.  So if <code>o</code> owns some confidentiality policy, <code>p</code> will also respect it.

<p> These policies can be combined much like principals: the disjunction of two policies, <code>o->r join o->s</code> (or <code>o</code>&rarr;<code>r</code> &#x2294; <code>o</code>&rarr;<code>s</code>) allows both r and s to read.  This can be abbreviated as <code>o->r,s</code>.  Likewise, the conjunction <code>o->r meet o->s</code> (or <code>o</code>&rarr;<code>r</code> &#x2293; <code>o</code>&rarr;<code>s</code>) allows a principal to read the data only if both policies allow it.  (This is more useful when <code>r</code> and <code>s</code> are more complicated expressions.)</p>

<p> We can define an ordering on confidentiality policies according to how many principals are allowed to read the data.  Specifically, two policies have c &#x2291; d if all principals agree that c allows more readers than d; that is, c is less confidential.  For example, c &#x2291; c &#x2293; d, since c &#x2293; d enforces d as well as c, so is more restrictive, while c &#x2294; d &#x2291; c, since c &#x2294; d allows readers from d as well as those from d.</p>

<p>Note that we also have top and bottom confidentiality policies: *->* (or simply *->) is the top policy; since * actsfor all principals, this policy says that all principals believe that only * can read the data; any more restrictive policy would require some principals to think that nobody can read the data, which is not allowed for obvious reasons.</p>

<p>Similarly, _->_ (or the empty policy) is the bottom policy, since it states only that bottom allows anyone to read, and all other principals implicitly have no restriction.</p>

<h4><a name="policies" id="policies">Integrity Policies</a></h4>

<p>Integrity policies, written <code>o<-w</code> (or <code>o</code> &larr; <code>w</code>) determine who may have influenced data.  Like confidentiality policies, o is the owner, and it implicitly believes that it may have influenced the data.  However, it is the dual to confidentiality, so many of the other properties are inverted.  Note also the tense: the policy describes not who is allowed to write, but who may have written in the past.

<p>As with confidentiality, a principal believes an integrity policy owned by a principal that acts for it, and if a principal may have affected data, then any principal which acts for it may have.</p>

<p> As the dual to confidentiality, disjunction is written <code>c meet d</code> (or <code>c</code> &#x2293; <code>d</code>, and weakens the restriction: a principal p may have affected the data if either c or d allowed it to.  Again, <code>o<-p meet o<-q</code> can be abbreviated to <code>o<-p, q</code>.  Not surprisingly, the conjunction is written <code>c join d</code>, and means that only principals allowed by both c and d may have affected the data.</p>

<p> The ordering on integrity policies is by how many principals may have influenced the data.  We say c &#x2291; d if all principals agree that c allows fewer writers.  This makes _->_ the top integrity policy, since it allows all writers, and *->* the bottom integrity policy, since it allows only * as a writer.</p>

<p>This ordering may seem backwards: higher integrity means that more principals may have affected data, the opposite of what one would expect high integrity to mean.  One way to make sense of it as a "restrictiveness" ordering: high integrity data may have been affected by any number of principals, so it should not be used in a system which needs to trust its data.  Likewise, low integrity data is highly trusted, so may be used pretty much anywhere; it is not very restricted in its use.</p>


<!--p>Confidentiality: a principal determines who is allowed to see data.  Join
means either can read it, meet means both must allow.  Also have an ordering:
c &lt; d if c allows more readers: it is less restrictive.</p>

<p>Integrity: a principal tracks who might have influenced data.  Dual of
confidentiality: Join means both think it influenced, meet means either.
Ordering is reversed: c &lt; d if c allows fewer influences; but still less
restrictive.</p

<p>Self is always implicit.</p>

<p>Principals also trust principals who act for them; e.g., T -&gt; T; top acts for
any principal, so all believe any wrote to it.</p> -->

<h4><a name="labels" id="labels">Labels</a></h4>

<p> Most of the time, we want both confidentiality and integrity policies, so these are combined into labels.  Labels are written inside curly braces, with the confidentiality and integrity parts separated by semicolons: {Alice&rarr;Bob; Alice&larr;}.  This semicolon notation can be extended to multiple confidentiality and integrity polices, effectively taking the join of all of them: {Alice->Bob; Bob->Alice; Alice&lt;-; Bob}.</p>

<p> As you might expect by now, labels also have an ordering.  Their ordering is pointwise: l &#x2291; l' when it is true of both the confidentiality and integrity parts of the labels.  Taking this as a lattice, meet and join are also pointwise.  (Note that this means that meet is conjunction on confidentiality and disjunction on integrity, and join is dually disjunction on confidentiality and conjunction on integrity.)</p>

<p> This ordering is extensively used in checking Jif programs; for example, a value put into a variable must have a label less than or equal to that of the variable.  This matches up well with the notion of the order as "restrictedness": a restricted value can't go into an unrestricted variable.

<p>Considering this example with each policy separately may clarify their orderings.  Confidentiality prevents leaking information by putting confidential information in a less confidential variable.  Integrity prevents a value that has been "tainted" by many writers being put into a variable with fewer writers.</p>

<p>As an example of confidentiality, consider the following snippet:</p>

<pre>
int{Alice->} alice_secret = 0;
int{Bob->} bob_secret = 1;
int{Alice->Bob; Bob->Alice} shared = 2;

alice_secret = shared;     // good
alice_secret = bob_secret; // bad
shared = alice_secret;     // bad
</pre>

<p> In this example, Alice and Bob each have a secret, and they have a shared value that both can read.  Alice can set her secret to the shared value, since the secret has higher confidentiality.  But her secret and Bob's secret do not have comparable labels, so cannot be directly transferred.  Likewise, the shared value has lower confidentiality than her secret, so her secret cannot be moved into it.  (Intuitively, this would reveal Alice's secret to Bob, breaking her privacy.)</p>

<p> What if Alice wants to reveal her secret?  That requires an explicit declassify expression, discussed below</p>

<p>Note that labels for variables are written immediately after the type.  They can often be omitted, as Jif has a label-inference system which can often determine valid labels.  However, it is often useful to make them explicit for debugging or demonstration purposes.</p>

<p> Now an example for integrity:</p>

<pre>
int{Alice&lt;-} internal;
int{Alice&lt;-_} external;

external = internal; // good
internal = external; // bad
</pre>

<p> Here, Alice has an internal value which only she can modify, as well as an internal value which she allows any principal acting for bottom (which is all of them) to modify.  In the first case, Alice is putting her trusted information into an untrusted destination, which is fine.  But in the second case puts external, which contains data potentially tainted by others, into internal, which is trusted to only have been modified by Alice herself.</p>

<p> To put external into internal (perhaps after checking that it is valid, or came from a trusted source), it must be endorsed, as discussed below.</p>

<p> Labels may also contain variables, e.g. <code>{x}</code>.  This simply refers to the label on the variable x.

<p> Note that labels, like principals, are really Java objects that can be passed around.  However, writing {lb} (where lb is a label variable) would mean the label of the variable lb.  To get the value stored in the label, the <code>*</code> operator is used: {*lb}.</p>

<!--p>Label: combination of confidentiality, integrity.  Ordered by both.  What
actually shows up in Jif programs.</p>

<p>Syntax: written in {}, semicolon separates parts, "magic join/semicolon", </p-->

<!--p>Examples:</p>
<ul>
<li>{Alice-&gt;; _&lt;-_ }: Alice believes that only she can read it, anybody may
                     have influenced it

<li>{Alice-&gt;; Alice&lt;-}: Alice thinks it's private; only she can read or has
                       written to it.

<li>{Alice-&gt;Bob; Bob-&gt;Alice}: Alice and Bob have a shared secret.  Default
   integrity of _&lt;-_.

<li>Definition of Alice, P is Alice{*&lt;-*}; default confidentiality of _-&gt;_;
   essentially unrestricted, useful for testing since anyone can use it.

<li>{x} label of the variable x

<li>{this} label of the current object

<li>{this-&gt;} only allowed in a user-defined class (see below)
</ul-->

<h3><a name="section title?" id="section title?">Details of Labels</a></h3>

There are many subtleties of labels and their usage beyond simply assigning to variables.  This section will cover some of them.

<h4><a name="implicit_information_flow" id="implicit_information_flow">Implicit Information Flow</a></h4>

As discussed above, data cannot be put into a variable with a lower label.  But there may be other ways to leak information.  For example:

<pre>
public static void main{}(principal{} p, String[]{} args)
{
   boolean{p-&gt;} secret = true;
   boolean{p-&gt;_} pub;

   if(secret)
      pub = true;
   else
      pub = false;
}
</pre>

<p>This code clearly has the effect of assigning secret to pub.  But secret is readable only to p, while pub is visible to the entire world.  Fortunately, the Jif compiler knows that something is wrong here:</p>

<pre>
Test.jif:14: Label of right hand side not less restrictive than the label for
    local variable pub
        pub = true;
</pre>

<p>This error message is not particularly enlightening, though.  However, giving the <code>-explain</code> option to jifc gives much more information:</p>

<pre>
Test.jif:14: Unsatisfiable constraint:    
     rhs.nv &lt;= label of var pub    
        {p-&gt;; _&lt;-_; caller_pc} &lt;= {}    
        
     Label Descriptions    
     ------------------    
     - rhs.nv = label of successful evaluation of right hand of assignment    
     - rhs.nv = {p-&gt;; _&lt;-_; caller_pc}    
     - label of var pub = {}    
     - caller_pc = The pc at the call site of this method (bounded above by
    {})    
        
     More information is revealed by the successful evaluation of the right
    hand side of the assignment than is allowed to flow to the local variable
    pub.
         pub = true;
</pre>

<p> This is much more informative: the right hand side has a label {p-&gt;; _&lt;-_; caller_pc} which isn't less than the label of the variable pub, which Jif gives as {}.  What happend to {p-&gt;_}?  Remember that if a principal isn't listed in a confidentiality or integrity policy, it is assumed to allow any principal to read, and make no assumptions about who may have affected it.  So {p-&gt;_} says explicitly that p thinks any principal may have modified it, but has the same meaning as {}.</p>

<p> Similarly, the _&lt;-_ portion of rhs is just Jif printing out an explicit empty integrity policy, and can be ignored.</p>

<p> But where did the p-&gt; come from?  This is the pc-bound at that point.  Because of the conditional, if the line pub = true is run, we know something about secret.  So the value computed there is implicitly dependent on the value of secret, and since secret has the label {p-&gt}, this is joined into the label of the expression.  Thus, we can avoid leaking information by where we are in the program.</p>

<p>And what about the remaining part: caller_pc?  This will be revealed in the next section.</p>

<!--p>rhs.nv has {p-&gt;}; this is from the conditional.  Track security of "PC"; goes
through conditionals, and function calls: caller_pc.</p-->

<h3><a name="method_labels" id="method_labels">Method Labels</a></h3>

Much of the complexity in a program is hidden by methods.  The interactions between them result in a lot of issues for security, as well...

<h4><a name="labels" id="labels">Labels</a></h4>

<p> Methods have several labels associated with them; the return value label, the begin label, and the argument labels.</p>

<p>The return value label is written after the return type:</p>
<pre>
int{L} fun(int x) {
   ...
}
</pre>

<p>This is effectively the label on the returned value, just as a label on a variable gives the label for the variable.  However, this label must also take into account all ways the method might terminate, including exceptions.</p>

<p>A method also has a begin label, written immediately after the method name:</p>

<pre>
int fun{L}(int x) {
   ...
}
</pre>

<p>This avoids leaking information by calling the method; much as the pc was tainted by a conditional above, it must be tainted by calling the method.  However, since methods can be called from multiple places, the situation is slightly more complicated.</p>

<p> Any caller of the method must have label no higher than the begin label, and the method can only modify locations with label no lower than the begin label.  Thus, the caller can't read any values changed by the method, so there is no implicit flow.</p>

<p> This also explains the caller_pc in the conditional example above: note that main was declared with begin label {}, which is what caller_pc is "bounded above by".  That is the restriction just given: the caller of the method can't have pc label higher than the begin label.

<!--p>"The begin-label ensures that the method can be called only if the pc of the
caller is no more restrictive than {L}; the begin-label also ensures that the
method can only update locations with a label at least as restrictive as {L}"</p-->

<p>Finally, each argument of the method has its own label.  These are a straightforward extension of normal variable labels: when a method is called, its given arguments are effectively assigned to the formal arguments.  So these labels form an upper bound on the information passed into a function, just as a variable label gives an upper bound on the information that may be stored in the variable.</p>

<p>The argument labels also act as an ordinary variable label within the method, enforcing how the arguments may be used.</p>

<!--p>argument labels: arguments, like any variables, get labels.  Effectively
assigned values when called, so restricts values passed in.</p-->

<h3><a name="method_constraints" id="method_constraints">Method Constraints</a></h3>

In addition to various labels, methods can have additional security information associated with them, using a <code>where</code> clause:

<h4><a name="authority" id="authority">Authority</a></h4>

<p>Some actions (such as declassify and endorse, discussed below) require the authority of a principal in order to perform.  One way to get this authority is to declare it in the code:</p>

<pre>
class Game authority(referee) {
   void start() where authority(referee) {
      // this entire method body has the authority of referee
      ...
   }

   void halftimeShow() {
      // this method body does not have the authority of referee
      // (no "where authority" clause)
      ...
   }
}
</pre>

<p> Note that the class itself has the authority of referee; this is required for any methods to declare the authority.  As the comments indicate, start claims the authority, while halftimeShow doesn't.</p>

<!--p>Asserts unconditionally that the method has authority; must be inside a class
which also claims that authority.  Big hammer(?).</p>

[is this right?]-->

<h4><a name="caller" id="caller">Caller</a></h4>

<p>A less dangerous way to obtain the authority of a user is through the caller constraint: a clause of the form <code>where caller(p)</code> allows the method to use the authority of <code>p</code>.  However, it doesn't get this for free: any method calling it must also have that authority.  Thus, <code>caller</code> merely passes along the authority, but doesn't create anything new</p>

<!-->Gains rights by virtue of the caller already having rights.  Of course,
requires the caller to have rights already.</p-->

<h4><a name="actsfor" id="actsfor">Actsfor</a></h4>

<p> Principals are real Java objects, and may be passed around.  At times it may be useful to have some constraint on a principal; for example, that it has at least some authority.  A method can enforce this using a constraint of the form <code>where p actsfor q</code>, which enforces the stated relation.

<!--p>... where p actsfor q; may assume p can act for q.  To call the method, caller
must know this holds.</p-->

<h4><a name="label_relations" id="label_relations">Label relations</a></h4>

<p>Labels can also be passed around, and they're generally opaque.  However, a method can enforce some constraints on labels given to it, using a constraint of the form <code>where l1 &lt;= l2</code>.

<h4><a name="method_an_example" id="method_an_exampel">An Example</a></h4>

Here is a fairly comprehensive example, taken from the Jif Reference Manual:

<code>
int{*lbl} m{*lbl}(label{*lbl} lbl, principal{*lbl} p, int{Alice->p} i)
   where {Alice->Bob} &lt;= lbl, Bob actsfor p
{
   // since Bob actsfor p, {Alice->p} &lt;= {Alice:Bob},
   // and since {Alice->Bob} &lt;= lbl, the label of the argument i
   // is &lt;= {*lbl}. Therefore, we can return i+1.
   return i+1;
}
</code>

<p>Note that the label <code>lbl</code> is an argument to the method, and is labeled with its own value.  The return value of the method also has this label, while <code>i</code> has a policy owned by Alice, only allowing <code>p</code> (and Alice herself, and any principal acting for either of them) to read it.  So returning <code>i+1</code> would ordinarily be problematic, since lbl might contain any value, including an empty confidentiality policy that would leak the returned value <code>i+1</code> (and by extension, <code>i</code>) to the world</p>

<p>However, the constraints come to the rescue.  Since <code>Bob actsfor p</code>, Bob is allowed to read i, and <code>{Alice -&gt;Bob} &lt;= lbl</code>, so lbl preserves the confidentiality that only Bob can read the returned value, so no information leaks.</p>

<p>Or, more formally, we <code>Bob actsfor p</code> means that <code>{Alice->p} <= {Alice->Bob}</code> (since they are identical, except for principals <code>q</code> for which <code>p &lt;= q &lt;= Bob</code>, on which <code>{Alice->Bob}</code> is stricter).  Then it is given that <code>Alice->Bob &lt;= lbl</code>.  Thus, the return value can be given the label <code>{Alice->p}</code>, which is less than the return label of the method, {*lbl}.  So no information leaks.</p>

<!--pre>
public boolean{authPrf; closure; lb; this; this &lt;-}
      isAuthorized{this&lt;-}(Object authPrf,
                 Closure[this, lb] closure,
                 label lb,
                 boolean executeNow)
   where authority (this),
         {authPrf;closure;lb;executeNow} <= lb
</pre>

<p>isAuthorized, will come up later.  lb is the label of the closure, caller
asserts lb is "good enough".</p-->

<h3><a name="exceptions" id="exceptions">Exceptions</a></h3>

<p>Must be caught
Affect PC bound.  </p>

<h3><a name="lowering_security" id="lowering_security">Lowering Security</a></h3>

So far, all information flows from lower labels to higher labels; at some points, it might be necessary to make information less secure.  Jif has two mechanisms for this: declassify to reduce confidentiality, and integrity to reduce integrity.

<h4><a name="declassify" id="declassify">Declassify</a></h4>

<p>Consider checking a password.  The actual password should be secret, but if the comparison is equally secret, the result is useless.  The problem is that the comparison does release information about the password: is it the given value?  But releasing this small amount of information is acceptable.  So it can be explicitly declassified:

<pre>
   String{Alice-&gt;; Alice&lt;-} password;
   boolean{Alice&lt;- checkpw(String pw)
         where caller(Alice) {
      boolean correct = password.equals(pw);
      return declassify(correct, {Alice-&gt;; Alice&lt;-} to {Alice&lt;-});
   }
</pre>

<p>The <code>declassify</code> statement uses a special syntax; the first argument is simply the expression to declassify, but the second is of the form <code>fromLabel to toLabel</code>.  The label <code>fromLabel</code> describes the current label of the expression, and <code>toLabel</code> is the new label which should be given to the result of the declassify.</p>

<p>So in this case, correct inherits the label <code>{Alice-&gt;; Alice&lt;</code> from password, which we then declassify to {Alice&lt;-} so that the rest of the world can use the result to determine if the user really is Alice (or at least, knows Alice's password).</p>

<p> Note that the integrity of the declassified result must be at least as high as the old integrity; <code>declassify</code> can't weaken integrity.  To do that, we have to <code>endorse</code>

<h4><a name="endorse" id="endorse">Endorse</a></h4>

<p>Just as <code>declassify</code> lowers the confidentiality of an expression; <code>endorse</code> lowers the integrity of an expression: it reduces the set of principals which might have affected data.  One possible use is to take untrusted input, and then, if it looks good, we can ignore the fact that it came from someone else, since we now trust it:</p>

<pre>
   String{Alice&lt;-} sanitize(String{} input) 
         where caller(Alice) {
      // Make sure that the string is acceptable.
      return endorse(input, {} to {Alice&lt;-});
   }
</pre>

<p>Continuing the similarity to <code>declassify</code>, the confidentiality of the result must be at least as high as the original confidentiality.</p>

<h4><a name="robustness" id="robustness">Selective Downgrading and Robustness</a></h4>

<p> Both of these operations are somewhat dangerous; if an expression is declassified too far, information might be inadvertently leaked, and if it is endorsed too far, untrusted data may be let into the system.  Jif has two mechanisms that restrict <code>declassify</code> and <code>endorse</code>.</pre>

<p> Selective downgrading simply require that if an expression weakens a policy owned by a principal, it must have the authority of the principal; this explains the <code>where caller(Alice)</code> clauses in the examples above.  This is a reasonable constraint: if Bob could declassify Alice's information, the confidentiality would not be very useful.</p>

<p> Robustness is slightly tricker: it enforces that a principal can't affect the release of information to it.  So at each declassify or endorse, the set of principals who are allowed to see new information or are no longer considered to affect some data are checked against the integrity of the pc_label.  If they are in the pc_label, then the robustness check fails, and an error occurs.  For example:

<pre>
public static void dummy{}(principal{} p, int{} untrusted)
      where caller(p) {
   int trusted = endorse(untrusted, {} to {p<-});
}
</pre>

<p>This snippet seems straightforward, yet fails robustness.  The reason is that the begin label of the method is {}: that is, there is no integrity requirement.  So the caller of the method may be inside some conditional that depends on data tainted by some user <code>q</code> who is removed from responsibility for the endorsed data.  The endorsement depends implicitly on this untrusted data, so robustness fails.  Changing the begin label to {p&lt;-} allows it to compile, since now p believes that noone else can affect whether or not the method is called, so it is safe to endorse.</p>

<h3><a name="parameterized_classes" id="parameterized_classes">Parameterized Classes</a></h3>

<p>Most of the examples so far used Alice or Bob as example principals, but it's more common to have variable principals.  However, so far there is no way to pass a principal to a class.  For example, we might want to have a SecretData class which stores a secret for a particular principal, but the labels of the fields and methods will have to depend on the owner.  The solution to this problem is parameterized classes:</p>

<pre>
class SecretData[principal p] {
   int{p<-; p->} secret;
   public getSecret{p<-; p->}() {
      ...
   }
}

SecretData[Alice] = new SecretData();
SecretData[Bob] = new SecretData();
</pre>

<p>The parameters are defined in brackets after the class name, with commas between them if there are more than one.  The class can then be instantiated with a particular principal, and it is then substituted into the class as expected.  Often, the parameter can be inferred from usage, as in the constructor calls here.</p>

<p>Labels can also be used as parameters, for example in a container class:</p>

<pre>
public class List[label lb] {
   private int{lb} length;
   ...
}
</pre>

<p>This functions nearly identically to principal parameters.  The two types may be freely mixed in the parameter list of a class</p>

<h3><a name="a_large_example" id="a_large_example">A Large Example</a></h3>

The above gives the key ideas of Jif, but actually writing a program of any size is still difficult, and learning to read Jif error messages is, as with most languages, an art in itself.  So this section will walk though the implementation of a small secret-keeper application, complete with mistakes, the resulting errors, and how to fix them.



<script type="text/javascript">colorize_all()</script>
</body>
</html>

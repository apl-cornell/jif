<html>

<head>
<link rel=StyleSheet href="jifdoc.css" type="text/css">
<title>Programming in Jif</title>
</head>

<body>

<h1><a name="overview">Programming in Jif</a></h1>

<p>
Jif is an extension to the Java programming language that adds
static analysis of information flow for improved security
assurance.  The primary goal is to prevent confidential information
from being used improperly; in some versions of Jif, the goal is
also to protect the integrity of trusted information.
</p>

<p>
The largest difference between Jif and Java is the addition of
<em>labels</em> that express security policies as
restrictions on how information may be used.
These labels facilitate
statically tracking information flow. The
analysis of information flow is performed mostly statically, at
compile time. However, Jif does also support some forms of
run-time security enforcement.
</p>

<p>
Static checking of information flow
in Jif programs is performed as part of type checking. If a Jif program
type-checks, the compiler translates it into Java code that can be
compiled with a standard Java compiler. The Jif compiler and run-time
system are available from the
<a href="http://www.cs.cornell.edu/jif">Jif web site</a>.
</p>

<p>
Jif is based on the JFlow language described in the <a
href="http://www.cs.cornell.edu/andru/papers/popl99/myers-popl99.ps.gz">Practical
Mostly-Static Information Flow Control</a>, published in the <i>Proceedings of the
26th ACM Symposium on Principles of Programming Languages</i> (POPL),
pp. 228-241, January 1999, by Andrew C. Myers.
</p>

<p>
Another source of documentation for Jif can be found in Andrew Myers'
thesis, linked to from the <a
href="http://www.cs.cornell.edu/jif/">Jif web site</a>. However, the
language has developed since that time, and some features in this
version of Jif are not documented in the thesis.
</p>

<h2><a name="features"></a>Language Features</h2> 
<p>
Jif has a number of unique features that are important for
building interesting programs in a security-typed language:

<ul>
<li>A <strong>declassification</strong> mechanism gives the programmer
an explicit escape hatch for releasing information when that is necessary.
<li><strong>Principals</strong>, the entities that have security requirements,
are explicitly represented in the Jif language, 
    both as type annotations and as values that can be manipulated at
    run time. A new feature of Jif 2.0.0 is the ability to create
    <strong>user-defined principals</strong>, so that programs can define
    their own authentication and authorization procedures.
<li><strong>Statically checked access control</strong> makes it possible
    to write complex authorization code without
    creating covert information leaks.
<li>A <strong>principal hierarchy</strong> allows policies to be stated
    in a general way in terms of more abstract principals
    such as groups or roles.
<li><strong>Label polymorphism</strong> allows the expression of code 
that is generic with respect to the security class of the data it manipulates.
<strong>Principal polymorphism</strong> supports genericity
with respect to principals as well.
<li><strong>Automatic label inference</strong>
makes it unnecessary to write many type annotations.
<li><strong>Run-time label checking and first-class label values</strong>
makes it possible to discover and to define new policies at run time. Run-time
checks are statically checked to ensure that information is not leaked by
the success or failure of the run-time check itself.  Jif 2.0.0 significantly
improves the expressive power of this important language feature.
</ul>

<p>
Jif is not completely a superset of Java. Certain features have
been omitted to make information flow control tractable. Also, Jif
does not eliminate all possible information leaks
(particularly, various kinds of <em>timing channels</em>).
</p>

<h3><a name="labels">Labels and labeled types</a></h3>

<p>
In Jif, every value has a <em>labeled type</em> that consists of two parts:
an ordinary Java type such as <code>int</code>,
and a <em>label</em> that describes how
the information can be used.
Any type expression <i class="math">t</i>
may be labeled with any label expression <i class="math">l</i>.
This labeled type expression is written <code><i class="math">t</i>{<i class="math">l</i>}</code>; for example, the
labeled type <code>int{p:}</code> represents an integer that principal <code>p</code> owns
and that only <code>p</code> can read.
For example, a variable may be declared with this labeled type: 
<div class="code"><pre>
int{p:} x = 2;
</pre></div>
</p>

<p>
In general,
a label is written as a set of <em>policy expressions</em>,
separated by semicolons. For example,
the label expression
<code>{o<sub>1</sub>: r<sub>1</sub>,r<sub>2</sub>; o<sub>2</sub>: r<sub>2</sub>,r<sub>3</sub>}</code> contains two policy expressions.
A policy expression <code><i class="math">owner</i>:
<i class="math">reader</i><sub>1</sub>,
<i class="math">reader</i><sub>2</sub>, ...</code>
means that the
principal <code><i>owner</i></code> wants to allow the labeled
information to flow to at most the principals
<code><i>reader<sub>i</sub></i></code>. Labels built from these
policies are called <em>decentralized labels</em> because they
enforce security on behalf of the owning principals, not on
behalf of an implicitly centralized policy specifier.
</p>
<p>
The compiler permits information to flow between locations
with different labels only if that information flow does not
lose policy restrictions.
In particular, if information is
able to flow from a location with label <i class="math">L</i><sub>1</sub>
to a location with label <i class="math">L</i><sub>2</sub>, the
label <i class="math">L</i><sub>2</sub> must be more restrictive
than <i class="math">L</i><sub>1</sub></i>, or equally restrictive.
This is written formally as
<i class="math">L</i><sub>1</sub></i> &#8849; 
<i class="math">L</i><sub>2</sub></i>. (The ordering &#8849;
defines a preorder on labels in which the equivalence
classes form a join semilattice.)
</p>
<p>
When differently labeled inputs are
combined, the result may reveal information about
any of the inputs. For example, when two variables
<code>x</code> and <code>y</code> are added, the sum
<code>x+y</code> may reveal information about both
<code>x</code> and <code>y</code>.  Conservatively,
the label of the result is the union of the policies
in the labels of the inputs. This union is the
<em>join</em> or <em>least upper bound</em>
of the input labels. For example, if the label of
<code>x</code> is <code>{p:q}</code> and the label of
<code>y</code> is <code>{a:b; p:q,r}</code>, the
label of the result is <code>{p:q; a:b; p:q,r}</code>,
which is equivalent to <code>{p:q; a:b}</code>.
</p>
<p>
In a program, a policy component of a label
may take a few additional forms. One such
form is a variable name, which denotes the set of policies
in the label of the variable named.  For example, suppose
that <code>a</code> is a variable and hence has a labeled type.
The label expression <code>{a}</code> contains a single component expression;
this label means that value it labels should be as restricted as the
contents of <code>a</code> are. The more complex
label expression <code>{a; o: r}</code> contains two policy components,
indicating
that the labeled value should be as restricted as <code>a</code> is, and also that
the principal <code>o</code> restricts the value to be read by at most
the principal <code>r</code>.
Other kinds of label components will be introduced later.
</p>

<p>
A labeled type may occur in a Jif program almost anywhere a type
may occur in a Java program. In fact, if the label is omitted from a type,
the Jif compiler automatically generates a label for that type according
to rules that are discussed later.
</p>

<p>
The type and label parts of a labeled type act largely independently.
The notation <i class="math">S &le; T</i> is used here to mean
that the type <i class="math">S</i> is a subtype of the type
<i class="math">T</i>. The intuitive
behavior of subtyping is that it operates independently on the type
and label: for any two types <i class="math">S</i> and <i
class="math">T</i> and labels <i
class="math">L</i><sub>1</sub> and <i
class="math">L</i><sub>2</sub>,
<i class="math">S</i> &le;
<i class="math">T</i> and
<i class="math">L</i><sub>1</sub> &#8849;
<i class="math">L</i><sub>2</sub></i> iff
<i class="math">S</i>{<i class="math">L</i><sub>1</sub>}
&le; <i class="math">T</i>{<i class="math">L</i><sub>2</sub>} (as in
[VSI96])
</p>

<h4><a name="principal-hierarchy"></a>Principals</h4>

<p>
In the decentralized label model implemented by Jif,
information is owned by, updated by,
and released to <em>principals</em>: users and other
authority entities such as groups or roles.  For example, both users and
groups in Unix would be modeled as principals.
</p>

<p>
Some principals may be authorized to <em>act for</em>
other principals. If the principal <code>p</code> acts for the
principal <code>q</code>, any action taken by <code>p</code>
is implicitly assumed to be authorized by <code>q</code>.
The acts-for relation is reflexive and transitive,
defining a hierarchy or partial order
of principals. This relation is similar to the <em>speaks for</em>
relation used in various authentication logics (e.g., [LABW91]);
the hierarchy of principals is also similar to a <em>role hierarchy</em>
[RBAC].
</p>

<p>
The acts-for relation can be used to model groups and
roles conveniently. A group principal, such as <code>students</code>,
is modeled by authorizing all of the principals
representing members of the group
to act for the group principal. That is, the group principal delegates
its authority to all of the group members.  A
role, a restricted form of a user's authority, is modeled by
authorizing the user's principal to act for the role principal.
</p>

<p><a name="actsfor"></a>
The acts-for relationship between two principals can be tested
in a Jif program using the built-in <code>actsfor</code> operator. The
boolean expression <code>p actsfor
q</code> evaluates to <code>true</code>
if the
specified relationship exists. Within the body of an <code>if</code>
statement conditioned on this test (see <a href="#runtime-tests">below</a>), the compiler makes use of
the knowledge that the relationship exists when checking
information flows and comparing security policies.
</p>

<p>As discussed <a href="#user-defined-principals">below</a>, Jif 2.0.0
adds support for user-defined principals and user-defined
authentication mechanisms.</p>

<h4><a name="implicit-flows">Implicit flows and
program-counter labels</a></h4>

<p>
The label of an expression's value varies depending
on the evaluation context.
This is needed to prevent leaks through
<em>implicit flows</em>: channels created by the control flow structure
itself.
To prevent information leaks through implicit flows, the compiler
associates a <em>program-counter label</em> (<u>pc</u>)
with every statement and expression,
representing the information that might be learned from
the knowledge that the statement or expression was evaluated.

<p>
For example, consider the following program, which is obviously
equivalent to the statement <code>l = h</code>, assuming
<code>h</code> is a boolean variable:
<div class="code"><pre>
boolean l = false;
if (h) {
    l = true;
}
</div>
</p>

<p class="cont">
If <code>l</code> contains public (low) information and <code>h</code>
contains secret (high) information, this program is not secure.
The solution is that by conditioning on the variable <code>h</code>,
the <code>if</code> statement makes the <u>pc</u> of the assignment
to <code>l</code> at least as restrictive as <code>{h}</code>.
Assume no information can be learned from the fact that the
program is executed (that is, initially <u>pc</u>&nbsp;=&nbsp;<code>{}</code>).
In this case, the value of <u>pc</u> during the consequent clause is
<code>{h}</code>.
After the <code>if</code> statement, it is again true that <u>pc</u> = <code>{}</code>,
because no information
about <code>h</code> can be deduced from the fact that the statement after the <code>if</code>
statement is executed. (It is not true in general that the value of <u>pc</u>
reverts after <code>if</code> statements,
but is true here because this <code>if</code> statement always terminates
without exceptions.)
The label of a literal expression (e.g., <code>true</code>) is the same as its <u>pc</u>, or <code>{h}</code>
in this case.
So the assignment is permitted only if the label <code>{l}</code> is
at least as restrictive as the label <code>{h}</code>. This would not be
true if <code>l</code> were public and <code>h</code> secret.
</p>

<p>
One way to think about the program-counter label is that
there is a distinct <u>pc</u> for every basic block in the program.
In general, the flow of control within a program depends on the values of
certain expressions. At any given point during execution, various values
<i class="math">v<sub>i</sub></i> have been observed in order to decide to arrive at the
current basic block; therefore, the labels of these values affect the
current <u>pc</u>. The Jif type system will ensure that the <u>pc</u>
label is at least as restrictive as the labels of all the variables on
which the program counter depends.
</p>

<p>
A related issue is the transmission of information through
the termination or non-termination of a program.
Consider the execution of a <code>while</code> statement
<code>while (h != 0) { ... }</code>.
According to the Jif type system,
assuming that initially <u>pc</u>=<code>{}</code>, then
after the statement terminates, <u>pc</u>=<code>{}</code>, using the
same reasoning as for the <code>if</code> statement. This
labeling might seem strange, because we
know the value of <code>h</code> when we arrive at the final basic block.
However, arriving at the final block gives no
information about the value of <code>h</code> before the code started.
Therefore, 
Jif does not attempt to control information transfers through
termination channels. It also ignores timing channels, which are
an issue for concurrent programming languages. Jif does not support
the Java thread model for concurrent programming.
</p>

<h4><a name="method-decls">Method declarations</a></h4>
<p>
The syntax of a Jif method
declaration has some extensions
when compared to Java syntax;
there are a few optional annotations,
including annotations for
controlling information flow and for managing
code authority.
</p>

<p>
In a Jif method declaration, the return value, the arguments, and
the exceptions each may be given their own individual label.
There are two optional labels in a method declaration called the
<em>begin-label</em> and the <em>end-label</em>. 
The begin-label is used to specify any
restriction on <u>pc</u> at the point of invocation of the method.
The begin-label allows information about the <u>pc</u> of the caller to
be used for statically checking the implementation, thereby
preventing assignments within the method from creating implicit flows
of information.
</p>

For example, a Jif version of the Java class
<code>Vector</code> looks like the following:

<div class="code"><pre>
public class Vector[label L] extends AbstractList[L] {
    private int{L} length;
    private Object{L}[]{L} elements;

    public Vector() ...
    public Object elementAt(int i):{L; i}
	            throws (IndexOutOfBoundsException) {
        ...
	return elements[i];
    }
    public void setElementAt{L}(Object{} o, int{} i) ...
    public int{L} size() { return length; }
    public void clear{L}() ...
    ...
}
</pre></div>

<p>
This code provides several examples of Jif method
declarations. The class is generic with respect to a label 
parameter <code>L</code>, permitting Vectors to be used to
store information of any one desired label. (Parametric
polymorphism over labels is discussed <a href="#parameterized-classes">later</a>).
</p>

<p>
The method <code>setElementAt</code> in this declaration
is prevented from leaking information
by its declared begin-label, <code>{L}</code>.
It can be called only if the <u>pc</u> of the
caller is no more restrictive than <code>{L}</code>. The labels of the
arguments <code>o</code> and <code>i</code> are written as
<code>{}</code>, but as discussed in the
following section, argument labels automatically
include the begin-label,
so both arguments are effectively labeled by <code>{L}</code>.
</p>
<p>
The end-label of a method specifies the <u>pc</u> at the point of termination
of the method, and captures the restrictions on the information that
can be learned by observing whether the method terminates normally.
Individual exceptions and the return value itself
also may have their own distinct labels, allowing static
label checking to track information flow at fine granularity. For
example, the end-label of the <code>elementAt</code> method,
<code>{L;i}</code>,
means that the <u>pc</u> following normal termination of the
method is at least as
restrictive as both the label parameter <code>L</code> and the label
of the argument <code>i</code>. This
end-label is necessary because when the index-out-of-bounds exception is
thrown, an observation has been made of both the instance variable
<code>elements</code> and the argument <code>i</code>.
Therefore, knowledge of the termination path of the method
may give information about the contents of these two variables.
</p>


<h4><a name="default-labels"></a>Default labels</h4>

<p>A powerful feature of Jif is automatic inference of the
labels of local variables. The Jif compiler can figure out whether there
is a way of labeling local variables to satisfy all the label
constraints. However, most of the time you do need to write down
labels of fields and method signatures, including the begin-label,
end-label, result label and arguments' labels. When these labels
are missing, some conservatives rules are used to assign restrictive
default labels:</p> 

<ul> 
<li>Default field label: the bottom label, <code>{}</code>
<br>
If a field's type declaration does not include a label, then by
default its label is <code>{}</code>, which is conservative because no
confidential data can be stored in the field.
</li>

<li> Default argument label: the top label, <code>&lt;top&gt;</code>
<br>
The label on the type of a formal argument is an upper bound for
labels of actual arguments. See the section on <a
href="#label-polymorphism">label polymorphism</a>.  
</li>


<li> Default method begin-label: the top label, <code>&lt;top&gt;</code>
<br>
The method begin-label is an upper bound on the <u>pc</u> of the caller, and
a lower bound on the side effects of the method.  The default method begin
label is <code>&lt;top&gt;</code>, the most restrictive label, meaning
that the method has no side effects.
</li>

<li>Default method end-label: The join of the declared
labels of any exceptions declared to be thrown.
<br>
The method end-label (how much information may be gained by knowing
the method terminates normally) is by default the join of the declared
labels of any exceptions that the method declares that it
throws. Thus, if the method does not throw any exceptions, or if the
declared exceptions do not have any labels, the default method
end-label is the bottom label, <code>{}</code>.
</li>

<li> Default method result label: the join of all the argument labels and the end-label. 
<br>
The method result label (the label of the value returned by the
method) is by default the method end-label joined with all of the
argument labels (<i>not</i> the upper bounds of the argument labels;
see the section on <a href="#method-polymorphism">polymorphic
methods</a>).  This is the common case, as most of the time the value
returned by a method is the result of computation on all of its
arguments.
</li>

<li> Default declared exception label: the method end-label.
<br>
A method may declare that it throws certain exceptions; if an
exception is declared to be thrown, but no label is given for that
exception type, then by default it is assumed to be the same as the
method end-label.
</li>
</ul>

<h3><a name="access-control"></a>Authority and access control</h3>

<p>
A method executes with some
<em>authority</em> that has been granted to it. The authority is essentially the
capability to act for some set of principals, and
controls the ability to declassify data. This simple authority mechanism
can be used to build more complex access control mechanisms.
It is also useful for releasing information.
</p>

<p>
At any given point within a program, the compiler understands the
code to be running with the ability to act for some set of
principals; the static authority of the code at that point. The actual
authority may be greater, because the known principals may be able to act
for other principals. The static authority can never exceed the actual
authority unless revocation occurs while the program is running.
</p>

<p>
The static checker maintains a notion of the <em>static principal
hierarchy</em> at every point in the program. The static principal hierarchy
is a set of acts-for relations that are known to exist. The static
principal hierarchy is a subset of the acts-for relations that exist in
the true principal hierarchy.
The static authority of a method may be augmented by testing the
principal hierarchy dynamically, using the
<a href="#actsfor"><code>actsfor</code> test</a>.
</p>

<h4><a name="declassification">Declassification</a></h4>

<p>
A program can use its authority to declassify information according to
the the decentralized label model. Declassification weakens
the policies restricting how the information can be used. It
provides an escape hatch from strict information flow
control, which is important for writing realistic programs.
Importantly, the use of declassification is mediated by the
static authority of the program.
</p>

<p>
The expression <code>declassify(<i>e</i>,
<i>L</i><sub>1</sub>, <i>L</i><sub>2</sub>)</code>
relabels the result of an expression <code><i>e</i></code>
from the initial label <code><i>L</i><sub>1</sub></code> to
the label <code><i>L</i></code><sub>2</sub>.
Declassification is checked statically, using the static
authority at the point of declassification. The
<code>declassify</code> expression
may relax only the policies owned by principals in the static authority.
It is also possible to omit the label
<code><i>L</i><sub>1</sub></code> in the expression, though
this form is deprecated.
</p>

<p>
A program also can use its authority to declassify the program-counter
label. This functionality is provided by the Jif statement
<code>declassify(<i>L</i>) <i>S</i></code>,
which executes the statement <code><i>S</i></code>
using the program-counter label <code><i>L</i></code>.
This form of declassification is
also checked statically. For example, the following is an example of
a <code>declassify</code> statement.
<div class="code"><pre>
int b;
int y = 0;
if (b) {
    declassify ({y}) y = 1;
}
</pre></div>
</p>

<p>
Assuming that the label of <code>y</code> is not more restrictive than
the label of <code>b</code>, this program declassifies the implicit flow
from <code>b</code> into <code>y</code>. For the duration of
the assignment into <code>y</code>,
the program-counter label is relaxed until it is no more restrictive than
<code>y</code> itself.  The legitimacy of the declassification is 
statically checked using the label of <code>y</code> and the static authority
of the program at this point. Note that the labels of
<code>b</code> and <code>y</code> are
both automatically inferred in this example; these automatically inferred
labels are not a problem for checking declassification statically.
</p>

<h4><a name="authority-decls">Authority declarations</a></h4>

<p>
There are two ways for method code to acquire authority. First, the
class containing the code may declare that it has the
authority of some principal using an <code>authority</code>
clause. A method of the class can then claim and use that 
authority if its signature includes a <code>where authority</code>
clause of its own. It is easy to identify the code to which
principal <code>p</code> has directly granted its authority
because of these clauses. For example, in the following code
the class <code>Game</code> has the authority of the
principal <code>referee</code>:
</p>

<div class="code"><pre>class Game authority(referee) {
    void start() where authority(referee) {
	<span class="comment">// this entire method body has the authority of referee</span>
	...
    }

    void halftimeShow() {
	<span class="comment">// this method body does not have the authority of referee
	// (no "where authority" clause)</span>
	...
    }
}
</div>
 
<p>
The second way for a method to acquire authority is for the
method to receive authority passed from another method. If the
receiving method signature contains a clause of the form
<code>where caller(p)</code>, then it can be called only
from code that is statically known to have the authority of
principal <code>p</code>. For example, the following method
receives authority for a principal <code>p</code> that is
determined at run time and passed as an argument to the
method.
</p>

<div class="code"><pre>
    void m(principal p) where caller(p) {
	<span class="comment">// this method body has the 
        // authority of the dynamic principal p</span>
	...
    }
}
</pre>
</div>

<p>
A final annotation for method declarations is a clause of
the form <code>where <i>p</i> actsfor <i>q</i></code>. When
this clause is present, the method can be called only from a
context where the specified relationship can be statically
determined to hold. The body of the method is checked under
the assumption that the specified relationship does hold.
</p>

<p>
These mechanisms can be used to implement access control
security within a program and are similar in expressiveness
to the Java stack inspection mechanism, while avoiding the
run-time overhead. Of course, Jif
offers more security assurance than stack inspection because
it also controls information flow.
</p>




<h3><a name="label-polymorphism">Polymorphism</a></h3>

<p>
Libraries of reusable code make up the bulk of most
program code. Jif supports various kinds of polymorphism to make
it possible to write reusable code that is not tied to any
specific security policy.
</p>

<p>
The most common form of polymorphism is over the labels of
arguments to a method.
When an argument label is omitted, the method is generic
with respect to the label of the argument. Consider
implementing a cosine method <code>cos</code>:
</p.

<div class="code"><pre>
double cos(double x);
</pre></div>

<p class="cont">
Omitting the label on the argument <code>x</code> means that
this method can be applied to an argument <code>x</code>
with any label.
</p>

<p>
Without label polymorphism, there are two strategies: reimplement it
for every argument label ever used, or implement it using run-time labels
(discussed <a href="#dynamic-labels">later</a>).
The former approach is clearly infeasible.
Implicit labels have the advantage
over run-time labels that when they
provide adequate power, they are easier and cheaper to use.
</p>

<p>When formal variables have declared labels, the method is
still polymorphic with respect to the label of the argument;
however, the declared label serves as a bound on the allowed
argument labels.
For example, in the following method
signature, the method <code>m</code> returns a <code>String</code> whose
label is the same as the label of the argument <code>a</code>.

<div class="code"><pre>
String{a} m(int{Alice: ; Bob:} a);
</pre></div>

<p>The label on the declaration of the argument <code>a</code> is
<code>{Alice: ; Bob:}</code>. This means that the label of any actual
argument given to <code>m</code> can be <i>at most</i> as restrictive
as <code>{Alice: ; Bob:}</code>, that is, <code>{Alice: ; Bob:}</code> is an
upper bound on the label of any actual argument to <code>m</code>. The
following code that calls the method <code>m</code> compiles
successfully.
<div class="code"><pre>
int{Alice: Chuck} i = 42;
String{Alice: Chuck} s = m(i);
    <span class="comment">// OK: m returns a String with the same label as i</span>
</pre></div>
 

<p>In the body of the method <code>m</code>, all that is known about
the label of the formal argument <code>a</code> is that <code>{Alice:
; Bob:}</code> is an upper bound for it. Thus, the first line of the method body below is illegal, while the second is legal.

<div class="code"><pre>
String{a} m(int{Alice: ; Bob:} a) {
    int{Alice:} i = a; <span class="comment">// ILLEGAL!  Don't know that {a} <= {Alice:}</span>
    int{Alice: ; Bob: ; Chuck: } j = a; <span class="comment">// OK</span>
    ...
}
</pre></div>
 

<p>The labels of arguments given to a method are not represented at
runtime. That is, within a method body, there is no runtime
representation of labels of the arguments. The following code
that manipulates run-time labels is thus illegal.

<div class="code"><pre>
void foo(int{Bob:} a) {
    label lb = new label {Alice: ; a};
	<span class="comment">// ILLEGAL! Label of a is not runtime representable.</span>

    if (new label {a} &lt;= new label {Bob: Chuck})
	<span class="comment">// ILLEGAL! Label of a is not runtime representable.</span>
    { ... }
}
</pre></div>
 

<p>If no label is specified for a formal argument, then it is assumed
that there are no restrictions on the labels of the actual arguments
that may be passed in. See the section on <a
href="#default-labels">default labels</a>.

<h3><a name="parameterized-classes"></a>Parameterized classes</h3> 

<p>Parameterized types have long been known to be important for building
reusable data structures. A parameterized class is generic with respect to
some set of type parameters. This genericity is particularly useful for building
collection classes such as generic sets and maps.
It is even more important to have polymorphism in the information flow domain;
the usual way to handle the absence of statically-checked type polymorphism
is to perform dynamic type casts, but this approach works poorly
when applied to information flow, because dynamic tests create
new information channels.
</p>

<h4><a name="label-principal-params">Label and principal parameters</a></h4>

<p>
Jif allows classes and interfaces to be parameterized by explicitly declared
label and principal parameters. The earlier example of a <code>Vector</code>
class demonstrated the use of a label parameter:
</p>

<div class="code"><pre>
public class Vector[label L] extends AbstractList[L] {
    private int{L} length;
    private Object{L}[]{L} elements;

    public Vector() ...
    public Object elementAt(int i):{L; i}
	            throws (IndexOutOfBoundsException) {
        ...
	return elements[i];
    }
    public void setElementAt{L}(Object{} o, int{} i) ...
    public int{L} size() { return length; }
    public void clear{L}() ...
    ...
}
</pre></div>

<p class="cont">
 The <code>Vector</code> class is parameterized on a label <code>L</code> that represents the
label of the contained elements. Assuming that
<code>secret</code> and <code>public</code> are appropriately defined,
the types <code>Vector[{secret}]</code> and <code>Vector[{public}]</code> would represent
vectors of elements of differing sensitivity. These types are referred
to as <em>instantiations</em> of the parameterized type <code>Vector</code>. Without the 
ability to instantiate
classes on particular labels, it would be necessary
to reimplement <code>Vector</code> for every distinct element label.
</p>

<p>
A class may also be parameterized with respect to principals, as in this
example:

<div class="code"><pre>
class paramCell[principal p, principal q] {
    int{p: q} contents;
}
</pre></div>

<p>
This class may be instantiated with any
two principals <code>p</code> and <code>q</code>. For example,
the instantiation <code>paramCell[Bob,Amy]</code> has
a field <code>contents</code> with the label <code>{Bob: Amy}</code>.
</p>

<h4><A NAME="param-interact-object-types">Interactions with object types</A></h4>

<p>
When a parameterized or unparameterized type inherits from a superclass,
or implements an interface, the supertype may be an instantiation.  The
instantiation that is inherited from or implemented must be a legal type
within the scope of the class that is inheriting from or implementing
it. This is a specific instance of a more general rule in Jif:
within a parameterized class or interface, the formal parameters
of the class may be used as actual parameters to instantiations of
parameterized types within its scope.
</p>

<p>
The presence of label and principal parameters means
instantiations of parameterized classes are simple <em>dependent types</em>,
because types depend on values. To ensure that these dependent types have
a well-defined meaning, only &ldquo;<code>final</code>&rdquo;
expressions may be used as parameters;
since they are immutable, their meaning cannot change. An alternative approach
would be to allow all variables to
be used as parameters; however, in that case two different types that
mention the same variable would have different meanings if an assignment
to the variable occurred between them.
</p>

<p>
Subtyping is ordinarily invariant on class parameters. For example,
even if <code>{public}</code> &#8849; <code>{secret}</code>, it is not the case
that <code>Vector[{public}]</code> &le; <code>Vector[{secret}]</code>.
(The label ordering is denoted here as &#8849,
and the subtype relation is denoted by &le;.) This subtype
relation would be unsound because <code>Vector</code> is mutable.
</p>

<p>
When such a subtype relation is sound, the parameter may be declared
as a <code>covariant label</code> rather than as a <code>label</code>. Covariant label parameters
are made sound by placing additional restrictions on their use,
as follows.
A covariant label parameter may not be used to construct the label for
a non-<code>final</code> instance variable.  It also may
not be used as an actual parameter to a class whose formal parameter
is a (non-<code>covariant</code>) <code>label</code>. However,
immutable (<code>final</code>) instance variables and method arguments and return
values may be labeled using a covariant parameter.
</p>

<p>
Although Jif does not support user-defined type parameters, it does support one
type with a type parameter: the built-in Java array type, which is used as the
type of the instance variable <code>elements</code> in the <code>Vector</code>
example.  Arrays are parameterized with respect to both the type of the
contained elements and the label of those elements. In the example for
<code>Vector</code>, the type of the instance variable <code>elements</code> is
<code>Object{L}[]</code> which represents an array of <code>Object</code> where
each element in the array is labeled with <code>L</code>. The array type
behaves as though it were a type <code>array[T,L]</code> with two parameters:
an element type and an element label; in this case <code>T</code> =
<code>Object</code>.  The label parameter may be omitted, in which case it
defaults to <code>{}</code>.  For example, the types <code>int[]</code> and
<code>int{}[]</code> are equal.
</p>

<h4><A NAME="params-runtime">Using parameters at run time</A></h4>
<p>
A new feature in Jif 2.0.0 is that
all class parameters are represented and accessible
at run time. Thus, the following code,
which uses the parameters <code>L</code> and <code>P</code> at runtime, 
is permitted.  

<div class="code"><pre>
class C[label L, principal P] {
    private final label{this} lb = L;         <span class="comment">// runtime use of L</span>

    private void m() {
        label foo = new label {L; Alice:};    <span class="comment">// runtime use of L</span>
        principal bar = P;                    <span class="comment">// runtime use of P</span>
    }
}
</pre>
</div>


<p>When a parameter is treated as an ordinary value, its label is the label
<code>{this}</code>. That is, the information that may be conveyed by
knowing the run-time value of a parameter is the same as the
information that may be conveyed by the reference to the current
object. Thus, if the label of the final field <code>lb</code> in the
example above was not at least as restrictive as the label
<code>{this}</code>, the example would not compile.

<h3><a name="dynamic-labels"></a>Dynamic labels and principals</h3>

<p>
Labels and principals can be used as first-class values, represented at
runtime. These &ldquo;dynamic&rdquo; labels and principals can be used in the
specification of other labels, and used as the parameters of <a
href="#parameterized-classes">parameterized classes</a>. (Thus, Jif's
type system has dependent types.) Consider the following example.
</p>

<div class="code"><pre>
class C[label L] { ... }

...

void m() {
    final label lb = new label {Alice: Bob};

    int{*lb; Bob:} x = 4;

    C[lb] foo = null;
    C[{*lb}] bar = foo;
}
</pre>
</div>

<p>Here we see a local variable <code>lb</code>, of type
<code>label</code>. At runtime, this variable will contain a
representation of the label <code>{Alice: Bob}</code>. The type of the
variable <code>x</code> is declared to be <code>int{*lb; Bob:}</code>,
that is, an integer whose label the policy <code>{Bob:}</code> joined
with the <i>value</i> stored in the variable <code>lb</code>. This is
an example of a dynamic label being used in another label.

<p>The variable <code>foo</code> is of type <code>C[lb]</code>, that
is, its type is the class <code>C</code> instantiated with the label
that is stored in the variable <code>lb</code>. This type is
equivalent to the type <code>C[{*lb}]</code>, since the label stored
in the variable <code>lb</code> is equivalent to the label <code>{*lb}</code>.

<p>Jif's allows more than just local variables of type
<code>label</code> and <code>principal</code> to be used to construct
new labels and types. in fact, any <i>final access path</i> expression
may be used. A final access path expression is an expression of the
form <i>r.f<sub>1</sub>.f<sub>2</sub>. ... .f<sub>n</sub></i>, where <i>r</i> is either a final local
variable, or the expression <code>this</code>, and each
<i>f<sub>i</sub></i> is an access to a final field. Thus, the following are all examples of legal uses of dynamic labels
and principals.

<div class="code"><pre>
class C[label L, principal P] {
    final label lb;    
    final principal q;
    final C[lb, Alice] next;

    public C() { ... }

    void m(principal pp) throws NullPointerException {
        final C[this.next.lb, pp] foo = new C[this.next.lb, pp]();
        C[{Alice: foo.q}, P] quux = null;

        int{foo.next.q: ; *this.lb} x = 8;        
    }
}
</pre>
</div>
<p>
Unlike in Java, method arguments in Jif are always implicitly
<code>final</code>. This change makes the use of first-class principals and labels
more convenient.  This simple change does not
remove any significant power from the language, since code that assigns
to an argument variable always can be rewritten to use a local variable
instead.
</p>


<p>Final access paths appearing in labels and types may act as covert
channels. For example, an access path may throw a null pointer
exception, or the value stored in a particular variable may reveal
sensitive information. The Jif type system must account for the
information that may be revealed whenever a final access path in a label
or type is evaluated at runtime. Final access paths occurring in a
label may be evaluated at runtime when a <code>new label</code>
expression is evaluated; final access paths occurring in a type may be
evaluated at runtime during the evaluation of casts to a parameterized
type, <code>instanceof</code> checks against a parameterized type,
construction of a new object of parameterized type, or a call to a
static method of a parameterized type.

<p>In the following example, an <code>instanceof</code> check is
performed against a parameterized type,
<code>C[{this.f.p:}]</code>. The evaluation of this expression
requires the evaluation of the access path expression
<code>this.f.p</code>, which may throw a
<code>NullPointerException</code> if <code>this.f</code> is
null. Thus, whether or not a <code>NullPointerException</code> is
thrown may reveal information at level <code>{this;
Alice:}</code> (which is the label of the expression <code>this.f</code>). 
Thus, if the assignment to the local variable
<code>x</code> occurs, information with the label <code>{this;
Alice:}</code> is flowing, and thus the label of the variable
<code>x</code> must be at least <code>{this; Alice:}</code>.

<div class="code"><pre>
class C[label L] { ... } 

class D { 
    final D{Alice:} f; 
    final principal{} p;

    ...

    void m(Object{} o) {
        try {
            boolean{Alice:; this} x = (o instanceof C[{this.f.p:}]);
        }
        catch (NullPointerException e) {
	    <span class="comment">// may be thrown by the evaluation of "this.f.p"</span>
	} 
    }
}
</pre>
</div>


<h4><a name="runtime-tests"></a>Runtime tests of labels and principals</h4>

<p>Jif provides a mechanism for comparing runtime labels, and also a
mechanism for comparing runtime principals. Both mechanisms use a
syntax similar to that of if statements.

<p>An <i>if-label</i> statement allows the runtime comparison of labels. It has the following form: 
<div class="code"><pre>
if (L1 <= L2) { 
    ... 
} 
else { 
    ... 
}
</pre></div>
 

<p>If the label <code>L2</code> is at least as restrictive as
the label <code>L1</code>, then the code in the <code>then</code>
branch is executed; otherwise, the code in the <code>else</code>
branch is executed. The <code>else</code> branch is
optional. During the label checking of the  <code>then</code>
branch, it is assumed that the label <code>L2</code> is indeed at least as restrictive as
the label <code>L1</code>. Thus, the following code compiles correctly.

<div class="code"><pre>
void m(int{*lbl} i, label{} lbl) {
    int{Alice:} x;
    if (lbl <= new label {Alice:}) {
        x = i; <span class="comment">// OK, since {*lb} &lt;= {Alice:}</span>
    }
    else {
        x = 0;
    }
}
</pre></div>


<p>
Note that this construct replaces the <code>switch-label</code> construct that existed in previous versions of Jif.
</p>

<p>An <i>actsfor</i> statement allows the runtime comparison of principals. It has the following form: 
<div class="code"><pre>
if (P1 actsfor P2) { 
    ... 
} 
else { 
    ... 
}
</pre></div>
 

<p>If the principal <code>P1</code> can act for the principal
<code>P2</code>, then the code in the <code>then</code> branch is
executed; otherwise, the code in the <code>else</code> branch is
executed. The <code>else</code> branch is optional. During the label
checking of the <code>then</code> branch, it is assumed that the
principal <code>P1</code> can act for the principal
<code>P2</code>. Thus, the following code compiles correctly.

<div class="code"><pre>
void m(int{Alice: pr} i, principal{} pr) {
    int{Alice: Bob} x;
    if (Bob actsfor pr) {
        x = i; <span class="comment">// OK, since {Alice: pr} &lt;= {Alice: Bob}</span>
    }
    else {
        x = 0;
    }
}
</pre></div>


<p class="cont">
Note that this construct replaces the <code>actsfor { ... } else { ... }</code> construct that existed in previous versions of Jif.
</p>

<h4><a name="user-defined-principals"></a>User-defined principals</h4>

<p>Jif provides an open-ended mechanism to allow applications written in
Jif to define their own principals. The Jif interface <a
href="rt-api/jif/lang/Principal.html"><code>jif.lang.Principal</code></a>
is used to represent principals, and Jif programs may implement this
interface to define their own principals.

<p>Objects of type <code>jif.lang.Principal</code> can be implicitly
cast to the type <code>principal</code>, and vice-versa.

<p>The interface <code>jif.lang.Principal</code> is defined
as follows:

<div class="code"><pre>
public interface Principal {
    String name();
    boolean delegatesTo(principal p);
    boolean equals(Principal p);
    boolean isAuthorized(Object authPrf, 
		         Closure[this, lb] closure,
		         label lb) where authority (this);

    Principal{this;p}[] findChainUpto{p;this}(Principal p);
    Principal{this;q}[] findChainDownto{q;this}(Principal q);
}
</pre></div>

<p>The method <code>name()</code> returns the name of the
principal. The <code>equals(Principal p)</code> method is used to
determine if the receiver object is the same as the principal p; two
principals <code>p</code> and <code>q</code> are regarded as being
equal only if <code>p.equals(q) && q.equals(p)</code>.

<p>The method <code>delegatesTo(principal p)</code> returns true if the
principal represented by the receiver object has delegated its
authority to the principal <code>p</code> (and thus <code>p</code> can
act for the principal represented by the receiver object).

<p>The methods <code>findChainUpto(Principal p)</code> and
<code>findChainDownto(Principal p)</code> are used to search for a
"delegates chain", a chain of principals between two principals, which
is proof that the principal at the head of the chain is able to act
for the principal at the tail of the chain.

<p>The method <code>isAuthorized(Object authPrf, Closure[this, lb]
closure, label lb)</code> is used to determine if the object
<code>authCode</code> is sufficient proof for the principal
represented by the receiver object to grant its authority to execute
the <code>Closure</code>. The form of the authorization proof will
depend on the principal implementation, but could be, for example, a
password, or a certificate, or some other capability.

<p>A <code>Closure[principal P, label L]</code> (see
$JIF/sig-src/jif/lang/Closure.java) is code that needs the authority of
the principal P to execute, and whose side effects are bounded below
by L. To execute a closure, a <code>Capability</code> (see
$JIF/sig-src/jif/lang/Capability.java) is required. A capability can only
be obtained by calling the method
<code>jif.lang.PrincipalUtil.authorize(principal p, Object authPrf,
Closure[p, lb] c, label lb)</code>, which returns a Capability to
execute the closure if the method <code>isAuthorized(authPrf, c,
lb)</code> called with receiver principal <code>p</code> returns true, and null
otherwise.


<p>The class <code>jif.lang.AbstractPrincipal</code> (found in the
$JIF/lib-src directory) is an abstract implementation of
<code>jif.lang.Principal</code> that many principal implementations
will find useful. The class <code>jif.lang.PrincipalUtil</code>
contains several utility methods to help in searching for
delegates-chains and also for obtaining capabilities to execute
closures.

<p>External principals (e.g., the principals Alice and
Bob mentioned in Jif code; see $JIF/tests/jif/lang/Alice.jif) are
implemented using the class <code>jif.lang.ExternalPrincipal</code>
(found in the $JIF/lib-src directory). You can create your own
external principals in a similar way. See the <a
href="../tests/README">README</a> file in $JIF/tests for more
information about creating external principals.


<h3><a name="java-changes">Other changes to Java</a></h3>

<p>
Jif makes several less significant changes to Java that are
necessary in order to reason securely about information
flow.
</p>

<h4><a name="static-fields"></a>Static fields</h4>

<p>Static fields of classes are supported in Jif, subject to the following restrictions.
</p>

<ol>
<li>If a static field has an initializing
expression, the expression must contain only constant values. Without
this restriction, the initializing expression could be used to convey
information about when the class is loaded (e.g., by calling a
method), which may depend on sensitive information.</li>
<li>The label of a static field cannot mention <code>this</code> (as the expression <code>this</code> is not valid in a static context).</li>
<li>The label of a static field cannot mention any class parameters (as class parameters are specific to an instance of the class).</li>
</ol>
</p>

<h4><a name="runtime-exceptions"></a>Runtime exceptions</h4>

<p>In Java, subclasses of <code>RuntimeException</code> (such as
<code>NullPointerException</code>, <code>ClassCastException</code>,
and <code>ArrayIndexOutOfBoundsException</code>) are <i>unchecked</i>;
they may be thrown by a method without being declared in the
<code>throws</code> clause of the method signature. Unchecked
exceptions can serve as covert channels. To prevent this covert
channel, Jif requires subclasses of
<code>RuntimeException</code> to be checked.

To reduce the additional programming burden of handling runtime
exceptions, this version of Jif has a simple not-null analysis, which
tracks whether local variables and final fields of the
<code>this</code> object are definitely not-null. Thus, in the following 
example, the method <code>m(Object, String)</code> cannot throw a
<code>NullPointerException</code>, and does not need to declare that it does.

<div class="code"><pre>
class C {
    final String{} f = "a string";
    C another;
    
    void m(Object{} o, String{} s) {
        if (s != null) {
            return;
        }
        s.length(); <span class="comment">// OK, s known to be not-null</span>
        if (o instanceof String) {
            try { 
                ((String)o).length();
		    <span class="comment">// OK, if instanceof succeeds, o is not-null</span>
            }
            catch (ClassCastException e) { 
                <span class="comment">// still need to catch the ClassCastException</span>
            }
            
        }
        if (f != null) { 
            f.length(); <span class="comment">// OK, f is final field of this.</span>
        }
        if (another.f != null) { 
            try {
                f.length(); 
            }
            catch (NullPointerException e) { 
		<span class="comment">// still need to catch the NPE, as we cannot reason
                // about fields of objects other than this.</span>
            }
        }
    }
}
</pre></div>

<h4><a name="constructors">Final field initialization</a></h4> 

<p>
In Java, it is possible to observe final fields of an object before
they have been initialized. This is not acceptable in Jif,
where final fields of type <code>label</code> or
<code>principal</code> may define the security requirements
for other information. To ensure that final fields really
are final, Jif constructors are required to initialize all
final fields explicitly before the call to the superclass
constructor. For example, a constructor might look like the
following:
</p>

<div class="code"><pre>
class B extends A {
    final principal p;
    String {p:} name;
    B(principal{} q, String{q:} n) {
	p = q;
	super(n);
	name = n;
    }
}
</pre></div>

<p class="cont">The assignment to the field <code>p</code> must occur
before the call to <code>super</code>. In fact, in Java no code may
precede the call to <code>super</code>.
</p>

<p>
Note that this example has an assignment from <code>n</code> (with label 
<code>{q:}</code>) to the field <code>name</code> (with label 
<code>{p:}</code>). The assignment is permitted because
the Jif compiler knows from the assignment <code>p=q</code> that these
principals are equal. It uses this fact to determine that
the assignment from <code>n</code> to <code>name</code> is
secure. In general, the Jif compiler can perform this kind of 
reasoning only for final fields of type <code>label</code> or 
<code>principal</code> that are initialized in a constructor, and 
for final local variables of type <code>label</code> or 
<code>principal</code> with an initializing expression.
</p>

<h4><a name="unsupported-java">Unsupported Java features</a></h4> 

Jif does not currently support nested classes,
initializer blocks, or threads.


<h2><a name="java">Interacting with Java</a></h2>

<h3><a name="main"></a>The <code>main</code> method</h3>

<p>Jif provides two possible signatures for the main method of a
class. The first is compatible with the signature for Java main
methods, and accepts a single argument of an array of String, that is,
<div class="code"><pre>
public static void main(String[] args) { ... }
</pre></div>


<p>The second signature takes two arguments, the first a principal, and
the second an array of String:

<div class="code"><pre>
public static void main(principal p, String[] args) { ... }
</pre></div>


<p>The principal <code>p</code> is the principal representing the current user that invoked the <code>main</code>. The signature
may optionally have the authority of the current user:

<div class="code"><pre>
public static void main(principal p, String[] args) where caller(p)
{
    ...
}
</pre></div>

A class may have at most one static method named <code>main</code>.

<h3><a name="java-classes"></a>Interacting with Java classes</h3>

<p>The Jif compiler provides a mechanism to allow Jif code to be compiled
against and linked to existing Java classes. However, appropriate Jif
signatures must be supplied for the Java classes. <b>NOTE:</b> the Jif compiler
does not verify that the Java code conforms to these provided
signatures.

<p>
Suppose that you have an existing Java class, called <code>Foo</code>,
i.e. you have a file <code>Foo.java</code>, and a file
<code>Foo.class</code> that was produced by compiling
<code>Foo.java</code>. Furthermore, suppose you want to use the class
Foo in some Jif code you are writing. You can do this by supplying a
Jif signature for the class <code>Foo</code>; at compile time, your Jif code will
be compiled against the signature you provide, but at runtime the
original <code>Foo.class</code> will be loaded. The steps for doing this are as
follows:

<ol>
<li> In a file <code>Foo.jif</code> write an appropriate Jif signature for the
   methods and fields in the class Foo.  Take a look at
   $JIF/sig-src/java/lang/*.jif for some examples of this.

   <p>Note the use of the <code>native</code> flag to avoid the need to provide a
   body for the methods. Note also that there is a <code>private static int</code>
   field named <code>__JIF_SIG_OF_JAVA_CLASS$20030619</code>; this is a hack to
   let the Jif compiler to know that the class provides a Jif
   signature for an existing Java class.
</li>

<li> Compile <code>Foo.jif</code> to produce the file <code>Foo.class</code>
</li>

<li> Make sure that the <code>Foo.class</code> you created in step 2 is on the
   signature classpath. Do this either by dropping the class file into
   the $JIF/sig-classes directory, or by specifying the directory with
   the <code>-sigcp</code> flag to the Jif compiler. (If you use the <code>-sigcp</code>
   flag you will probably also need to explicitly add the
   $JIF/sig-classes directory to the signature classpath, e.g. use
   <code>-sigcp my-sig-classes:$JIF/sig-classes</code>)
</li>

<li> Compile your Jif code that uses the class Foo. The Jif compiler
   will use the signature you created in step 1 to compile your code
   against.
</li>

<li> Make sure that the original <code>Foo.class</code> is on the classpath, but
   that the <code>Foo.class</code> you created in step 2 is not. Now, when you
   run your Jif compiled code, the original <code>Foo.class</code> will be loaded
   by the classloader.
</li>
</ol>

<h2><a name="debugging"></a>Debugging Jif Programs</h2> 

<p>Tracking down and correcting compilation errors in Jif code can be
difficult. While there is not as yet a debugger specifically for the
Jif language, the Jif compiler has a number of reporting options that
will result in additional information being displayed.


<h3><a name="explain"></a>Constraint explanations</h3>

<p>The <code>-explain</code> or <code>-e</code> flag of the Jif compiler can be used to view
more information about failed label checking. For example, consider
the program, in which there is a potential implicit information flow
from the high security argument <code>h</code>, whose label is the dynamic label
<code>lbl</code>, to the low security local variable <code>l</code>:

<div class="code"><pre>
class Implicit {
    void m(boolean{*lbl} h, label{} lbl) {
        if (lbl <= new label {Alice:}) {
            boolean{} l = false;
            if (h) {
                l = true;
            }
        }
    }
}
</pre></div>

Trying to compile this program produces the following output:

<div class="code"><pre>
$ $JIF/bin/jifc Implicit.jif
Implicit.jif:6: Label of right hand side not less restrictive
    than the label for local variable l
                l = true;
                ^

1 error.
</pre></div>

<p>More information can be gleaned by using the <code>-explain</code> flag:

<div class="code"><pre>
$ $JIF/bin/jifc Implicit.jif -explain
Implicit.jif:6: Unsatisfiable constraint:
     rhs.nv <= label of var l
        {h} <= {lbl}
     in environment
     [{*lbl} <= {Alice: }]

     Label Descriptions
     ------------------
     - rhs.nv = label of successful evaluation of right hand of assignment
     - rhs.nv = {h}
     - label of var l = {lbl}

     More information is revealed by the successful evaluation of the right
    hand side of the assignment than is allowed to flow to the local variable
    l.
                l = true;
                ^

1 error.
</pre></div>

<p>The more detailed error message first shows what the symbolic
unsatisfiable constraint is (<code>rhs.nv <= label of var l</code>),
and then shows the same constraints with the actual labels substituted
for the symbols (<code>{h} <= {lbl}</code>). The label environment in
which the constraint must be satisfied is also shown. Here, the
environment indicates that the value held in the label variable
<code>lbl</code> is bounded above by the label
<code>{Alice:}</code>. Brief descriptions of the labels that appear in
the unsatisfiable constraint are also shown. Here, we see that
<code>rhs.nv</code> represents the label of the information that may
be acquired by knowing the <em>v</em>alue of the successful
(<em>n</em>ormal) evaluation of the <em>r</em>ight <em>h</em>and
<em>s</em>ide of the assignment; for this assignment, that label is
<code>{h}</code>, the label of the actual argument <code>h</code>.


<h3><a name="report"></a>Detailed reporting</h3>

<p>Sometimes the additional information provided by the <code>-explain</code> option
is not sufficient to determine why a Jif program fails to
compile. There are two additional useful ways to gain more information
about the label checking process: reporting the topics <code>debug</code> and
<code>solver</code>.

Specifying the command line option <code>-report debug=n</code>, where <code>n</code> is a
non-negative integer, will display more information about labels. The
higher the value for <code>n</code>, the more information is displayed. For
example:
<div class="code"><pre>
$ $JIF/bin/jifc Implicit.jif -report debug=1 -explain
Implicit.jif:6: Unsatisfiable constraint:
     rhs.nv <= label of var l
        {&lt;arg h {&lt;dynamic lbl>}>} <= {&lt;arg lbl {}>}
     in environment
     [{&lt;dynamic lbl>} <= {&lt;pr-external Alice>: }]

     Label Descriptions
     ------------------
     - rhs.nv = label of successful evaluation of right hand of assignment
     - rhs.nv = {&lt;arg h {&lt;dynamic lbl>}>}
     - label of var l = {&lt;arg lbl {}>}

     More information is revealed by the successful evaluation of the right
    hand side of the assignment than is allowed to flow to the local variable
    l.
                l = true;
                ^

1 error.
</pre></div>


<p>In the environment, we see that the label of the actual argument
for <code>h</code> is displayed as <code>&lt;arg h {&lt;dynamic
lbl&gt;}&gt;</code>. That is, we see that the label is the argument
label for the argument <code>h</code>, and that this arg-label is
bounded above by the label <code>&lt;dynamic lbl&gt;</code>, that is by the dynamic label 
<code>lbl</code>.

<p>The arg-label for <code>h</code> would normally be displayed simply
as <code>h</code>, and the dynamic label <code>lbl</code> would normal
be displayed as <code>*lbl</code>. But with the <code>debug</code>
topic reporting at level 1, we see more detail about the labels, which
can be helpful to determine what reasoning the compiler is
performing. Setting the report level higher reveals even more
information.

<p>Thus, reporting the debug topic provides more information about
the labels and their meaning, but a less readable display.


<p>Specifying the command line option <code>-report solver=n</code>, for a
nonnegative n, will display more information about the constraint
solver, which attempts to solve the system of constraints generated by
label checking. The higher the value for n, the more information is
displayed.

<p>When the constraint solver is unable to solve a system of constraints,
it attempts to find the most appropriate constraint to "blame": this
is the constraint that is displayed in the error message. However,
sometimes this constraint is not the real culprit, and one or more
other constraints are really preventing successful
compilation. Enabling reporting for the solver allows the user to
determine which constraint(s) are problematic, when the error message
does not appear to be helpful.

<h2><a name="runtime-interface">Jif Runtime Interface</a></h2>


<p>To interact with the external environment, Jif provides a runtime
interface to allow Jif code to read and write files, and access stdin,
stdout and stderr, and also to obtain a principal representing the current user. The runtime interface is <code>jif.runtime.Runtime</code>.
</p>

<p>Although
the runtime code is itself is written in Java (see $JIF/rt-src/jif/runtime/Runtime.java), a Jif signature is
provided to allow calls to this interface can be checked
statically (see $JIF/sig-src/jif/runtime/Runtime.jif). 
</p>
</body>

</html>

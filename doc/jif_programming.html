<html>

<head>
<link rel=StyleSheet href="jifdoc.css" type="text/css">
<title>Programming in Jif</title>
</head>

<body>

<h1>Programming in Jif</h1>

<p>
Jif is an extension to the Java programming language that supports
static analysis of information flow. This support consists primarily
of extensions to the type system.  Static checking of information flow
in Jif programs is performed as part of type checking. If a Jif program
type-checks, the compiler translates it into Java code that can be
compiled with a standard Java compiler. The Jif compiler and run-time
system are available from the
<a href="http://www.cs.cornell.edu/jif">Jif web site</a>.
</p>

<p>
The primary difference between Jif and Java is the addition of
<em>labels</em> that capture restrictions on how information may
be used. The primary goal is to prevent confidential information
from being used improperly; in some versions of Jif, the goal is
also to protect the integrity of trusted information.
</p>

<p>
The core mechanism for security enforcement in Jif is
statically tracking information flow.  This
analysis of information flow is performed mostly statically, at
compile time. However, Jif does also support some forms of
run-time security enforcement.
</p>

<p>
Jif has a number of unique features that are important for
building interesting programs in a security-typed language:

<ul>
<li>A <strong>declassification</strong> mechanism gives the programmer
an explicit escape hatch for releasing information when that is necessary.
<li><strong>Principals</strong>, the entities that have security requirements,
are explicitly represented in the Jif language, 
    both as type annotations and as values that can be manipulated at
    run time. A new feature of Jif 2.0.0 is the ability to create
    <strong>user-defined principals</strong>, so that programs can define
    their own authentication and authorization procedures.
<li><strong>Statically checked access control</strong> makes it possible
    to write complex authorization code without
    creating covert information leaks.
<li>A <strong>principal hierarchy</strong> allows policies to be stated
    in a general way in terms of more abstract principals.
<li><strong>Label polymorphism</strong> allows the expression of code 
that is generic with respect to the security class of the data it manipulates.
<li><strong>Automatic label inference</strong>
makes it unnecessary to write many type annotations.
<li><strong>Run-time label checking and first-class label values</strong>
makes it possible to discover and to define new policies at run time. Run-time
checks are statically checked to ensure that information is not leaked by
the success or failure of the run-time check itself.  Jif 2.0.0 significantly
improves the expressive power of this important language feature.
</ul>

<p>
Jif is not completely a superset of Java. Certain features have
been omitted to make information flow control tractable. Also, Jif
does not eliminate all possible information leaks. Certain covert
channels (particularly, various kinds of <em>timing channels</em>).
These limitations of Jif are discussed later.
</p>

<h2><a name="language-features"></a>Language Features</h2> 

<h3>Labels and labeled types</h3>

<p>
In Jif, every value has a <em>labeled type</em> that consists of two parts:
an ordinary Java type such as <code>int</code>,
and a <em>label</em> that describes how
the information can be used.
Any type expression <i class="math">t</i>
may be labeled with any label expression <i class="math">l</i>.
This labeled type expression is written <code><i class="math">t</i>{<i class="math">l</i>}</code>; for example, the
labeled type <code>int{p:}</code> represents an integer that principal <code>p</code> owns
and, because no readers are listed, that only <code>p</code> can read.
For example, a variable may be declared with labeled type: 
<div class="code"><pre>
int{p:} x = 2;
</pre></div>
</p>

<p>
In a Jif program,
a label is written as a set of <em>policy expressions</em>,
separated by semicolons. For example,
the label expression
<code>{o<sub>1</sub>: r<sub>1</sub>,r<sub>2</sub>; o<sub>2</sub>: r<sub>2</sub>,r<sub>3</sub>}</code> contains two policy expressions.
A policy expression <code><i class="math">owner</i>:
<i class="math">reader</i><sub>1</sub>,
<i class="math">reader</i><sub>2</sub>, ...</code>
means that the
principal <code><i>owner</i></code> wants to allow the labeled
information to flow to at most the principals
<code><i>reader<sub>i</sub></i></code>. Labels built from these
policies are called <em>decentralized labels</em> because they
enforce security on behalf of the owning principals, not on
behalf of an implicitly centralized policy specifier.
</p>
<p>
The compiler permits information to flow between locations
with different labels only if that information flow does not
lose policy restrictions.
In particular, if information is
able to flow from a location with label <code>L<sub>1</sub></code>
to a location with label <code>L<sub>2</sub></code>, the
label <code>L<sub>2</sub></code> must be more restrictive
than <code>L<sub>1</sub></code>, or equally restrictive.
</p>
<p>
When differently labeled inputs are
combined, the result may reveal information about
any of the inputs. For example, when two variables
<code>x</code> and <code>y</code> are added, the sum
<code>x+y</code> may reveal information about both
<code>x</code> and <code>y</code>.  Conservatively,
the label of the result is the union of the policies
in the labels of the inputs. This union is the
<em>join</em> or <em>least upper bound</em>
of the input labels. For example, if the label of
<code>x</code> is <code>{p:q}</code> and the label of
<code>y</code> is <code>{a:b; p:q,r}</code>, the
label of the result is <code>{p:q; a:b; p:q,r}</code>,
which is equivalent to <code>{p:q; a:b}</code>.
</p>
<p>
In a program, a policy component of a label
may take a few additional forms. One such
form is a variable name, which denotes the set of policies
in the label of the variable named.  For example, 
the label expression <code>{a}</code> contains a single component expression;
this label means that value it labels should be as restricted as the
contents of <code>a</code> are. The
label expression <code>{a; o: r}</code> contains two policy components,
indicating
that the labeled value should be as restricted as <code>a</code> is, and also that
the principal <code>o</code> restricts the value to be read by at most
the principal <code>r</code>.
Other kinds of label components will be introduced later.
</p>

<p>
A labeled type may occur in a Jif program almost anywhere a type
may occur in a Java program. In fact, if the label is omitted from a type,
the Jif compiler automatically generates a label for that type according
to rules that are discussed later.
</p>

<p>
The type and label parts of a labeled type act largely independently.
The notation <i class="math">S &le; T</i> is used here to mean
that the type <i class="math">S</i> is a subtype of the type
<i class="math">T</i>. The intuitive
behavior of subtyping is that it operates independently on the type
and label: for any two types <i class="math">S</i> and <i
class="math">T</i> and labels <i
class="math">L</i><sub>1</sub> and <i
class="math">L</i><sub>2</sub>,
<i class="math">S &le; T and L<sub>1</sub> &sqle;
L<sub>2</sub></i> iff
<i class="math">S{L<sub>1</sub>} &le; T{L<sub>2</sub>}</i> (as in
[VSI96])
</p>

<h3><a name="principal-hierarchy"></a>Principals</h3>

<p>
In the decentralized label model implemented by Jif,
information is owned by, updated by,
and released to <em>principals</em>: users and other
authority entities such as groups or roles.  For example, both users and
groups in Unix would be modeled as principals.
</p>

<p>
Some principals may be authorized to <em>act for</em>
other principals. If the principal <code>p</code> acts for the
principal <code>q</code>, any action taken by <code>p</code>
is implicitly assumed to be authorized by <code>q</code>
The acts-for relation is reflexive and transitive,
defining a hierarchy or partial order
of principals. This relation is similar to the <em>speaks for</em>
relation used in various authentication logics (e.g., [LABW91]);
the hierarchy of principals is also similar to a <em>role hierarchy</em>
[RBAC].
</p>

<p>
The acts-for relation can be used to model groups and
roles conveniently. A group principal, such as <code>students</code>,
is modeled by authorizing all of the principals
representing members of the group
to act for the group principal. That is, the group principal delegates
its authority to all of the group members.  A
role, a restricted form of a user's authority, is modeled by
authorizing the user's principal to act for the role principal.
</p>

<p>
The acts-for relationship between two principals can be tested
in a Jif program using the built-in <code>actsfor</code> operator. The
boolean expression <code>p actsfor q</code> evaluates to <code>true</code>
if the
specified relationship exists. Within the body of an <code>if</code>
statement conditioned on this test, the compiler makes use of
the knowledge that the relationship exists when checking
information flows and comparing security policies.
</p>

<h3><a name="access-control"></a>Access control</h3>

<p>
A method executes with some
<em>authority</em> that has been granted to it. The authority is essentially the
capability to act for some set of principals, and
controls the ability to declassify data. This simple authority mechanism
can be used to build more complex access control mechanisms.
It is also useful for releasing information.
</p>

<p>
At any given point within a program, the compiler understands the
code to be running with the ability to act for some set of
principals; the static authority of the code at that point. The actual
authority may be greater, because the known principals may be able to act
for other principals. The static authority can never exceed the actual
authority unless revocation occurs while the program is running.
</p>

<p>
The static checker maintains a notion of the <em>static principal
hierarchy</em> at every point in the program. The static principal hierarchy
is a set of acts-for relations that are known to exist. The static
principal hierarchy is a subset of the acts-for relations that exist in
the true principal hierarchy.
The static authority of a method may be augmented by testing the
principal hierarchy dynamically, using the
<code>actsfor</code> test.
</p>

<p>
There are two ways for method code to acquire authority. First, the
class containing the code may declare that it has the
authority of some principal using an <code>authority</code>
clause. A method of the class can then claim and use that 
authority if its signature includes a <code>where authority</code>
clause of its own. It is easy to identify the code to which
principal <code>p</code> has directly granted its authority
because of these clauses. For example, in the following code
the class <code>Game</code> has the authority of the
principal <code>referee</code>:
</p>

<div class="code"><pre>class Game authority(referee) {
    void start() where authority(referee) {
	...
    }
}
</div>
 
<p>
The second way for a method to acquire authority is for the
method to receive authority passed from another method. If the
receiving method signature contains a clause of the form
<code>where caller(p)</code>, then it can be called only
from code that is statically known to have the authority of
principal <code>p</code>. For example, the following method
receives authority for a principal <code>p</code> that is
determined at run time and passed as an argument to the
method.
</p>

<div class="code"><pre>
    void m(principal p) where caller(p) {
	...
    }
}
</pre>
</div>

<p>
These mechanisms can be used to implement access control
security within a program and are similar in expressiveness
to the Java stack inspection mechanism, while avoiding the
run-time overhead. Of course, Jif
offers more security assurance than stack inspection because
it also controls information flow.
</p>

<h3>Implicit flows and program-counter labels</h3>

<p>
The label of an expression's value varies depending
on the evaluation context.
This is needed to prevent leaks through
<em>implicit flows</em>: channels created by the control flow structure
itself.
To prevent information leaks through implicit flows, the compiler
associates a <em>program-counter label</em> (<u>pc</u>)
with every statement and expression,
representing the information that might be learned from
the knowledge that the statement or expression was evaluated.

<p>
For example, consider the following program, which is obviously
equivalent to the statement <code>l = h</code>:
<div class="code"><pre>
boolean l = false;
if (h) {
    
}
</div>
</p>

<p class="cont">
If <code>l</code> contains public (low) information and <code>h</code>
contains secret (high) information, this program is not secure.
The solution is that by conditioning on the variable <code>h</code>,
the <code>if</code> statement makes the <u>pc</u> of the assignment
to <code>l</code> at least as restrictive as <code>{h}</code>.
Assume no information can be learned from the fact that the
program is executed (that is, initially <u>pc</u>&nbsp;=&nbsp;<code>{}</code>).
In this case, the value of <u>pc</u> during the consequent clause is
<code>{h}</code>.
After the <code>if</code> statement, it is again true that <u>pc</u> = <code>{}</code>,
because no information
about <code>h</code> can be deduced from the fact that the statement after the <code>if</code>
statement is executed. (It is not true in general that the value of <u>pc</u>
reverts after <code>if</code> statements,
but is true here because this <code>if</code> statement always terminates
without exceptions.)
The label of a literal expression (e.g., <code>true</code>) is the same as its <u>pc</u>, or <code>{h}</code>
in this case.
So the assignment is permitted only if the label <code>{l}</code> is
at least as restrictive as the label <code>{h}</code>. This would not be
true if <code>l</code> were public and <code>h</code> secret.
</p>

<p>
One way to think about the program-counter label is that
there is a distinct <u>pc</u> for every basic block in the program.
In general, the flow of control within a program depends on the values of
certain expressions. At any given point during execution, various values
<i class="math">v<sub>i</sub></i> have been observed in order to decide to arrive at the
current basic block; therefore, the labels of these values affect the
current <u>pc</u>. The Jif type system will ensure that the <u>pc</u>
label is at least as restrictive as the labels of all the variables on
which the program counter depends.
</p>

<p>
A related issue is the transmission of information through
the termination or non-termination of a program.
Consider the execution of a <code>while</code> statement:
According to the Jif type system,
after the statement terminates, <u>pc</u>=<code>{}</code>, using the
same reasoning as for the <code>if</code> statement. This
labeling might seem strange, because we
know the value of <code>h</code> when we arrive at the final basic block.
However, arriving at the final block gives no
information about the value of <code>h</code> before the code started.
Therefore, 
Jif does not attempt to control information transfers through
termination channels. It also ignores timing channels, which are
an issue for concurrent programming languages. Jif does not support
the Java thread model for concurrent programming.
</p>



<h3><a name="dynamic-labels"></a>Dynamic labels and principals</h3>

<p>
Labels and principals are first-class values, and are represented at
runtime. These &ldquo;dynamic&rdquo; labels and principals can be used in the
specification of other labels, and used as the parameters of <a
href="parameterized-classes">parameterized classes</a>. (Thus, Jif's
type system uses dependent types.) Consider the following example.
</p>

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
class C[label L] { ... }

...

void m() {
    final label lb = new label {Alice: Bob};

    int{*lb; Bob:} x = 4;

    C[lb] foo = null;
    C[{*lb}] bar = foo;
}
</pre>
</div></td></tr></table>

<p>Here we see a local variable <code>lb</code>, of type
<code>label</code>. At runtime, this variable will contain a
representation of the label <code>{Alice: Bob}</code>. The type of the
variable <code>x</code> is declared to be <code>int{*lb; Bob:}</code>,
that is, an integer whose label the policy <code>{Bob:}</code> joined
with the <i>value</i> stored in the variable <code>lb</code>. This is
an example of a dynamic label being used in another label.

<p>The variable <code>foo</code> is of type <code>C[lb]</code>, that
is, its type is the class <code>C</code> instantiated with the label
that is stored in the variable <code>lb</code>. This type is
equivalent to the type <code>C[{*lb}]</code>, since the label stored
in the variable <code>lb</code> is equivalent to the label <code>{*lb}</code>.

<p>Jif's allows more than just local variables of type
<code>label</code> and <code>principal</code> to be used to construct
new labels and types. in fact, any <i>final access path</i> expression
may be used. A final access path expression is an expression of the
form <i>r.f<sub>1</sub>.f<sub>2</sub>. ... .f<sub>n</sub></i>, where <i>r</i> is either a final local
variable, or the expression <code>this</code>, and each
<i>f<sub>i</sub></i> is an access to a final field. Thus, the following are all examples of legal uses of dynamic labels.

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
class C[label L, principal P] {
    final label lb;    
    final principal q;
    final C[lb, Alice] next;

    public C() { ... }

    void m(principal pp) throws NullPointerException {
        final C[this.next.lb, pp] foo = new C[this.next.lb, pp]();
        C[{Alice: foo.q}, P] quux = null;

        int{foo.next.q: ; *this.lb} x = 8;        
    }
}
</pre>
</div></td></tr></table>

<p>Final access paths appearing in labels and types may act as covert
channels. For example, an access path may throw a null pointer
exception, or the value stored in a particular variable may reveal
sensitive information. The Jif type system must account for the
information that may be revealed whenever a final access path in a label
or type is evaluated at runtime. Final access paths occurring in a
label may be evaluated at runtime when a <code>new label</code>
expression is evaluated; final access paths occurring in a type may be
evaluated at runtime during the evaluation of casts to a parameterized
type, <code>instanceof</code> checks against a parameterized type,
construction of a new object of parameterized type, or a call to a
static method of a parameterized type.

<p>In the following example, an <code>instanceof</code> check is
performed against a parameterized type,
<code>C[{this.f.p:}]</code>. The evaluation of this expression
requires the evaluation of the access path expression
<code>this.f.p</code>, which may throw a
<code>NullPointerException</code> if <code>this.f</code> is
null. Thus, whether or not a <code>NullPointerException</code> is
thrown may reveal information at level <code>{this;
Alice:}</code> (which is the label of the expression <code>this.f</code>). 
Thus, if the assignment to the local variable
<code>x</code> occurs, information with the label <code>{this;
Alice:}</code> is flowing, and thus the label of the variable
<code>x</code> must be at least <code>{this; Alice:}</code>.

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
class C[label L] { ... } 

class D { 
    final D{Alice:} f; 
    final principal{} p;

    ...

    void m(Object{} o) {
        try {
            boolean{Alice:; this} x = (o instanceof C[{this.f.p:}]);
        }
        catch (NullPointerException e) {
	    // may be thrown by the evaluation of "this.f.p"
	} 
    }
}
</pre>
</div></td></tr></table>


<h3><a name="parameterized-classes"></a>Parameterized classes</h3> 

<p>A parameterized class is generic with respect to some set of type
parameters. Jif allows classes to be parameterized on labels and
principals. The key difference between parameterized classes in this
version of Jif, and as described in Andrew Myers' thesis, is that
class parameters are represented at runtime. Thus, the following code,
which uses the parameters <code>L</code> and <code>P</code> at runtime, 
is permitted.  

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
class C[label L, principal P] {
    private final label{this} lb = L;         // runtime use of L

    private void m() {
        label foo = new label {L; Alice:};    // runtime use of L
        principal bar = P;                    // runtime use of P
    }
}
</pre>
</div></td></tr></table>


<p>Note that the label of a parameter is the label
<code>{this}</code>. That is, the information that may be conveyed by
knowing the runtime value of a parameter is the same as the
information that may be conveyed by the reference to this
object. Thus, if the label of the final field <code>lb</code> in the
example above was not at least as restrictive as the label
<code>{this}</code>, the example would not compile.

<h3><a name="method-polymorphism"></a>Method polymorphism</h3>

<p>Methods in Jif are parametric in the labels of the arguments. This
facilitates reuse of methods. For example, in the following method
signature, the method <code>m</code> returns a <code>String</code> whose
label is the same as the label of the argument <code>a</code>.

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
String{a} m(int{Alice: ; Bob:} a);
</pre></div></td></tr></table>
 

<p>The label on the declaration of the argument <code>a</code> is
<code>{Alice: ; Bob:}</code>. This means that the label of any actual
argument given to <code>m</code> can be <i>at most</i> as restrictive
as <code>{Alice: ; Bob:}</code>, that is, <code>{Alice: ; Bob:}</code> is an
upper bound on the label of any actual argument to <code>m</code>. The
following code that calls the method <code>m</code> compiles
successfully.
<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
int{Alice: Chuck} i = 42;
String{Alice: Chuck} s = m(i); // OK, since m returns a String with the same label as i
</pre></div></td></tr></table>
 

<p>In the body of the method <code>m</code>, all that is known about
the label of the formal argument <code>a</code> is that <code>{Alice:
; Bob:}</code> is an upper bound for it. Thus, the first line of the method body below is illegal, while the second is legal.

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
String{a} m(int{Alice: ; Bob:} a) {
    int{Alice:} i = a; // ILLEGAL! Don't know that {a} <= {Alice:}
    int{Alice: ; Bob: ; Chuck: } j = a; // OK
    ...
}
</pre></div></td></tr></table>
 

<p>The labels of arguments given to a method are not represented at
runtime. That is, within a method body, there is no runtime
representation of labels of the arguments. The following code is thus illegal.

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
void foo(int{Bob:} a) {
    label lb = new label {Alice: ; a}; // ILLEGAL! Label of a is not runtime representable.

    if (new label {a} <= new label {Bob: Chuck}) { // ILLEGAL! Label of a is not runtime representable.
    }
    ....
}
</pre></div></td></tr></table>
 

<p>If no label is specified for a formal argument, then it is assumed
that there are no restrictions on the labels of the actual arguments
that may be passed in. See the section on <a
href="#default-labels">default labels</a>.

<h3><a name="runtime-tests"></a>Runtime tests of labels and principals</h3>

<p>Jif provides a mechanism for comparing runtime labels, and also a
mechanism for comparing runtime principals. Both mechanisms use a
syntax similar to that of if statements.

<p>An <i>if-label</i> statement allows the runtime comparison of labels. It has the following form: 
<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
if (L1 <= L2) { 
    ... 
} 
else { 
    ... 
}
</pre></div></td></tr></table>
 

<p>If the label <code>L2</code> is at least as restrictive as
the label <code>L1</code>, then the code in the <code>then</code>
branch is executed; otherwise, the code in the <code>else</code>
branch is executed. The <code>else</code> branch is
optional. During the label checking of the  <code>then</code>
branch, it is assumed that the label <code>L2</code> is indeed at least as restrictive as
the label <code>L1</code>. Thus, the following code compiles correctly.

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
void m(int{*lbl} i, label{} lbl) {
    int{Alice:} x;
    if (lbl <= new label {Alice:}) {
        x = i; // OK, since {*lb} <= {Alice:}
    }
    else {
        x = 0;
    }
}
</pre></div></td></tr></table>


Note that this construct replaces the <code>switch-label</code> construct that existed in previous versions of Jif.


<p>An <i>actsfor</i> statement allows the runtime comparison of principals. It has the following form: 
<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
if (P1 actsfor P2) { 
    ... 
} 
else { 
    ... 
}
</pre></div></td></tr></table>
 

<p>If the principal <code>P1</code> can act for the principal
<code>P2</code>, then the code in the <code>then</code> branch is
executed; otherwise, the code in the <code>else</code> branch is
executed. The <code>else</code> branch is optional. During the label
checking of the <code>then</code> branch, it is assumed that the
principal <code>P1</code> can act for the principal
<code>P2</code>. Thus, the following code compiles correctly.

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
void m(int{Alice: pr} i, principal{} pr) {
    int{Alice: Bob} x;
    if (Bob actsfor pr) {
        x = i; // OK, since {Alice: pr} <= {Alice: Bob}
    }
    else {
        x = 0;
    }
}
</pre></div></td></tr></table>


Note that this construct replaces the <code>actsfor { ... } else { ... }</code> construct that existed in previous versions of Jif.

<h3><a name="static-fields"></a>Static fields</h3>

<p>Static fields of classes are supported in Jif, subject to the following restrictions.
</p>

<ol>
<li>If a static field has an initializing
expression, the expression must contain only constant values. Without
this restriction, the initializing expression could be used to convey
information about when the class is loaded (e.g., by calling a
method), which may depend on sensitive information.</li>
<li>The label of a static field cannot mention <code>this</code> (as the expression <code>this</code> is not valid in a static context).</li>
<li>The label of a static field cannot mention any class parameters (as class parameters are specific to an instance of the class).</li>
</ol>
</p>

<h3><a name="runtime-exceptions"></a>Runtime exceptions</h3>

<p>In Java, subclasses of <code>RuntimeException</code> (such as
<code>NullPointerException</code>, <code>ClassCastException</code>,
and <code>ArrayIndexOutOfBoundsException</code>) are <i>unchecked</i>;
they may be thrown by a method without being declared in the
<code>throws</code> clause of the method signature. Unchecked
exceptions can serve as covert channels. To prevent this covert
channel, Jif requires subclasses of
<code>RuntimeException</code> to be checked.

To reduce the additional programming burden of handling runtime
exceptions, this version of Jif has a simple not-null analysis, which
tracks whether local variables and final fields of the
<code>this</code> object are definitely null. Thus, in the following example, the method <code>m(Object, String)</code> cannot throw a
<code>NullPointerException</code>, and does not need to declare that it does.

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
class C {
    final String{} f = "a string";
    C another;
    
    void m(Object{} o, String{} s) {
        if (s != null) {
            return;
        }
        s.length(); // OK, s known to be not-null
        if (o instanceof String) {
            try { 
                ((String)o).length();
		    <span class="comment">// OK, if instanceof succeeds, o is not-null</span>
            }
            catch (ClassCastException e) { 
                // still need to catch the ClassCastException
            }
            
        }
        if (f != null) { 
            f.length(); // OK, f is final field of this.
        }
        if (another.f != null) { 
            try {
                f.length(); 
            }
            catch (NullPointerException e) { 
                // still need to catch the NPE, as we cannot reason about 
                // fields of objects other than this.  
            }
        }
    }
}
</pre></div></td></tr></table>
 

<h3><a name="user-defined-principals"></a>User-defined principals</h3>

<p>Jif provides an open-ended mechanism to allow applications written in
Jif to define their own principals. The Jif interface <a
href="rt-api/jif/lang/Principal.html"><code>jif.lang.Principal</code></a>
is used to represent principals, and Jif programs may implement this
interface to define their own principals.

<p>Objects of type <code>jif.lang.Principal</code> can be implicitly
cast to the type <code>principal</code>, and vice-versa.

<p>The interface <code>jif.lang.Principal</code> is defined below.

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
public interface Principal {
    String{this} name();
    boolean{this;p} delegatesTo(principal p);
    boolean{this;p} equals(Principal p);
    boolean{authPrf; closure; lb; this} isAuthorized(Object authPrf, 
                                                     Closure[this, lb] closure,
                                                     label lb) where authority (this);

    Principal{this;p}[]{this;p} findChainUpto{p;this}(Principal p);
    Principal{this;q}[]{this;q} findChainDownto{q;this}(Principal q);
}
</pre></div></td></tr></table>

<p>The method <code>name()</code> returns the name of the
principal. The <code>equals(Principal p)</code> method is used to
determine if the receiver object is the same as the principal p; two
principals <code>p</code> and <code>q</code> are regarded as being
equal only if <code>p.equals(q) && q.equals(p)</code>.

<p>The method <code>delegatesTo(principal p)</code> returns true if the
principal represented by the receiver object has delegated its
authority to the principal <code>p</code> (and thus <code>p</code> can
act for the principal represented by the receiver object).

<p>The methods <code>findChainUpto(Principal p)</code> and
<code>findChainDownto(Principal p)</code> are used to search for a
"delegates chain", a chain of principals between two principals, which
is proof that the principal at the head of the chain is able to act
for the principal at the tail of the chain.

<p>The method <code>isAuthorized(Object authPrf, Closure[this, lb]
closure, label lb)</code> is used to determine if the object
<code>authCode</code> is sufficient proof for the principal
represented by the receiver object to grant its authority to execute
the <code>Closure</code>. The form of the authorization proof will
depend on the principal implementation, but could be, for example, a
password, or a certificate, or some other capability.

<p>A <code>Closure[principal P, label L]</code> (see
$JIF/sig-src/jif/lang/Closure.java) is code that needs the authorty of
the principal P to execute, and whose side effects are bounded below
by L. To execute a closure, a <code>Capability</code> (see
$JIF/sig-src/jif/lang/Closure.java) is required. A capability can only
be obtained by calling the method
<code>jif.lang.PrincipalUtil.authorize(principal p, Object authPrf,
Closure[p, lb] c, label lb)</code>, which returns a Capability to
execute the closure if the method <code>isAuthorized(authPrf, c,
lb)</code> of the principal <code>p</code> returns true, and null
otherwise.


<p>The class <code>jif.lang.AbstractPrincipal</code> (found in the
$JIF/lib-src directory) is an abstract implementation of
<code>jif.lang.Principal</code> that many principal implementations
will find useful. The class <code>jif.lang.PrincipalUtil</code>
contains several utility methods to help in searching for
delegates-chains and also for obtaining capabilities to execute
closures.

<p>External principals (e.g., the principals Alice and
Bob mentioned in Jif code; see $JIF/tests/jif/lang/Alice.jif) are
implemented using the class <code>jif.lang.ExternalPrincipal</code>
(found in the $JIF/lib-src directory). You can create your own
external principals in a similar way. See the <a
href="../tests/README">README</a> file in $JIF/tests for more
information about creating external principals.

<h3><a name="default-labels"></a>Default labels</h3>

<p>A powerful feature of Jif is that you don't have to write down
labels of local variables. Jif compiler can figure out whether there
is a way of labeling local variables to satisfy all the label
constraints. However, most of the time you do need to write down
labels of fields and method signatures, including the begin label,
return label, result label and arguments' labels. When these labels
are missing, some conservatives rules are used to assign restrictive
default labels:</p> 

<ul> 
<li>Default field label: the bottom label, <code>{}</code>
<br>
If a field's type declaration does not include a label, then by
default its label is <code>{}</code>, which is conservative because no
confidential data can be stored in the field.
</li>

<li> Default argument label: the top label, <code>&lt;top&gt;</code>
<br>
The label on the type of a formal argument is an upper bound for
labels of actual arguments. See the section on <a
href="#method-polymorphism">polymorphic methods</a>.  
</li>


<li> Default method begin label: the top label, <code>&lt;top&gt;</code>
<br>
The method begin label is an upper bound on the PC of the caller, and
a lower bound on the side effects of method.  The default method begin
label is <code>&lt;top&gt;</code>, the most restrictive label, meaning
that the method has no side effects.
</li>

<li>Default method return label: The join of the declared labels of any exceptions declared to be thrown
<br>
The method return label (how much information may be gained by knowing
the method terminates normally) is by default the join of the declared
labels of any exceptions that the method declares that it
throws. Thus, if the method does not throw any exceptions, or if the
declared exceptions do not have any labels, the default method return
label is the bottom label, <code>{}</code>.
</li>

<li> Default method result label: the join of all the argument labels and the return label. 
<br>
The method result label (the label of the value returned by the
method) is by default the method return label joined with all of the
argument labels (<i>not</i> the upper bounds of the argument labels;
see the section on <a href="#method-polymorphism">polymorphic
methods</a>).  This is the common case, as most of the time the value
returned by a method is the result of computation on all of its
arguments.
</li>

<li> Default declared exception label: the method return label
<br>
A method may declare that it throws a certain exceptions; if an
exception is declared to be thrown, but no label is given for that
exception type, then by default it is assumed to be the same as the
method return label.
</li>
</ul>

<h2><a name="main"></a>The <code>main<code> method</h2>

<p>Jif provides two possible signatures for the main method of a
class. The first is compatible with the signature for Java main
methods, and accepts a single argument of an array of String, that is,
<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
public static void main(String[] args) { ... }
</pre></div></td></tr></table>


<p>The second signature takes two arguments, the first a principal, and
the second an array of String:

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
public static void main(principal p, String[] args) { ... }
</pre></div></td></tr></table>


<p>The principal <code>p</code> is the principal representing the current user that invoked the <code>main</code>. The signature
may optionally have the authority of the current user:

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
public static void main(principal p, String[] args) where caller(p)  { ... }
</pre></div></td></tr></table>

<h3><a name="java-classes"></a>Interacting with Java classes</h3>

<p>The Jif compiler provides a mechanism to allow Jif code to be compiled
against and linked to existing Java classes. However, appropriate Jif
signatures must be supplied for the Java classes. <b>NOTE:</b> the Jif compiler
does not verify that the Java code conforms to these provided
signatures.

<p>
Suppose that you have an existing Java class, called <code>Foo</code>,
i.e. you have a file <code>Foo.java</code>, and a file
<code>Foo.class</code> that was produced by compiling
<code>Foo.java</code>. Furthermore, suppose you want to use the class
Foo in some Jif code you are writing. You can do this by supplying a
Jif signature for the class <code>Foo</code>; at compile time, your Jif code will
be compiled against the signature you provide, but at runtime the
original <code>Foo.class</code> will be loaded. The steps for doing this are as
follows:

<ol>
<li> In a file <code>Foo.jif</code> write an appropriate Jif signature for the
   methods and fields in the class Foo.  Take a look at
   $JIF/sig-src/java/lang/*.jif for some examples of this.

   <p>Note the use of the <code>native</code> flag to avoid the need to provide a
   body for the methods. Note also that there is a <code>private static int</code>
   field named <code>__JIF_SIG_OF_JAVA_CLASS$20030619</code>; this is a hack to
   let the Jif compiler to know that the class provides a Jif
   signature for an existing Java class.
</li>

<li> Compile <code>Foo.jif</code> to produce the file <code>Foo.class</code>
</li>

<li> Make sure that the <code>Foo.class</code> you created in step 2 is on the
   signature classpath. Do this either by dropping the class file into
   the $JIF/sig-classes directory, or by specifying the directory with
   the <code>-sigcp</code> flag to the Jif compiler. (If you use the <code>-sigcp</code>
   flag you will probably also need to explicitly add the
   $JIF/sig-classes directory to the signature classpath, e.g. use
   <code>-sigcp my-sig-classes:$JIF/sig-classes</code>)
</li>

<li> Compile your Jif code that uses the class Foo. The Jif compiler
   will use the signature you created in step 1 to compile your code
   against.
</li>

<li> Make sure that the original <code>Foo.class</code> is on the classpath, but
   that the <code>Foo.class</code> you created in step 2 is not. Now, when you
   run your Jif compiled code, the original <code>Foo.class</code> will be loaded
   by the classloader.
</li>
</ol>

<h2><a name="debugging"></a>Debugging Jif Programs</h2> 

<p>Tracking down and correcting compilation errors in Jif code can be
difficult. While there is not as yet a debugger specifically for the
Jif language, the Jif compiler has a number of reporting options that
will result in additional information being displayed.


<h3><a name="explain"></a>Constraint explanations</h3>

<p>The <code>-explain</code> or <code>-e</code> flag of the Jif compiler can be used to view
more information about failed label checking. For example, consider
the program, in which there is a potential implicit information flow
from the high security argument <code>h</code>, whose label is the dynamic label
<code>lbl</code>, to the low security local variable <code>l</code>:

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
class Implicit {
    void m(boolean{*lbl} h, label{} lbl) {
        if (lbl <= new label {Alice:}) {
            boolean{} l = false;
            if (h) {
                l = true;
            }
        }
    }
}
</pre></div></td></tr></table>

Trying to compile this program produces the following output:

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
$ $JIF/bin/jifc Implicit.jif
Implicit.jif:6: Label of right hand side not less restrictive than the label
    for local variable l
                l = true;
                ^

1 error.
</pre></div></td></tr></table>

<p>More information can be gleaned by using the <code>-explain</code> flag:

<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
$ $JIF/bin/jifc Implicit.jif -explain
Implicit.jif:6: Unsatisfiable constraint:
     rhs.nv <= label of var l
        {h} <= {lbl}
     in environment
     [{*lbl} <= {Alice: }]

     Label Descriptions
     ------------------
     - rhs.nv = label of successful evaluation of right hand of assignment
     - rhs.nv = {h}
     - label of var l = {lbl}

     More information is revealed by the successful evaluation of the right
    hand side of the assignment than is allowed to flow to the local variable
    l.
                l = true;
                ^

1 error.
</pre></div></td></tr></table>

<p>The more detailed error message first shows what the symbolic
unsatisfiable constraint is (<code>rhs.nv <= label of var l</code>), and then
shows the same constraints with the actual labels substituted for the
symbols (<code>{h} <= {}</code>). The label environment in which the constraint
must be satisfied is also shown. Here, the environment indicates that
the value held in the label variable <code>lbl</code> is bounded above by the label
<code>{Alice:}</code>. Brief descriptions of the labels that appear in the
unsatisfiable constraint are also shown. Here, we see that <code>rhs.nv</code> is
the label of the information that may be acquired by the successful
evaluation of the right hand side of the assignment, and that for this
assignment, that label is <code>{h}</code>, the label of the actual argument <code>h</code>.


<h3><a name="report"></a>Reporting</h3>

<p>Sometimes the additional information provided by the <code>-explain</code> option
is not sufficient to determine why a Jif program fails to
compile. There are two additional useful ways to gain more information
about the label checking process: reporting the topics <code>debug</code> and
<code>solver</code>.

Specifying the command line option <code>-report debug=n</code>, where <code>n</code> is a
non-negative integer, will display more information about labels. The
higher the value for <code>n</code>, the more information is displayed. For
example:
<table><tr><td>&nbsp;&nbsp;&nbsp;</td><td><div class="code"><pre>
$ $JIF/bin/jifc Implicit.jif -report debug=1 -explain
Implicit.jif:6: Unsatisfiable constraint:
     rhs.nv <= label of var l
        {<arg h {<dynamic lbl>}>} <= {<arg lbl {}>}
     in environment
     [{<dynamic lbl>} <= {<pr-external Alice>: }]

     Label Descriptions
     ------------------
     - rhs.nv = label of successful evaluation of right hand of assignment
     - rhs.nv = {<arg h {<dynamic lbl>}>}
     - label of var l = {<arg lbl {}>}

     More information is revealed by the successful evaluation of the right
    hand side of the assignment than is allowed to flow to the local variable
    l.
                l = true;
                ^

1 error.
</pre></div></td></tr></table>


<p>In the environment, we see that the label of the actual argument
for <code>h</code> is displayed as <code>&lt;arg h {&lt;dynamic
lbl&gt;}&gt;</code>. That is, we see that the label is the argument
label for the argument <code>h</code>, and that this arg-label is
bounded above by the label <code>&lt;dynamic lbl&gt;</code>, that is by the dynamic label 
<code>lbl</code>.

<p>The arg-label for <code>h</code> would normally be displayed simply
as <code>h</code>, and the dynamic label <code>lbl</code> would normal
be displayed as <code>*lbl</code>. But with the <code>debug</code>
topic reporting at level 1, we see more detail about the labels, which
can be helpful to determine what reasoning the compiler is
performing. Setting the report level higher reveals even more
information.

<p>Thus, reporting the debug topic provides more information about
the labels and their meaning, but a less readable display.


<p>Specifying the command line option <code>-report solver=n</code>, for a
nonnegative n, will display more information about the constraint
solver, which attempts to solve the system of constraints generated by
label checking. The higher the value for n, the more information is
displayed.

<p>When the constraint solver is unable to solve a system of constraints,
it attempts to find the most appropriate constraint to "blame": this
is the constraint that is displayed in the error message. However,
sometimes this constraint is not the real culprit, and one or more
other constraints are really preventing successful
compilation. Enabling reporting for the solver allows the user to
determine which constraint(s) are problematic, when the error message
does not appear to be helpful.

</body>

</html>

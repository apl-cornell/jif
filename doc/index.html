<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
	"http://www.w3.org/TR/xhtm111/DTD/xhtm111.dtd">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">

<style type="text/css">
			.center_div
				{
				border:1px white;
				margin-left:auto;
				margin-right:auto;
				width:60%;
				background-color:white ;
				text-align:left;
				padding:8px;
                font-family: Arial, Helvetica, sans-serif;
				}

h1 {
    color: #6666ff;
}

h2 {
    color: #8080ff;
}

strong {
  color:#9999ff;
}
		</style>

</head>
<body>
<div class="center_div">
<h1 align="center">JRIF: Reactive Information Flow Control for Java</h1>
<hr>
<h2>Overview</h2>
<div style="text-align:justify; font-size: 12pt;">
JRIF extends Java to support RIF labels, by modifying the <a href="http://www.cs.cornell.edu/jif/">Jif</a> compiler and run time. RIF labels express changes in values' confidentiality and integrity that are instigated by applied operations. Indeed, the confidentiality and integrity of the output value of an operation depends both on the confidentiality and
 integrity of the input values, and on the applied operation. So, a RIF label that tags a particular value can specify what is the confidentiality and integrity for all possible values derived from it, depending on the operations involves in these derivations.
 For example, a RIF label that tags a vote can express that (i) initially the vote can be read only by the principal that cast this vote, (ii) but the result of the majority (which is derived based on this and other votes) can be read by all principals.
</div>
</p>
<div style="text-align:justify; font-size: 12pt;">
A RIF label consists of two RIF automata; a <i>c-automaton</i> that specifies the confidentiality policy, and an
<i>i-automaton</i> that specifies the integrity policy for a value. States of either kind of RIF automaton are mapped to sets of principals, and transitions are mapped to operations. For a c-automaton, these sets contain principals that are allowed to read
 values. For an i-automaton, these sets contain principals that should be trusted in order for values to be trusted. A visual representation of a c-automaton appropriate for the vote of the example above is shown below, where M identifies the majority operation,
 \not M identifies all other operations, pi is the principal that cast this vote, P is the set of all principals, \ast identifies all operations, and the grey state represents the initial state.
</div>
</p>
<img src="maj.png" alt="some text" height="100" width="300">
</p>
<div style="text-align:justify; font-size: 12pt;">
JRIF allows programmers to tag variables with RIF labels, and generally use RIF labels anywhere that ordinary types are used, specifying confidentiality and integrity restrictions on the corresponding information. RIF labels may be known statically, or they
 may be created dynamically. In the latter case, RIF labels can be treated as first-order values. For a more complete description of how labels can be used in a Java program, please study <a href="http://www.cs.cornell.edu/jif/doc/jif-3.3.0/manual.html">
Jif's documentation</a> (the syntax of Jif labels, and Jif's features for downgrading and authority are irrelevant for JRIF).
</div>
</p>
<div style="text-align:justify; font-size: 12pt;">
If a JRIF program is type correct, then all RIF labels used in that program are satisfied. In particular, if the value of a variable tagged with RIF label L is derived from the value of another variable tagged with L', by applying some operations, then L
 should be more restrictive than L' after taking transitions that correspond to these operations. L1 is more restrictive than L2, when L1 allows less principals to read and requires more principals to be trusted, comparing to L2, for all possible derived values.
</div>

<h2>JRIF Syntax</h2>
<p><strong>RIF automaton:</strong> It is written as a linear representation of an automaton, by listing identified states and transitions. For example, the syntax for the c-automaton of the above figure is:
</p>
<pre>rif[q1*:{pi},q2:{_},M:q1-&gt;q2].
</pre>
We use <tt>{_}</tt> to represent the set of all principals, and <tt>{}</tt> to represent the empty set.
<p><strong>RIF label:</strong> It is a pair of a c-automaton (starting with rif) and an i-automaton (starting with rifi). For example:
</p>
<pre>{rif[q1*:{pi},q2:P,M:q1-&gt;q2];rifi[q1*:{pi},q2:{},M:q1-&gt;q2]}.
</pre>
The least restrictive RIF label, which is sometimes written as <tt>{}</tt>, allows all principals to read and requires no principal to be trusted:
<pre>{rif[q1*:{_}];rifi[q1*:{}]}.
</pre>
Absence of the c-automaton from a RIF label, by default implies that no confidentiality restrictions are imposed. Similarly for the i-automaton.
<p><strong>Annotated expression:</strong> Expressions in a program are regarded to be operations; the values of variables in an expression are the inputs, and the value of that expression is the output. Expressions are assumed to be annotated with reclassifiers,
 which identify these operations. Reclassifiers are used to trigger transitions on RIF automata. Expression
<tt>E</tt> annotated with reclassifier <tt>f</tt> is written as </p>
<pre> reclassify(E,f).</pre>
Expressions that are not explicitly annotated, are assumed to be annotated with a default &quot;empty&quot; reclassifier, which has no effect on RIF automata. Currently, we assume that programmers use reclassifiers ranging from
<tt>f0</tt> to <tt>f9</tt>. Discharging this assumption requires a slight modification of the algorithm that decides the restrictiveness relation between two RIF labels, which we leave for future work.
<p></p>
<p><strong>Transitions on RIF labels:</strong> New RIF labels can be computed by applying transitions to existing ones. For example, a programmer may write
<tt>tr(tr(L,f1),f2)</tt>, meaning the RIF label derived from L, by applying reclassifiers
<tt>f1</tt> and <tt>f2</tt>. Notice that L may or may not be statically known.</p>
<h2>Examples</h2>
<p><strong>1. Reclassifying assigned expression:</strong> Reclassifier <tt>f1</tt> is applied to
<tt>x&#43;y</tt>. This method is type correct, because (i) the c-automaton of <tt>res</tt> is more restrictive than the c-automata of
<tt>x</tt> and <tt>y</tt> after taking the <tt>f1</tt> transition, (ii) the c-automaton of the declared exception is more restrictive than the c-automaton of
<tt>res</tt>, and (iii) the c-automaton of <tt>res</tt> if more restrictive than the c-automaton of the pc (program counter) at the call site of this method. In general, the specified RIF label of the pc at the call site of a method is written between the name
 and the arguments of that method. In this case, this RIF label is <tt>{}</tt>.</p>
<pre>public static void  main {} (String[] args) throws (Exception{rif[q1*:{Alice}]}) {

    int {rif[q1*:{Alice}]} res; 
    int {rif[q1*:{Alice,Bob},q2:{Alice},f1:q1-&gt;q2]} x;
    int {rif[q1*:{Alice},q2:{Alice,Bob},f1:q1-&gt;q2]} y; 
    
    res = reclassify(x&#43;y,f1);
    
    throw new Exception(&quot;Result: &quot;&#43;res);
    
}
</pre>
<p><strong>2. Reclassifying guard expression:</strong> Reclassifier <tt>f1</tt> is applied to
<tt>x==y</tt>. This snippet is type correct, because the c-automaton of <tt>res</tt> is more restrictive than the c-automata of
<tt>x</tt> and <tt>y</tt> after taking the <tt>f1</tt> transition.</p>
<pre>int {rif[q1*:{Alice}]} res; 
int {rif[q1*:{Alice,Bob},q2:{Alice},f1:q1-&gt;q2,f2:q2-&gt;q1]} x;
int {rif[q1*:{Alice,Bob},q2:{Alice,Bob},f1:q1-&gt;q2]} y;

if (reclassify(x==y,f1)){
	res = 1;
}
</pre>
<p><strong>3. Consecutive reclassifications:</strong> The final value of <tt>res</tt> depends on consecutively applying reclassifiers
<tt>f3</tt>, <tt>f1</tt>, <tt>f2</tt> to <tt>x</tt>. Here, both c-automata and i-automata are explicitly specified.</p>
<pre>int {rif[q1*:{},q2:{Alice},q3:{Alice,Bob},f1:q1-&gt;q2,f2:q2-&gt;q3];rifi[q1*:{Alice,Bob},q2:{Alice},f1:q1-&gt;q2]} res; 
int {rif[q1*:{},q2:{Alice},q3:{Bob,Alice},f1:q1-&gt;q2,f2:q2-&gt;q3];rifi[q1*:{Alice,Bob},q2:{Alice},f1:q1-&gt;q2]} x;
int {rif[q1*:{Alice},f2:q1-&gt;q2,q2:{Bob, Alice}];rifi[q1*:{Alice}]} y;

x = reclassify(res,f3);
y = reclassify(x&#43;4,f1);
res = reclassify(y,f2);
</pre>
<p><strong>4. Method call:</strong> Method <tt>work</tt> calls method <tt>help</tt> inside an annotated expression. This snippet is type correct, because (i) the c-automaton of the return type of
<tt>help</tt> is more restrictive than the c-automaton of <tt>y</tt>, (ii) the c-automaton of
<tt>res</tt> is more restrictive than the c-automata of <tt>help(x)</tt> after taking the
<tt>f1</tt> transition, and (iii) the c-automaton of <tt>y</tt> is more restrictive than the c-automaton of
<tt>x</tt>. </p>
<pre>public work {} (int {rif[q1*:{Alice,Bob}]} x) {

    int {rif[q1*:{Alice}]} res; 

    res = reclassify(help(x),f1);
}


int{rif[q1*:{Alice,Bob},q2:{Alice},f1:q1-&gt;q2]} help (int {rif[q1*:{Alice,Bob}]} y) {

    return y%2 &#43; y%3 &#43; y%4;
}
</pre>
<p><strong>5. Parametric RIF labels in where-constraint:</strong> Class <tt>foo</tt> is defined parametrically to labels
<tt>L1</tt>, <tt>L2</tt>, and <tt>L3</tt>. These parameters are instantiated once a
<tt>foo</tt> object is constructed. Whenever the constructor <tt>foo</tt> is called (e.g.
<tt>obj = new foo[{rif...;rifi...},{rif...;rifi...},{rif...;rifi...}](7,9);</tt> ), the instantiations of the parameters
<tt>L1</tt>,<tt>L2</tt>,<tt>L3</tt> should satisfy the where-constraint. Specifically,
<tt>L1</tt> should be more restrictive than <tt>L2</tt> and <tt>L3</tt>, after they have taken the
<tt>f1</tt> transition. If this condition holds, then the constructor is type correct, because the RIF label of
<tt>res</tt> is more restrictive than the RIF labels of <tt>x</tt> and <tt>y</tt>, after they have taken the
<tt>f1</tt> transition. </p>
<pre>public class foo[label L1, label L2, label L3] {

   int{L1} res;
   int{L2} x;
   int{L3} y;

   public foo(int{L2} a, int{L3} b) where tr(L2,f1)&lt;=L1, tr(L3,f1)&lt;=L1 {
       x = a;
       y = b;
       res = reclassify(x&#43;y,f1);
   }

}
</pre>
<p><strong>6. Dynamic RIF labels in dynamic check:</strong> Method <tt>work</tt> creates two dynamic RIF labels, and then it passes these labels as arguments to method
<tt>help</tt>. Method <tt>help</tt> executes the assignment only if the dynamic check succeeds.
</p>
<pre>int{*l2} help {rif[q0*:{_}];rifi[q1*:{}]} (label{rif[q0*:{_}];rifi[q1*:{}]} l1, label{rif[q0*:{_}];rifi[q1*:{}]} l2, int{*l1} x){

    int{*l2} y=-1;

    if ( new label tr(l1,f1) &lt;= l2)  y = reclassify(x % 4,f1);
    return y;
}

public void work{rif[q0*:{_}];rifi[q1*:{}]}() {

    final label{rif[q0*:{_}];rifi[q1*:{}]} l1 = new label {rif[q1*:{Alice},q2:{_},f1:q1-&gt;q2]; rifi[q1*:{Alice},q2:{},f1:q1-&gt;q2]};
    final label{rif[q0*:{_}];rifi[q1*:{}]} l2 = new label {rif[q1*:{_}]; rifi[q1*:{}]};
    int{*l1} x = new Random();
    int{*l2} res;
   
    res = help(l1,l2,x);

}
</pre>


</div>
</body>
</html>

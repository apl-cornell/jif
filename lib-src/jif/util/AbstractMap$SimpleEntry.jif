package jif.util;
/**
 * This should be made public as soon as possible.  It greately simplifies
 * the task of implementing Map.
 */
public class AbstractMap$SimpleEntry[label K, label V] implements Map$Entry[K,V] {
	JifObject[K]{K} key;
	JifObject[V]{K} value;
	
	public AbstractMap$SimpleEntry(JifObject[K]{K} key, JifObject[V]{K} value)
  {
		this.key   = key;
		this.value = value;
	}
	
	public AbstractMap$SimpleEntry(Map$Entry[K,V]{K} e)
  {
    try
    {
      this.key   = e.getKey();
      this.value = e.getValue();
    } catch (NullPointerException e)
    {
      key=null;
      value=null;
    }
	}
	
	public JifObject[K]{K} getKey()
  {
		return key;
	}
	
	public JifObject[V]{K} getValue()
  {
		return value;
	}
	
	public JifObject[V]{K} setValue{K}(JifObject[V]{K} value)
  {
		JifObject[V]{K} oldValue = this.value;
		this.value = value;
		return oldValue;
	}
	
	public boolean{K;V;o} equals(IDComparable[{K;V}] o)
  {
		if (!(o instanceof Map$Entry[K,V]))
    {
			return false;
    }

    try
    {
      Map$Entry[K,V] e = (Map$Entry[K,V])o;
      return eq(key, e.getKey()) &&  eq(value, e.getValue());
    } catch (ClassCastException impossible) {}

    return false;
	}
	
	public int{K;V} hashCode()
  {
    try
    {
      return ((key   == null)   ? 0 :   key.hashCode()) ^	((value == null)   ? 0 : value.hashCode());
    } catch (NullPointerException e) {return 0;}
	}
	
	public String{K;V} toString()
  {
    try
    {
      return key.toString() + "=" + value.toString();
    } catch (NullPointerException e) {return "";}
	}
	
	private static boolean{K;V;o1;o2} eq(IDComparable[{K;V}] o1, IDComparable[{K;V}] o2)
  {
		return (o1 == null ? o2 == null : o1.equals(o2));
	}
}

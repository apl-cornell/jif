package jif.util;

import jif.runtime.Runtime;

/**
 * This class is a simple utility class for representing and comparing dates. 
 * It is not intended to replace or duplicate the functionality of 
 * java.util.Date.
 * It provides precision only to the day.
 * It is immutable.
 * It provides no way to get the current time.
 */
public final class Date[covariant label L] implements JifObject[L] {
    private final int{L} year;
    private final int{L} month;
    private final int{L} day;

    public static final String{*!:*}[]{*!:*} monthNames = {
            "NOT A VALID MONTH",
            "January", "February", "March", "April",
            "May", "June", "July", "August",
            "September", "October", "November", "December",
        };

    public static final String{*!:*}[]{*!:*} daysOfWeek = {
            "Sunday",
            "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
            "Saturday", "Sunday",
        };
    public static final String{*!:*}[]{*!:*} shortDaysOfWeek = {
            "Sun",
            "Mon", "Tue", "Wed", "Thu", "Fri",
            "Sat", "Sun",
        };

    public static final String{*!:*}[]{*!:*} shortMonthNames = {
        "NOT A VALID MONTH",
        "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    };
    public static final int{*!:*}[]{*!:*} maxDaysInMonth = {
        -1,
        31, 29, 31, 30, 31, 30, 
        31, 31, 30, 31, 30, 31,
    };

    /**
     * At the moment, assume that the string is in the format YYYY/MM/DD
     * or DD-MM-YYYY
     */
    public static Date[lbl]{lbl} valueOf{*lbl}(label lbl, String{*lbl} d) throws (IllegalArgumentException{*lbl}) {
        if (d == null) {
            throw new IllegalArgumentException("null string");
        }
        int yearStart = 0;
        int yearEnd = 4;
        int monthStart = 5;
        int monthEnd = 7;
        int dayStart = 8;
        int dayEnd = 10;
        int i = d.indexOf('-', 0);
        if (i > 0) { 
            // date is of the form dd-mm-yyyy
            dayStart=0;
            dayEnd = i; 
            monthStart = i + 1; 
            int j = d.indexOf('-', monthStart);
            if (j > 0) { 
                monthEnd = j; 
                yearStart = j + 1;
                yearEnd = d.length();
            }
            else {
                throw new IllegalArgumentException("invalid string: format should be DD-MM-YYYY");
            }

        }
        else if (d.length() != 10) {
            throw new IllegalArgumentException("invalid string: format should be DD-MM-YYYY");
        }
        
        try {
            int year = Integer.parseInt(d.substring(yearStart,yearEnd));
            int month = Integer.parseInt(d.substring(monthStart,monthEnd));
            int day = Integer.parseInt(d.substring(dayStart,dayEnd));
            return new Date[lbl](year, month, day);
        }
        catch (NumberFormatException e) {
            throw new IllegalArgumentException("invalid string: format should be DD-MM-YYYY");
        }
        catch (StringIndexOutOfBoundsException impossible) {
            return null;
        }
    }
 
    /**
     * Set the date to the current day
     */
    public Date() {
        final principal p = PrincipalUtil.nullPrincipal();
        this.year = Runtime[p].currentYear();
        this.month = Runtime[p].currentMonth();
        this.day = Runtime[p].currentDayOfMonth();
    }
    public Date(int{L; this} pYear, int{L; this} pMonth, int{L; this} pDay) throws (IllegalArgumentException{pYear; pMonth; pDay}){
        this.year = pYear;
        this.month = pMonth;
        this.day = pDay;            
        checkDateValid(pYear, pMonth, pDay);
    }
    public Date(int{L} pYear, String{L} pMonth, int{L} pDay) throws (IllegalArgumentException{pYear; pMonth; pDay}) {
        this.year = pYear;
        this.day = pDay;
        int theMonth = 0;
        for (int i = 1; i <= 12; i++) {
            try {
                if (monthNames[i].equalsIgnoreCase(pMonth) || shortMonthNames[i].equalsIgnoreCase(pMonth)) {
                    theMonth = i;
                    break;
                }
            }
            catch(ArrayIndexOutOfBoundsException impossible) { }
            catch(NullPointerException impossible) { }
        }
        if (theMonth == 0) {
            throw new IllegalArgumentException("Invalid month: " + pMonth);
        }
        this.month = theMonth;
        checkDateValid(pYear, theMonth, pDay);
    }
    
    public static int daysInMonth(int month, int year) {
        if (month < 1 || month > 12) return -1;
        try {
            if (month == 2) {
                return isLeapYear(year)?29:28;
            }
            return maxDaysInMonth[month];
        }
        catch (NullPointerException impossible) { }
        catch (ArrayIndexOutOfBoundsException impossible) { }
        return -1;
    }
    private static void checkDateValid(int pYear, int pMonth, int pDay)  throws (IllegalArgumentException{pYear; pMonth; pDay}) {
        if (pMonth < 1 || pMonth > 12) {
            throw new IllegalArgumentException("Invalid month: " + pMonth);
        }
        try {
            if (pDay < 1 || pDay > daysInMonth(pMonth, pYear)) {
                throw new IllegalArgumentException(monthNames[pMonth] + " " + 
                      pYear + " has " + daysInMonth(pMonth, pYear) + " days.");
            }
        }
        catch(ArrayIndexOutOfBoundsException impossible) { }
        catch(NullPointerException impossible) { }

    }
    
    public static Date[lbl] lenientDate(label lbl, int{*lbl} year, 
                                        int{*lbl} month, int{*lbl} day) {
        int y = year;
        int m = month;
        int d = day;
        try {
            while (m > 12 || m < 1 || d < 1 || d > daysInMonth(m, y)) {
                while (m > 12) {
                    m -= 12; y++;
                }
                while (m < 1) {
                    m += 12; y--;
                }
                // m is now between 1 and 12 inclusive
                if (d > daysInMonth(m, y)) {
                    d -= daysInMonth(m, y); m++;
                }
                if (d < 1) {
                    d += daysInMonth((m+10)%12+1, y); m--;
                }
            }
            return new Date[lbl](y, m, d);
        }
        catch (ArithmeticException impossible) { }
        catch (IllegalArgumentException impossible) { }
        return null;
    }

    public int{L} getYear() { return this.year; }
    public int{L} getMonth() { return this.month; }
    public int{L} getDay() { return this.day; }
    public int{L} getDayOfWeek() { 
        try {
            // Jan 1 1900 was a monday, so its index is 1.
            // add the number of days since then, and take mod 7
            // could be a negative number, so add seven to be safe...
            int thisD = Date[L].daysAfterJan_1_1900(this.year, this.month, this.day);
            return ((thisD % 7) + 8) % 7;
        }
        catch (ArithmeticException unlikely) { return 0; }
    }
    
    public String{L} getMonthName() { 
        try {
            return monthNames[this.month];
        }
        catch(ArrayIndexOutOfBoundsException impossible) { }
        catch(NullPointerException impossible) { }
        return "impossible!";
    }
    public String{L} getShortMonthName() { 
        try {
            return monthNames[this.month];
        }
        catch(ArrayIndexOutOfBoundsException impossible) { }
        catch(NullPointerException impossible) { }
        return "impossible!";
    }
    public String{L} getDayOfWeekName() { 
        try {
            return daysOfWeek[this.getDayOfWeek()];
        }
        catch(ArrayIndexOutOfBoundsException impossible) { }
        catch(NullPointerException impossible) { }
        return "impossible!";            
    }
    public String{L} getShortDayOfWeekName() {
        try {
            return shortDaysOfWeek[this.getDayOfWeek()];
        }
        catch(ArrayIndexOutOfBoundsException impossible) { }
        catch(NullPointerException impossible) { }
        return "impossible!";
    }

    //    public String{L} getDayOfWeek() {
//        try {
//            return daysOfWeek[this.day];
//        }
//        catch(ArrayIndexOutOfBoundsException impossible) { }
//        catch(NullPointerException impossible) { }
//        return "impossible!";
//    }

    public boolean{L; when} before(Date[L] when) {
        Date[L] that = when;
        if (that == null) {
            return false;
        }
        return (this.year < that.year) ||
            (this.year == that.year && this.month < that.month) ||
            (this.year == that.year && this.month == that.month && this.day < that.day);
    }

    public boolean{L; when} after(Date[L] when) {
        Date[L] that = when;
        if (that == null) {
            return false;
        }
        return (this.year > that.year) ||
            (this.year == that.year && this.month > that.month) ||
            (this.year == that.year && this.month == that.month && this.day > that.day);
    }
    
    /**
     * Return number of days that this is before when. Will return a negative
     * number if this is after when.
     */
    public int{L; when} daysBefore(Date[L] when) {
        if (when == null) return 0;
        int whenD = Date[L].daysAfterJan_1_1900(when.year, when.month, when.day);
        int thisD = Date[L].daysAfterJan_1_1900(this.year, this.month, this.day);

        return whenD - thisD; 
    }
            
    private static int daysAfterJan_1_1900(int year, int month, int day) {        
        int y = year;
        int m = month;
        int d = day;
        int count = 0;

        while (y - 400 > 1900) {
            count += DAYS_IN_400_YEARS;
            y -= 400;
        }
        while (y + 400 < 1900) {
            count -= DAYS_IN_400_YEARS;
            y += 400;
        }

        while (y > 1900) {
            count += isLeapYear(--y)?366:365;
        }
        while (y < 1900) {
            count -= isLeapYear(++y)?366:365;
        }
        // now y == 1900
        while (m > 1) {
            count += daysInMonth(--m, y);
        }
        count += d-1;
        return count;
    }
    private static final int{} DAYS_IN_400_YEARS = 146097;

    /**
     * Determine if the given year is a leap years. A year is a leap year
     * if it is divisible by 4, unless it is the first year of a century 
     * (i.e. is divisible by 100), except for every fourth century.
     */
    public static boolean{pYear} isLeapYear(int pYear) {
        try {
            return (pYear % 4 == 0 && (pYear % 100 != 0 || pYear % 400 == 0));
        }
        catch (ArithmeticException  e) {
            return false;
        }
    }

    public String{L} toString() {
        return toLongString();
    }

    public boolean{L;o} equals(IDComparable[L] o) {
        return equals(L, o);
    }
    public boolean{L;*lbl;lbl;o} equals(label lbl, IDComparable[lbl] o) {
        if (o == null || !(o instanceof Date[lbl])) {
            return false;
        }
        Date[lbl] that = (Date[lbl])o;
        return this.year == that.year &&
            this.month == that.month &&
            this.day == that.day;
    }

    public int{L} hashCode() {
        return (year) ^
            (month * 37) &
            (day * 113);
    }
    // formatting methods
    public String{L} toLongString() {
        return day + " " + getMonthName() + " " + year;
    }
    public String{L} toShortString() {
        return day + "-" + month + "-" + year;
    }
    
    
    // Functional style methods
    public Date[L]{L} year(int{this} year):{L; this} throws IllegalArgumentException {
        return new Date[L](year, this.month, this.day);
    }
    public Date[L]{L} month(int{this} month):{L; this} throws IllegalArgumentException {
        return new Date[L](this.year, month, this.day);
    }
    public Date[L]{L} day(int{this} day):{L; this} throws IllegalArgumentException {
        return new Date[L](this.year, this.month, day);
    }
//    public Date[L]{L} addYear(int{L} yearDelta):{L; this} {
//        return lenientDate(L, this.year + yearDelta, this.month, this.day);
//    }
//    public Date[L]{L} addMonth(int{L} monthDelta):{L; this} {
//        return lenientDate(L, this.year, this.month + monthDelta, this.day);
//    }
//    public Date[L]{L} addDay(int{L} dayDelta):{L; this} {
//        return lenientDate(L, this.year, this.month, this.day + dayDelta);
//    }
    public static Date[lb]{*lb; lb; date; delta} addYear(label lb, Date[lb]{*lb} date, int{*lb} delta) {
        if (date == null) return null;
        return Date[lb].lenientDate(lb, date.getYear() + delta, date.getMonth(), date.getDay());
    }
    public static Date[lb]{*lb; lb; date; delta} addMonth(label lb, Date[lb]{*lb} date, int{*lb} delta) {
        if (date == null) return null;
        return Date[lb].lenientDate(lb, date.getYear(), date.getMonth() +  + delta, date.getDay());
    }
    public static Date[lb]{*lb; lb; date; delta} addDay(label lb, Date[lb]{*lb} date, int{*lb} delta) {
        if (date == null) return null;
        return Date[lb].lenientDate(lb, date.getYear(), date.getMonth(), date.getDay() + delta);
    }
}

package jif.lang;


/**
 * TODO Documentation 
 */
public abstract class AbstractPrincipal implements Principal {
    private final String{this} name;
    protected Principal{this:;this!:*}[]{this:;this!:*} superiors = null;
    
    protected AbstractPrincipal(String{this} name) {
        this.name = name;
    }
    
    public String{this} name() {
        return name;
    }
    
    public boolean{this;p;this!:} delegatesTo(principal p) {
        return superiorsContains((Principal)p);
    }
    
    public void addDelegatesTo{this:;this!:*}(principal{this} p) where caller (this) {
        if (superiorsContains((Principal)p)) {
            return;
        }
        // need to add p to the superiors.
        try {
            if (superiors == null) {
                superiors = new Principal[1];
                superiors[0] = (Principal)p;            
            }
            else {
                Principal{this:;this!:*}[] old = superiors;
                superiors = new Principal[old.length+1];
                for (int i = 0; i < old.length; i++) {
                    superiors[i] = old[i];
                }
                superiors[old.length] = (Principal)p;            
            }
        }
        catch (NullPointerException impossible) {}
        catch (ArrayStoreException impossible) {}
        catch (ArrayIndexOutOfBoundsException impossible) {}
    }
    
    protected boolean{this;p;this!:} superiorsContains(Principal p) where authority (this) {
        boolean result = false;
        Principal{this:;this!:*}[] sprs = superiors;
        for (int i = 0; sprs != null && i < sprs.length; i++) {
            try {
                Principal pi = sprs[i];                        
                if (p == pi || (pi != null && pi.equals(p))) {
                    result = true;
                    break;
                }
            }
            catch (ArrayIndexOutOfBoundsException impossible) {}
        }
        return declassify(result, {this;p;this!:});
    }
    
    public boolean{authPrf; closure; lb; *lb; this; this!:} isAuthorized(Object authPrf, 
                                                                 Closure[this, lb] closure,
                                                                 label lb) where authority (this) {
        // The default is that this principal authorizes no closures.
        return false;
    }
    
    
    public ActsForProof findProofDownto(Principal q) {    
        // don't even try! We don't have any information
        // about who we can act for.
        return null;
    }
    
    public ActsForProof{this;p;this!:;p!:} findProofUpto(Principal p) where authority (this) {
        // go through each superior s, and see if we can find a proof
        // from p to s.
        ActsForProof prf;
        
        Principal{this:;this!:*}[]{this;this!:*} sprs = declassify(superiors, {this;this!:*});
        ActsForProof{this;p;this!:;p!:} result = null;
        for (int i = 0; sprs != null && i < sprs.length; i++) {
            try {
                final Principal s = declassify(sprs[i], {this;this!:*});
                prf = PrincipalUtil.findActsForProof(p, s);
                if (prf != null) {
                    // success!
                    // create a bigger proof 
                    if (s actsfor this) {
                        // always true, since s is in the delegates set.
                        // we need it in order to get the right label for the
                        // return value.
                        result = new TransitiveProof(prf, s, new DelegatesProof(s, this));
                        break;
                    }
                }
            }
            catch (ArrayIndexOutOfBoundsException impossible) {}
        }
        
        return result;
    }
    
    public boolean{this;o} equals(Object o) {
        if (o == null) return false;
        if (o instanceof Principal) {
            return equals((Principal)o);
        }
        return false;
    }
    
    public boolean{this;p} equals(Principal p) {
        if (p == null) return false;
        return (this.name == p.name() || (this.name != null && 
                this.name.equals(p.name()))) &&
                this.getClass() == p.getClass();        
    }
    
}

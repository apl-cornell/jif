package jif.parse; 

import java_cup.runtime.*;

import polyglot.ast.*;
import polyglot.visit.*;
import polyglot.types.*;
import polyglot.frontend.*;
import polyglot.util.*;
import polyglot.lex.Lexer;
import polyglot.lex.Identifier;
import polyglot.lex.Token;

import polyglot.ext.jl.ast.*;
import jif.ast.*;
import jif.types.*;

import java.util.*;

parser Grm extends polyglot.ext.jl.parse.Grm {:

    public final JifNodeFactory nf; /* shadows BaseParser.nf */
    public final JifTypeSystem ts; /* shadows BaseParser.ts */

    public Grm(polyglot.lex.Lexer l, JifTypeSystem t,
	       JifNodeFactory n, ErrorQueue q) {
	super(l,t,n,q);
	ts = t;
	nf = n;
    }

    /**
     * After we parse as usual, the AST may contain ambiguous nodes wrapped in
     * expressions.  These are the _only_ ambiguous expressions in the AST at
     * this point, although there may be ambiguous types, qualifiers, etc.
     * Here, we make a visitor pass over the AST to unwrap these ambiguous
     * nodes and convert them to (possibly ambiguous) expressions.
     *
     * This pass is done after parsing to avoid having to convert expressions
     * into types.
     */
    public java_cup.runtime.Symbol parse() throws Exception {
        java_cup.runtime.Symbol sym = super.parse();

        if (sym == null || sym.value == null) {
            return null;
        }

        Node n = (Node) sym.value;
        sym.value = n.visit(new UnwrapVisitor());
        return sym;
    }

    // Since there are no inner classes, a type qualifier must be a package.
    public PackageNode exprToPackage(Expr e) throws Exception {
        if (e instanceof Wrapper) {
            return ((Wrapper) e).amb.toPackage();
        }

        if (e instanceof AmbExpr) {
            AmbExpr a = (AmbExpr) e;
            return nf.PackageNode(pos(e), ts.packageForName(a.name()));
        }

        if (e instanceof Field) {
            Field f = (Field) e;
            PackageNode pn = prefixToPackage(f.target());
            return nf.PackageNode(pos(e),
                                ts.packageForName(pn.package_(), f.name()));
        }

        die(pos(e));
        return null;
    }
	
    public PackageNode prefixToPackage(Prefix p) throws Exception {
        if (p instanceof Expr) {
            return exprToPackage((Expr) p);
        }

        if (p instanceof AmbPrefix) {
            AmbPrefix a = (AmbPrefix) p;
            PackageNode pn = prefixToPackage(a.prefix());
            return nf.PackageNode(pos(p),
                                ts.packageForName(pn.package_(), a.name()));
        }

        die(pos(p));
        return null;
    }

    public ParamNode exprToParam(Expr e) throws Exception {
        if (e instanceof Wrapper) {
            Wrapper w = (Wrapper) e;
            if (w.amb instanceof Name) {
                Name a = (Name) w.amb;
                if (a.prefix == null) {
                    return nf.AmbParam(pos(e), a.name);
                }
            }
        }

        die(pos(e));
        return null;
    }

    public TypeNode exprToUninstType(Expr e) throws Exception {
        if (e instanceof Wrapper) {
            return ((Wrapper) e).amb.toUnlabeledType();
        }

        if (e instanceof AmbExpr) {
            AmbExpr a = (AmbExpr) e;
            return nf.AmbTypeNode(pos(e), a.name());
        }

        if (e instanceof Field) {
            Field f = (Field) e;
            Receiver r = f.target();
            return nf.AmbTypeNode(pos(e), prefixToPackage(r), f.name());
        }

        die(pos(e));
        return null;
    }

    public TypeNode exprToType(Expr e) throws Exception {
        if (e instanceof ArrayAccess) {
            ArrayAccess a = (ArrayAccess) e;
            Expr array = a.array();
            Expr index = a.index();

            TypeNode base = exprToUninstType(array);
            ParamNode param = exprToParam(index);

            List l = new LinkedList();
            l.add(param);
            return nf.InstTypeNode(pos(e), base, l);
        }

        return exprToUninstType(e);
    }

    List toParamList(List l) throws Exception {
        List params = new TypedList(new LinkedList(), ParamNode.class, false);

        for (Iterator i = l.iterator(); i.hasNext(); ) {
            Object n = i.next();

            if (n instanceof Name) {
                params.add(nf.AmbParam(((Name) n).pos,
                                ((Name) n).name));
            }
            else if (n instanceof ParamNode) {
                params.add(n);
            }
            else if (n instanceof Node) {
                die(pos((Node) n));
                return null;
            }
            else {
                die(pos());
                return null;
            }
        }

        return params;
    }
	

    /**
     * Return the source position of the Parse.
     */
    public static Position pos(Amb n) {
	if (n == null) {
	    return null;
	}
	return n.pos;
    }
    
    public Position pos(Declarator n) {
        if (n == null) {
            return null;
        }
        return n.pos;
    }
    
    public Position pos() {
        return new Position(lexer.file());
    }

:};

scan with {: return nextSymbol(); :};

terminal Token BOOLEAN; // primitive_type
terminal Token BYTE, SHORT, INT, LONG, CHAR; // integral_type
terminal Token FLOAT, DOUBLE; // floating_point_type
terminal Token LBRACK, RBRACK; // primitive_array_type
terminal Identifier IDENTIFIER; // name
terminal Token DOT; // qualified_name
terminal Token SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ; // separators
terminal Token LPAREN, RPAREN, COLON; // more separators
terminal Token PACKAGE; // package_declaration
terminal Token IMPORT; // import_declaration
terminal Token PUBLIC, PROTECTED, PRIVATE; // modifier
terminal Token STATIC; // modifier
terminal Token ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal Token CLASS; // class_declaration
terminal Token EXTENDS; // super
terminal Token IMPLEMENTS; // interfaces
terminal Token VOID; // method_header
terminal Token THROWS; // throws
terminal Token THIS, SUPER; // explicit_constructor_invocation
terminal Token INTERFACE; // interface_declaration
terminal Token IF, ELSE; // if_then_statement, if_then_else_statement
terminal Token SWITCH; // switch_statement
terminal Token CASE, DEFAULT; // switch_label
terminal Token DO, WHILE; // while_statement, do_statement
terminal Token FOR; // for_statement
terminal Token BREAK; // break_statement
terminal Token CONTINUE; // continue_statement
terminal Token RETURN; // return_statement
terminal Token THROW; // throw_statement
terminal Token TRY; // try_statement
terminal Token CATCH; // catch_clause
terminal Token FINALLY; // finally
terminal Token NEW; // class_instance_creation_expression
terminal Token PLUSPLUS; // postincrement_expression
terminal Token MINUSMINUS; // postdecrement_expression
terminal Token PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal Token LSHIFT, RSHIFT, URSHIFT; // shift_expression
terminal Token LT, GT, LTEQ, GTEQ, INSTANCEOF; // relational_expression
terminal Token EQEQ, NOTEQ; // equality_expression
terminal Token AND; // and_expression
terminal Token XOR; // exclusive_or_expression
terminal Token OR;  // inclusive_or_expression
terminal Token ANDAND; // conditional_and_expression
terminal Token OROR; // conditional_or_expression
terminal Token QUESTION; // conditional_expression
terminal Token MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator
terminal Token LSHIFTEQ, RSHIFTEQ, URSHIFTEQ; // assignment_operator
terminal Token ANDEQ, XOREQ, OREQ; // assignment_operator

terminal polyglot.lex.IntegerLiteral INTEGER_LITERAL;
terminal polyglot.lex.LongLiteral LONG_LITERAL;
terminal polyglot.lex.DoubleLiteral DOUBLE_LITERAL;
terminal polyglot.lex.FloatLiteral FLOAT_LITERAL;
terminal polyglot.lex.BooleanLiteral BOOLEAN_LITERAL;
terminal polyglot.lex.CharacterLiteral CHARACTER_LITERAL;
terminal polyglot.lex.StringLiteral STRING_LITERAL;
terminal polyglot.lex.NullLiteral NULL_LITERAL;

// strictfp keyword, new in Java 1.2
terminal Token STRICTFP;

// Reserved but unused:
terminal CONST, GOTO;

// Jif extensions
terminal Token WHERE;
terminal Token PRINCIPAL;
terminal Token LABEL;
terminal Token COVARIANT;
terminal Token INVARIANT;
terminal Token AUTHORITY;
terminal Token CALLER;
terminal Token ACTSFOR;
terminal Token DECLASSIFY;

// 19.2) The Syntactic Grammar
non terminal SourceFile goal;
// 19.3) Lexical Structure
non terminal polyglot.ast.Lit literal;
// 19.4) Types, Values, and Variables
non terminal TypeNode type, primitive_type, numeric_type;
non terminal TypeNode integral_type, floating_point_type;
non terminal TypeNode reference_type;
non terminal TypeNode class_or_interface_type;
non terminal TypeNode primitive_array_type;
// 19.5) Names
non terminal Name name, simple_name, qualified_name;
// 19.6) Packages
non terminal SourceFile compilation_unit;
non terminal PackageNode package_declaration_opt, package_declaration;
non terminal List import_declarations_opt, import_declarations;
non terminal List type_declarations_opt, type_declarations;
non terminal Import import_declaration;
non terminal Import single_type_import_declaration;
non terminal Import type_import_on_demand_declaration;
non terminal ClassDecl type_declaration;
// 19.7) Productions used only in the LALR(1) grammar
non terminal Flags modifiers_opt, modifiers, modifier;
// 19.8.1) Class Declaration
non terminal ClassDecl class_declaration;
non terminal TypeNode super, super_opt;
non terminal List interfaces, interfaces_opt, interface_type_list;
non terminal ClassBody class_body;
non terminal List class_body_declarations, class_body_declarations_opt;
non terminal List class_body_declaration, class_member_declaration;
// 19.8.2) Field Declarations
non terminal List field_declaration;
non terminal List variable_declarators;
non terminal Declarator variable_declarator;
non terminal Declarator variable_declarator_id;
non terminal Expr variable_initializer;
// 19.8.3) Method Declarations
non terminal MethodDecl method_declaration, method_header;
non terminal List formal_parameter_list_opt, formal_parameter_list;
non terminal Formal formal_parameter;
non terminal List throws_opt, throws;
non terminal List class_type_list;
non terminal Block method_body;
// 19.8.4) Static Initializers
non terminal Block static_initializer;
// 19.8.5) Constructor Declarations
non terminal ConstructorDecl constructor_declaration;
non terminal Block constructor_body;
non terminal ConstructorCall explicit_constructor_invocation;
non terminal ConstructorCall explicit_super_constructor_invocation;
// 19.9.1) Interface Declarations
non terminal ClassDecl interface_declaration;
non terminal List extends_interfaces_opt, extends_interfaces;
non terminal ClassBody interface_body;
non terminal List interface_member_declarations_opt, interface_member_declarations;
non terminal List interface_member_declaration;
non terminal List constant_declaration;
non terminal MethodDecl abstract_method_declaration;
// 19.10) Arrays
non terminal ArrayInit array_initializer;
non terminal List variable_initializers;
// 19.11) Blocks and Statements
non terminal Block block;
non terminal List block_statements_opt, block_statements;
non terminal List block_statement;
non terminal List local_variable_declaration_statement;
non terminal List local_variable_declaration;
non terminal Stmt statement, statement_no_short_if;
non terminal Stmt statement_without_trailing_substatement;
non terminal Empty empty_statement;
non terminal Stmt labeled_statement, labeled_statement_no_short_if;
non terminal Stmt expression_statement;
non terminal Expr statement_expression;
non terminal If if_then_statement;
non terminal If if_then_else_statement, if_then_else_statement_no_short_if;
non terminal Switch switch_statement;
non terminal List switch_block, switch_block_statement_groups;
non terminal List switch_block_statement_group, switch_labels;
non terminal Case switch_label;
non terminal While while_statement, while_statement_no_short_if;
non terminal Do do_statement;
non terminal For for_statement, for_statement_no_short_if;
non terminal List for_init_opt, for_init;
non terminal List for_update_opt, for_update;
non terminal List statement_expression_list;
non terminal Name identifier_opt;
non terminal Branch break_statement, continue_statement;
non terminal Return return_statement;
non terminal Throw throw_statement;
non terminal Synchronized synchronized_statement;
non terminal Try try_statement;
non terminal List catches_opt, catches;
non terminal Catch catch_clause;
non terminal Block finally;
// 19.12) Expr
non terminal Expr primary, primary_no_array, primary_no_new_array;
non terminal New class_instance_creation_expression;
non terminal List argument_list_opt, argument_list;
non terminal Expr array_creation_expression;
non terminal List dim_exprs;
non terminal Expr dim_expr;
non terminal Integer dims_opt, dims;
non terminal Field field_access;
non terminal Call method_invocation;
non terminal Expr array_access;
non terminal Expr postfix_expression;
non terminal Unary postincrement_expression, postdecrement_expression;
non terminal Expr unary_expression, unary_expression_not_plus_minus;
non terminal Unary preincrement_expression, predecrement_expression;
non terminal Cast cast_expression;
non terminal Expr multiplicative_expression, additive_expression;
non terminal Expr shift_expression, relational_expression, equality_expression;
non terminal Expr and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal Expr conditional_and_expression, conditional_or_expression;
non terminal Expr conditional_expression, assignment_expression;
non terminal Expr assignment;
non terminal Expr left_hand_side;
non terminal Assign.Operator assignment_operator;
non terminal Expr expression_opt, expression;
non terminal Expr constant_expression;

// Jif extensions
non terminal DeclassifyExpr declassify;
non terminal DeclassifyStmt declassify_statement;
non terminal TypeNode labeled_primitive_type;
non terminal LabelNode label, label_opt, return_label_opt;
non terminal List component_list;
non terminal LabelNode label_component;
non terminal PrincipalNode principal;
non terminal List principal_list, readers;
non terminal ActsFor actsfor_statement;
non terminal ActsFor actsfor_else_statement;
non terminal ActsFor actsfor_else_statement_no_short_if;
non terminal SwitchLabel labelcase_statement;
non terminal List labelcases;
non terminal LabelCase labelcase_else, labelcase_no_else;

non terminal List parameters_opt, parameters;
non terminal ParamDecl parameter;
non terminal Boolean invariant_opt;
non terminal List constraints, constraints_opt;
non terminal List authority, authority_opt;
non terminal ConstraintNode constraint;
non terminal Amb ambiguous, simple_ambiguous;
non terminal List param_or_expr_list;

start with goal;

// 19.2) The Syntactic Grammar
goal ::=
                    // SourceFile
        compilation_unit:a
            {: RESULT = a; :}
    ;

// 19.3) Lexical Structure.
literal ::=
                    // Lit
        INTEGER_LITERAL:a
            {: RESULT = parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                         a.getValue().intValue()); :}
    |   LONG_LITERAL:a
            {: RESULT = parser.nf.IntLit(parser.pos(a), IntLit.LONG,
                                         a.getValue().longValue()); :}
    |   DOUBLE_LITERAL:a
            {: RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.DOUBLE,
                                           a.getValue().doubleValue()); :}
    |   FLOAT_LITERAL:a
            {: RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.FLOAT,
                                           a.getValue().floatValue()); :}
    |   BOOLEAN_LITERAL:a
            {: RESULT = parser.nf.BooleanLit(parser.pos(a),
                                             a.getValue().booleanValue()); :}
    |   CHARACTER_LITERAL:a
            {: RESULT = parser.nf.CharLit(parser.pos(a),
                                          a.getValue().charValue()); :}
    |   STRING_LITERAL:a
            {: RESULT = parser.nf.StringLit(parser.pos(a), a.getValue()); :}
    |   NULL_LITERAL:a
            {: RESULT = parser.nf.NullLit(parser.pos(a)); :}
    ;

// Jif labels
label ::=
                    // LabelNode
        LBRACE:x RBRACE
            {: RESULT = parser.nf.CanonicalLabelNode(parser.pos(x),
                                        parser.ts.bottomLabel()); :}
    |   LBRACE:x component_list:a RBRACE
            {: RESULT = parser.nf.JoinLabelNode(parser.pos(x), a); :}
    ;
label_opt ::=
                    // LabelNode
            {: RESULT = null; :}
    |   label:a
            {: RESULT = a; :}
    ;
component_list ::=
                    // List of LabelNode
        label_component:a
            {: List l = new TypedList(new LinkedList(), LabelNode.class, false);
               l.add(a);
               RESULT = l; :}
    |   component_list:a SEMICOLON label_component:b
            {: RESULT = a;
               a.add(b); :}
        ;
label_component ::=
                    // LabelNode
        principal:a COLON readers:b
            {: RESULT = parser.nf.PolicyLabelNode(parser.pos(a), a, b); :}
    |   MULT IDENTIFIER:a
            {: RESULT = parser.nf.AmbDynamicLabelNode(parser.pos(a), a.getIdentifier()); :}
    |   THIS:a
            {: RESULT = parser.nf.AmbThisLabelNode(parser.pos(a)); :}
    |   IDENTIFIER:a
            {: RESULT = parser.nf.AmbVarLabelNode(parser.pos(a), a.getIdentifier()); :}
    ;
readers ::=
                    // List of PrincipalNode
            {: RESULT = new TypedList(new LinkedList(), PrincipalNode.class, false); :}
    |   principal_list:a
            {: RESULT = a; :}
    ;
principal_list ::=
                    // List of PrincipalNode
        principal:a
            {: List l = new TypedList(new LinkedList(), PrincipalNode.class, false);
           l.add(a);
               RESULT = l; :}
    |   principal_list:a COMMA principal:b
            {: RESULT = a;
               a.add(b); :}
    ;
principal ::=
                    // PrincipalNode
        IDENTIFIER:a
            {: RESULT = parser.nf.AmbPrincipalNode(parser.pos(a),
                           a.getIdentifier()); :}
    ;

// 19.4) Types, Values, and Variables
primitive_type ::=
                    // TypeNode
        numeric_type:a
            {: RESULT = a; :}
    |   BOOLEAN:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Boolean()); :}
    |   LABEL:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Label()); :}
    |   PRINCIPAL:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Principal()); :}
    ;
numeric_type::=
                    // TypeNode
        integral_type:a
            {: RESULT = a; :}
    |   floating_point_type:a
            {: RESULT = a; :}
    ;
integral_type ::=
                    // TypeNode
        BYTE:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Byte()); :}
    |   SHORT:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Short()); :}
    |   CHAR:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Char()); :}
    |   INT:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Int()); :}
    |   LONG:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Long()); :}
    ;
floating_point_type ::=
                    // TypeNode
        FLOAT:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Float()); :}
    |   DOUBLE:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Double()); :}
    ;
type    ::=
                    // TypeNode
        labeled_primitive_type:a
            {: RESULT = a; :}
    |   ambiguous:a
            {: RESULT = a.toType(); :}
    |   primitive_array_type:a
            {: RESULT = a; :}
    |   primitive_array_type:a label:b
            {: RESULT = parser.nf.LabeledTypeNode(parser.pos(a), a, b); :}
    ;
labeled_primitive_type  ::=
        primitive_type:a
            {: RESULT = a; :}
    |   primitive_type:a label:b
            {: RESULT = parser.nf.LabeledTypeNode(parser.pos(a), a, b); :}
    ;
reference_type ::=
                    // TypeNode
        primitive_array_type:a
            {: RESULT = a; :}
    |   ambiguous:a
            {: RESULT = a.toType(); :}
    ;
class_or_interface_type ::=
                    // TypeNode
        ambiguous:a
            {: RESULT = a.toType(); :}
    ;
primitive_array_type ::=
                    // TypeNode
        labeled_primitive_type:a dims:b
            {: RESULT = parser.array(a, b.intValue()); :}
    ;
// 19.5) Names
name    ::=
                    // Name
        simple_name:a
            {: RESULT = a; :}
    |   qualified_name:a
            {: RESULT = a; :}
    ;
simple_name ::=
                    // Name
        IDENTIFIER:a
            {: RESULT = new Name(parser, parser.pos(a),
                                 a.getIdentifier()); :}
    ;
qualified_name ::=
                    // Name
        name:a DOT IDENTIFIER:b
            {: RESULT = new Name(parser, parser.pos(a), a,
                                 b.getIdentifier()); :}
    ;
// 19.6) Packages
compilation_unit ::=
                    // SourceFile
        package_declaration_opt:a
        import_declarations_opt:b
        type_declarations_opt:c
            {: RESULT = parser.nf.SourceFile(parser.pos(), a, b, c); :}
    ;
package_declaration_opt ::=
                    // PackageNode
        package_declaration:a {: RESULT = a; :}
    |
    ;
import_declarations_opt ::=
                    // List of Import
        import_declarations:a
            {: RESULT = a; :}
    |
        {: RESULT = new TypedList(new LinkedList(), Import.class, false); :}
    ;
type_declarations_opt   ::=
                    // List of ClassDecl
        type_declarations:a
            {: RESULT = a; :}
    |
        {: RESULT = new TypedList(new LinkedList(), ClassDecl.class, false); :}
    ;
import_declarations ::=
                    // List of Import
        import_declaration:a
            {: List l = new TypedList(new LinkedList(), Import.class, false);
               l.add(a);
               RESULT = l; :}
    |   import_declarations:a import_declaration:b
            {: RESULT = a;
               a.add(b); :}
    ;
type_declarations ::=
                    // List of ClassDecl
        type_declaration:a
        {: List l = new TypedList(new LinkedList(), ClassDecl.class, false);
               if (a != null)
                   l.add(a);
               RESULT = l; :}
    |   type_declarations:a type_declaration:b
            {: RESULT = a;
               if (b != null)
                   a.add(b); :}
    ;
package_declaration ::=
                    // Name
        PACKAGE name:a SEMICOLON
            {: RESULT = a.toPackage(); :}
    ;
import_declaration ::=
                    // Import
        single_type_import_declaration:a
            {: RESULT = a; :}
    |   type_import_on_demand_declaration:a
            {: RESULT = a; :}
    ;
single_type_import_declaration ::=
                    // Import
        IMPORT name:a SEMICOLON
            {: RESULT = parser.nf.Import(parser.pos(a), Import.CLASS, a.toName()); :}
    ;
type_import_on_demand_declaration ::=
                    // Import
        IMPORT name:a DOT MULT SEMICOLON
            {: RESULT = parser.nf.Import(parser.pos(a), Import.PACKAGE, a.toName()); :}
    ;
type_declaration ::=
                    // ClassDecl
        class_declaration:a
            {: RESULT = a; :}
    |   interface_declaration:a
            {: RESULT = a; :}
    |   SEMICOLON
            {: RESULT = null; :}
    ;
// 19.7) Productions used only in the LALR(1) grammar
modifiers_opt::=
                    // Flags
            {: RESULT = Flags.NONE; :}
    |   modifiers:a
            {: RESULT = a; :}
    ;
modifiers ::=
                    // Flags
        modifier:a
            {: RESULT = a; :}
    |   modifiers:a modifier:b
            {: RESULT = a.set(b); :}
    ;
modifier ::=
                    // Flags
        PUBLIC:a
            {: RESULT = Flags.PUBLIC; :}
    |    PROTECTED:a
            {: RESULT = Flags.PROTECTED; :}
    |    PRIVATE:a
            {: RESULT = Flags.PRIVATE; :}
    |    STATIC:a
            {: RESULT = Flags.STATIC; :}
    |    ABSTRACT:a
            {: RESULT = Flags.ABSTRACT; :}
    |    FINAL:a
            {: RESULT = Flags.FINAL; :}
    |    NATIVE:a
            {: RESULT = Flags.NATIVE; :}
    |    SYNCHRONIZED:a
            {: RESULT = Flags.SYNCHRONIZED; :}
    |    TRANSIENT:a
            {: RESULT = Flags.TRANSIENT; :}
    |    VOLATILE:a
            {: RESULT = Flags.VOLATILE; :}
    |    STRICTFP:a
            {: RESULT = Flags.STRICTFP; :}
    ;
// 19.8) Classes

// 19.8.1) Class Declarations
class_declaration ::=
                    // ClassDecl
        modifiers_opt:a CLASS:n IDENTIFIER:b
                parameters_opt:p invariant_opt:i super_opt:c
                interfaces_opt:d authority_opt:u class_body:e
            {: RESULT = parser.nf.JifClassDecl(parser.pos(b),
                                               a, b.getIdentifier(),
                                               p, i.booleanValue(), c, d, u, e); :}
    ;
super ::=
                    // TypeNode
        EXTENDS simple_ambiguous:a
            {: RESULT = a.toUnlabeledType(); :}
    ;
super_opt ::=
                    // TypeNode
    |   super:a
            {: RESULT = a; :}
    ;
interfaces ::=
                    // List of TypeNode
        IMPLEMENTS interface_type_list:a
            {: RESULT = a; :}
    ;
interfaces_opt::=
                    // List of TypeNode
            {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |   interfaces:a
            {: RESULT = a; :}
    ;
interface_type_list ::=
                    // List of TypeNode
        simple_ambiguous:a
            {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a.toUnlabeledType());
               RESULT = l; :}
    |   interface_type_list:a COMMA simple_ambiguous:b
            {: RESULT = a;
               a.add(b.toUnlabeledType()); :}
    ;
authority_opt ::=
            {: RESULT = new TypedList(new LinkedList(), PrincipalNode.class, false); :}
    |   authority:a
            {: RESULT = a; :}
    ;
authority ::=
        AUTHORITY:n LPAREN principal_list:a RPAREN
        {: RESULT = a; :}
    ;
class_body ::=
                    // List of ClassMember
        LBRACE:n class_body_declarations_opt:a RBRACE
            {: RESULT = parser.nf.ClassBody(parser.pos(n), a); :}
    ;
class_body_declarations_opt ::=
                    // List of ClassMember
            {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |   class_body_declarations:a
            {: RESULT = a; :}
    ;
class_body_declarations ::=
                    // List of ClassMember
        class_body_declaration:a
            {: RESULT = a; :}
    |   class_body_declarations:a class_body_declaration:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
class_body_declaration ::=
                    // List ClassMember
        class_member_declaration:a
            {: RESULT = a; :}
    |   static_initializer:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.pos(a), Flags.STATIC, a));
               RESULT = l; :}
    |   constructor_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    ;
class_member_declaration ::=
                    // List of ClassMember
        field_declaration:a
            {: RESULT = a; :}
    |   method_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    ;

// 19.8.2) Field Declarations
field_declaration ::=
                    // FieldNode
        modifiers_opt:a type:b variable_declarators:c SEMICOLON
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           for (Iterator i = c.iterator(); i.hasNext(); ) {
           Declarator d = (Declarator) i.next();
           l.add(parser.nf.FieldDecl(parser.pos(b),
                         a, parser.array(b, d.dims),
                         d.name, d.init));
           }
           RESULT = l; :}
    ;
variable_declarators ::=
                    // List of Declarator
        variable_declarator:a
            {: List l = new TypedList(new LinkedList(), Declarator.class, false);
               l.add(a);
               RESULT = l; :}
    |   variable_declarators:a COMMA variable_declarator:b
            {: RESULT = a;
               a.add(b); :}
    ;
variable_declarator ::=
                // Declarator
        variable_declarator_id:a
            {: RESULT = a; :}
    |   variable_declarator_id:a EQ variable_initializer:b
            {: RESULT = a;
               a.init = b; :}
    ;
variable_declarator_id ::=
                // Declarator
        IDENTIFIER:a
            {: RESULT = new Declarator(parser.pos(a), a.getIdentifier()); :}
    |   variable_declarator_id:a LBRACK RBRACK
            {: RESULT = a;
               a.dims++; :}
    ;
variable_initializer ::=
                    // Expr
        expression:a
            {: RESULT = a; :}
    |   array_initializer:a
            {: RESULT = a; :}
    ;

// 19.8.3) Method Declarations
method_declaration ::=
                    // MethodDecl
        method_header:a method_body:b
        {: RESULT = (MethodDecl) a.body(b); :}
    ;
method_header ::=
                    // JifMethodNode
        modifiers_opt:a type:b IDENTIFIER:c label_opt:i
        LPAREN formal_parameter_list_opt:d RPAREN
        dims_opt:e return_label_opt:r throws_opt:f constraints_opt:w
            {: RESULT = parser.nf.JifMethodDecl(parser.pos(c), a,
                        parser.array(b, e.intValue()),
                        c.getIdentifier(),
                                                i, d, r, f, w, null); :}
    |   modifiers_opt:a VOID:b IDENTIFIER:c label_opt:i
        LPAREN formal_parameter_list_opt:d RPAREN
        dims_opt:e return_label_opt:r throws_opt:f constraints_opt:w
            {: RESULT = parser.nf.JifMethodDecl(parser.pos(c), a,
                        parser.nf.CanonicalTypeNode(parser.pos(b),
                                   parser.ts.Void()),
                        c.getIdentifier(),
                                                i, d, r, f, w, null); :}
    ;
return_label_opt ::=
                    // LabelNode
            {: RESULT = null; :}
    |   COLON label:a
            {: RESULT = a; :}
    ;
formal_parameter_list_opt ::=
                    // List of FormalParameters
            {: RESULT = new TypedList(new LinkedList(), Formal.class, false); :}
    |   formal_parameter_list:a
            {: RESULT = a; :}
    ;
formal_parameter_list ::=
                    // List of FormalParameters
        formal_parameter:a
            {: List l = new TypedList(new LinkedList(), Formal.class, false);
               l.add(a);
               RESULT = l; :}
    |   formal_parameter_list:a COMMA formal_parameter:b
            {: RESULT = a;
               a.add(b); :}
    ;
formal_parameter ::=
                    // FormalParameter
        type:a variable_declarator_id:b
            {: RESULT = parser.nf.Formal(parser.pos(b), Flags.FINAL,
                     parser.array(a, b.dims), b.name); :}
    |   FINAL type:a variable_declarator_id:b
            {: RESULT = parser.nf.Formal(parser.pos(b), Flags.FINAL,
                     parser.array(a, b.dims), b.name); :}
    ;
throws_opt ::=
                    // List of TypeNode
            {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |   throws:a
            {: RESULT = a; :}
    ;
throws ::=
                    // List of TypeNode
        THROWS LPAREN class_type_list:a RPAREN
            {: RESULT = a; :}
    ;
class_type_list ::=
                    // List of TypeNode
        class_or_interface_type:a
            {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; :}
    |   class_type_list:a COMMA class_or_interface_type:b
            {: RESULT = a;
               a.add(b); :}
    ;
method_body ::=
                    // Block
        block:a
            {: RESULT = a; :}
    |   SEMICOLON
            {: RESULT = null; :}
    ;

// 19.8.4) Static Initializers
static_initializer ::=
                    // Block
        STATIC block:a
            {: RESULT = a; :}
    ;

// 19.8.5) Constructor Declarations
constructor_declaration ::=
                    // ConstructorDecl
        modifiers_opt:a ambiguous:q
        LPAREN formal_parameter_list_opt:c RPAREN return_label_opt:r
        throws_opt:d constraints_opt:w constructor_body:e
            {: String b; LabelNode i;
               // Pick apart the ambiguous node.
               // It can be either an identifier "a" or an
               // identifier and label "a{L}".
               if (q instanceof LabeledExpr) {
                   b = ((LabeledExpr) q).prefix.toIdentifier();
                   i = ((LabeledExpr) q).label;
               }
               else {
                   b = q.toIdentifier();
                   i = null;
               }
           RESULT = parser.nf.JifConstructorDecl(parser.pos(q),
                             a, b, i, r, c, d, w, e); :}
    ;
constructor_body ::=
                    // Block
        LBRACE:n block_statements:a explicit_super_constructor_invocation:b RBRACE
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.addAll(a);
               l.add(b);
               RESULT = parser.nf.Block(parser.pos(n), l); :}
    |   LBRACE:n block_statements:a explicit_super_constructor_invocation:b block_statements:c RBRACE
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.addAll(a);
               l.add(b);
               l.addAll(c);
               RESULT = parser.nf.Block(parser.pos(n), l); :}
    |   LBRACE:n explicit_constructor_invocation:a block_statements:b RBRACE
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               l.addAll(b);
               RESULT = parser.nf.Block(parser.pos(n), l); :}
    |   LBRACE:n explicit_constructor_invocation:a RBRACE
            {: RESULT = parser.nf.Block(parser.pos(n), a); :}
    |   LBRACE:n block_statements:a RBRACE
            {: a.add(0, parser.nf.SuperCall(parser.pos(n), 
                Collections.EMPTY_LIST));
               RESULT = parser.nf.Block(parser.pos(n), a); :}
    |   LBRACE:n RBRACE
            {: RESULT = parser.nf.Block(parser.pos(n),
                parser.nf.SuperCall(parser.pos(n),
                Collections.EMPTY_LIST)); :}
    ;

explicit_super_constructor_invocation ::=
                    // Stmt
        SUPER:a LPAREN argument_list_opt:b RPAREN SEMICOLON
            {: RESULT = parser.nf.SuperCall(parser.pos(a), b); :}
    ;
explicit_constructor_invocation ::=
                    // Stmt
        THIS:a LPAREN argument_list_opt:b RPAREN SEMICOLON
            {: RESULT = parser.nf.ThisCall(parser.pos(a), b); :}
    |   explicit_super_constructor_invocation:a
            {: RESULT = a; :}
    ;

// 19.9) Interfaces

// Jif Extensions
parameters_opt ::=
            // List of ParamDecl
            {: RESULT = new TypedList(new LinkedList(), ParamDecl.class, false); :}
    |
        LBRACK parameters:p RBRACK
            {: RESULT = p; :}
    ;

parameters ::=
            // List of ParamDecl
        parameter:a
            {: List l = new TypedList(new LinkedList(), ParamDecl.class, false);
               l.add(a);
               RESULT = l; :}
    |   parameters:a COMMA parameter:b
            {: RESULT = a;
               a.add(b); :}
    ;
parameter ::=
            // ParamDecl
    LABEL IDENTIFIER:a
        {: RESULT = parser.nf.ParamDecl(parser.pos(a),
                                        ParamInstance.INVARIANT_LABEL,
                                        a.getIdentifier()); :}
    |   COVARIANT LABEL IDENTIFIER:a
        {: RESULT = parser.nf.ParamDecl(parser.pos(a),
                                        ParamInstance.COVARIANT_LABEL,
                                        a.getIdentifier()); :}
    |   PRINCIPAL IDENTIFIER:a
        {: RESULT = parser.nf.ParamDecl(parser.pos(a),
                                        ParamInstance.PRINCIPAL,
                                        a.getIdentifier()); :}
    ;

invariant_opt ::=
	{: RESULT = new Boolean(false); :}
    |
    	LPAREN INVARIANT RPAREN
	{: RESULT = new Boolean(true); :}
    ;
    
constraints_opt ::=
        // List of ConstraintNode
            {: RESULT = new TypedList(new LinkedList(), ConstraintNode.class, false); :}
    |   WHERE constraints:a
            {: RESULT = a; :}
    ;
    
constraints ::=
        // List of ConstraintNode
        constraint:a
            {: List l = new TypedList(new LinkedList(), ConstraintNode.class, false);
               l.add(a); RESULT = l; :}
    |   constraints:a COMMA constraint:b
            {: RESULT = a;
               a.add(b); :}
    ;
    
constraint ::=
        // ConstraintNode
        AUTHORITY:n LPAREN principal_list:a RPAREN
        {: RESULT = parser.nf.AuthConstraintNode(parser.pos(n), a); :}
    |   CALLER:n LPAREN principal_list:a RPAREN
        {: RESULT = parser.nf.CallerConstraintNode(parser.pos(n), a); :}
    |   ACTSFOR:n LPAREN principal:a COMMA principal:b RPAREN
        {: RESULT = parser.nf.ActsForConstraintNode(parser.pos(n), a, b); :}
    ;

// 19.9.1) Interface Declarations
interface_declaration ::=
        // ClassDecl
        modifiers_opt:a INTERFACE:n IDENTIFIER:b
                parameters_opt:p invariant_opt:i
                extends_interfaces_opt:d authority_opt:u interface_body:e
            {: RESULT = parser.nf.JifClassDecl(parser.pos(b),
		    a.set(Flags.INTERFACE), b.getIdentifier(),
		    p, i.booleanValue(), null, d, u, e); :} 
    ;
extends_interfaces_opt ::=
                    // List of TypeNode
            {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |   extends_interfaces:a
            {: RESULT = a; :}
    ;
extends_interfaces ::=
                    // List of TypeNode
        EXTENDS simple_ambiguous:a
            {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a.toUnlabeledType());
               RESULT = l; :}
    |   extends_interfaces:a COMMA simple_ambiguous:b
            {: RESULT = a;
               a.add(b.toUnlabeledType()); :}
    ;
interface_body ::=
                    // ClassBody
        LBRACE:n interface_member_declarations_opt:a RBRACE
            {: RESULT = parser.nf.ClassBody(parser.pos(n), a); :}
    ;
interface_member_declarations_opt ::=
                    // List of ClassMember
            {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |   interface_member_declarations:a
            {: RESULT = a; :}
    ;
interface_member_declarations ::=
                    // List of ClassMember
        interface_member_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.addAll(a);
               RESULT = l; :}
    |   interface_member_declarations:a interface_member_declaration:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
interface_member_declaration ::=
                    // List ClassMember
        constant_declaration:a
            {: RESULT = a; :}
    |   abstract_method_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    ;
constant_declaration ::=
                    // List of FieldDecl
        field_declaration:a
            {: RESULT = a; :}
    ;
abstract_method_declaration ::=
                    // MethodDecl
        method_header:a SEMICOLON
            {: RESULT = a; :}
    ;

// 19.10) Arrays
array_initializer ::=
                    // ArrayInitializerExpr
        LBRACE:n variable_initializers:a COMMA RBRACE
            {: RESULT = parser.nf.ArrayInit(parser.pos(n), a); :}
    |   LBRACE:n variable_initializers:a RBRACE
            {: RESULT = parser.nf.ArrayInit(parser.pos(n), a); :}
    |   LBRACE:n COMMA RBRACE
            {: RESULT = parser.nf.ArrayInit(parser.pos(n)); :}
    |   LBRACE:n RBRACE
            {: RESULT = parser.nf.ArrayInit(parser.pos(n)); :}
    ;
variable_initializers ::=
                    // List of Expr
        variable_initializer:a
            {: List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; :}
    |   variable_initializers:a COMMA variable_initializer:b
            {: RESULT = a; a.add(b); :}
    ;

// 19.11) Blocks and Statements
block ::=
                    // Block
        LBRACE:n block_statements_opt:a RBRACE
            {: RESULT = parser.nf.Block(parser.pos(n), a); :}
    ;
block_statements_opt ::=
                    // List of Stmt
            {: RESULT = new TypedList(new LinkedList(), Stmt.class, false); :}
    |   block_statements:a
            {: RESULT = a; :}
    ;
block_statements ::=
                    // List of Stmt
        block_statement:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.addAll(a);
               RESULT = l; :}
    |   block_statements:a block_statement:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
block_statement ::=
                    // List of Stmt
        local_variable_declaration_statement:a
            {: RESULT = a; :}
    |   statement:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               RESULT = l; :}
    ;
local_variable_declaration_statement ::=
                    // List of LocalDecl
        local_variable_declaration:a SEMICOLON
            {: RESULT = a; :}
    ;
local_variable_declaration ::=
                    // List of LocalDecl
        type:a variable_declarators:b
            {: List l = new TypedList(new LinkedList(), LocalDecl.class, false);
           for (Iterator i = b.iterator(); i.hasNext(); ) {
                   Declarator d = (Declarator) i.next();
                   l.add(parser.nf.LocalDecl(parser.pos(a), Flags.NONE,
                                             parser.array(a, d.dims),
                                             d.name, d.init));
               }
               RESULT = l; :}
    |   FINAL type:a variable_declarators:b
            {: List l = new TypedList(new LinkedList(), LocalDecl.class, false);
           for (Iterator i = b.iterator(); i.hasNext(); ) {
                   Declarator d = (Declarator) i.next();
                   l.add(parser.nf.LocalDecl(parser.pos(a), Flags.FINAL,
                                             parser.array(a, d.dims),
                                             d.name, d.init));
               }
               RESULT = l; :}
    ;
statement ::=
                    // Stmt
        statement_without_trailing_substatement:a
            {: RESULT = a; :}
    |   labeled_statement:a
            {: RESULT = a; :}
    |   if_then_statement:a
            {: RESULT = a; :}
    |   if_then_else_statement:a
            {: RESULT = a; :}
    |   while_statement:a
            {: RESULT = a; :}
    |   for_statement:a
            {: RESULT = a; :}
    |   labelcase_statement:a
            {: RESULT = a; :}
    |   actsfor_statement:a
            {: RESULT = a; :}
    |   actsfor_else_statement:a
            {: RESULT = a; :}
    |   declassify_statement:a
            {: RESULT = a; :}
    ;
statement_no_short_if ::=
                    // Stmt
        statement_without_trailing_substatement:a
            {: RESULT = a; :}
    |   labeled_statement_no_short_if:a
            {: RESULT = a; :}
    |   if_then_else_statement_no_short_if:a
            {: RESULT = a; :}
    |   actsfor_else_statement_no_short_if:a
            {: RESULT = a; :}
    |   while_statement_no_short_if:a
            {: RESULT = a; :}
    |   for_statement_no_short_if:a
            {: RESULT = a; :}
    ;
statement_without_trailing_substatement ::=
                    // Stmt
        block:a
            {: RESULT = a; :}
    |   empty_statement:a
            {: RESULT = a; :}
    |   expression_statement:a
            {: RESULT = a; :}
    |   switch_statement:a
            {: RESULT = a; :}
    |   do_statement:a
            {: RESULT = a; :}
    |   break_statement:a
            {: RESULT = a; :}
    |   continue_statement:a
            {: RESULT = a; :}
    |   return_statement:a
            {: RESULT = a; :}
    |   synchronized_statement:a
            {: RESULT = a; :}
    |   throw_statement:a
            {: RESULT = a; :}
    |   try_statement:a
            {: RESULT = a; :}
    ;
empty_statement ::=
                    // Stmt
        SEMICOLON:a
            {: RESULT = parser.nf.Empty(parser.pos(a)); :}
    ;
labeled_statement ::=
                    // Stmt
        IDENTIFIER:a COLON statement:b
            {: RESULT = parser.nf.Labeled(parser.pos(a),
                                          a.getIdentifier(), b); :}
    ;
labeled_statement_no_short_if ::=
                    // Stmt
        IDENTIFIER:a COLON statement_no_short_if:b
            {: RESULT = parser.nf.Labeled(parser.pos(a),
                                          a.getIdentifier(), b); :}
    ;
expression_statement ::=
                    // Stmt
        statement_expression:a SEMICOLON
            {: RESULT = parser.nf.Eval(parser.pos(a), a); :}
    ;
statement_expression ::=
                    // Expr
        assignment:a
            {: RESULT = a; :}
    |   preincrement_expression:a
            {: RESULT = a; :}
    |   predecrement_expression:a
            {: RESULT = a; :}
    |   postincrement_expression:a
            {: RESULT = a; :}
    |   postdecrement_expression:a
            {: RESULT = a; :}
    |   method_invocation:a
            {: RESULT = a; :}
    |   class_instance_creation_expression:a
            {: RESULT = a; :}
    ;
if_then_statement ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement:b
            {: RESULT = parser.nf.If(parser.pos(n), a, b); :}
    ;
if_then_else_statement ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement_no_short_if:b
            ELSE statement:c
            {: RESULT = parser.nf.If(parser.pos(n), a, b, c); :}
    ;
if_then_else_statement_no_short_if ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement_no_short_if:b
            ELSE statement_no_short_if:c
            {: RESULT = parser.nf.If(parser.pos(n), a, b, c); :}
    ;
switch_statement ::=
                    // Switch
        SWITCH:n LPAREN expression:a RPAREN switch_block:b
            {: RESULT = parser.nf.Switch(parser.pos(n), a, b); :}
    ;
switch_block ::=
                    // List of SwitchElement
        LBRACE switch_block_statement_groups:a switch_labels:b RBRACE
            {: RESULT = a; a.addAll(b); :}
    |   LBRACE switch_block_statement_groups:a RBRACE
            {: RESULT = a; :}
    |   LBRACE switch_labels:a RBRACE
            {: RESULT = a; :}
    |   LBRACE RBRACE
            {: RESULT = new TypedList(new LinkedList(), SwitchElement.class, false); :}
    ;
switch_block_statement_groups ::=
                    // List of SwitchElement
        switch_block_statement_group:a
            {: RESULT = a; :}
    |   switch_block_statement_groups:a switch_block_statement_group:b
            {: RESULT = a; a.addAll(b); :}
    ;
switch_block_statement_group ::=
                    // List of SwitchElement
        switch_labels:a block_statements:b
            {: List l = new TypedList(new LinkedList(), SwitchElement.class, false);
               l.addAll(a);
               l.add(parser.nf.SwitchBlock(parser.pos(b), b));
               RESULT = l; :}
    ;
switch_labels ::=
                    // List of Case
        switch_label:a
            {: List l = new TypedList(new LinkedList(), Case.class, false);
               l.add(a);
               RESULT = l; :}
    |   switch_labels:a switch_label:b
            {: RESULT = a; a.add(b); :}
    ;
switch_label ::=
                    // Case
        CASE:n constant_expression:a COLON
        {: RESULT = parser.nf.Case(parser.pos(n), a); :}
    |   DEFAULT:n COLON
        {: RESULT = parser.nf.Default(parser.pos(n)); :}
    ;

while_statement ::=
                    // While
        WHILE:n LPAREN expression:a RPAREN statement:b
        {: RESULT = parser.nf.While(parser.pos(n), a, b); :}
    ;
while_statement_no_short_if ::=
                    // While
        WHILE:n LPAREN expression:a RPAREN statement_no_short_if:b
        {: RESULT = parser.nf.While(parser.pos(n), a, b); :}
    ;
do_statement ::=
                    // Do
        DO:n statement:a WHILE LPAREN expression:b RPAREN SEMICOLON
        {: RESULT = parser.nf.Do(parser.pos(n), a, b); :}
    ;
for_statement ::=
                    // For
    FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON
        for_update_opt:c RPAREN statement:d
        {: RESULT = parser.nf.For(parser.pos(n), a, b, c, d); :}
    ;
for_statement_no_short_if ::=
                    // For
        FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON
            for_update_opt:c RPAREN statement_no_short_if:d
        {: RESULT = parser.nf.For(parser.pos(n), a, b, c, d); :}
    ;
for_init_opt ::=
                    // List of ForInit
            {: RESULT = new TypedList(new LinkedList(), ForInit.class, false); :}
    |   for_init:a
            {: RESULT = a; :}
    ;
for_init ::=
                    // List of ForInit
        statement_expression_list:a
            {: RESULT = a; :}
    |   local_variable_declaration:a
            {: List l = new TypedList(new LinkedList(), ForInit.class, false);
               l.addAll(a);
               RESULT = l; :}
    ;
for_update_opt ::=
                    // List of ForUpdate
            {: RESULT = new TypedList(new LinkedList(), ForUpdate.class, false); :}
    |   for_update:a
            {: RESULT = a; :}
    ;
for_update ::=
                    // List of ForUpdate
        statement_expression_list:a
            {: RESULT = a; :}
    ;
statement_expression_list ::=
                    // List of Stmt
        statement_expression:a
            {: List l = new TypedList(new LinkedList(), Eval.class, false);
               l.add(parser.nf.Eval(parser.pos(a), a));
               RESULT = l; :}
    |   statement_expression_list:a COMMA statement_expression:b
            {: RESULT = a;
               a.add(parser.nf.Eval(parser.pos(b), b)); :}
    ;

identifier_opt ::=
                    // Name
        {: RESULT = null; :}
    |   IDENTIFIER:a
            {: RESULT = new Name(parser, parser.pos(a),
                                     a.getIdentifier()); :}
    ;

break_statement ::=
                    // Branch
        BREAK:n identifier_opt:a SEMICOLON
            {: if (a == null)
                   RESULT = parser.nf.Break(parser.pos(n));
               else
                   RESULT = parser.nf.Break(parser.pos(n), a.toName()); :}
    ;

continue_statement ::=
                    // Branch
        CONTINUE:n identifier_opt:a SEMICOLON
            {: if (a == null)
                   RESULT = parser.nf.Continue(parser.pos(n));
               else
                   RESULT = parser.nf.Continue(parser.pos(n), a.toName()); :}
    ;
return_statement ::=
                    // Return
        RETURN:n expression_opt:a SEMICOLON
            {: RESULT = parser.nf.Return(parser.pos(n), a); :}
    ;
throw_statement ::=
                    // Throw
        THROW:n expression:a SEMICOLON
            {: RESULT = parser.nf.Throw(parser.pos(n), a); :}
    ;
synchronized_statement ::=
                    // Synchronized
        SYNCHRONIZED:n LPAREN expression:a RPAREN block:b
            {: RESULT = parser.nf.Synchronized(parser.pos(n), a, b); :}
    ;
try_statement ::=
                    // Try
        TRY:n block:a catches:b
            {: RESULT = parser.nf.Try(parser.pos(n), a, b); :}
    |   TRY:n block:a catches_opt:b finally:c
            {: RESULT = parser.nf.Try(parser.pos(n), a, b, c); :}
    ;
catches_opt ::=
                    // List of Catch
            {: RESULT = new TypedList(new LinkedList(), Catch.class, false); :}
    |   catches:a
            {: RESULT = a; :}
    ;
catches ::=
                    // List of Catch
        catch_clause:a
            {: List l = new TypedList(new LinkedList(), Catch.class, false);
               l.add(a);
               RESULT = l; :}
    |   catches:a catch_clause:b
            {: RESULT = a;
               a.add(b); :}
    ;
catch_clause ::=
                    // Catch
        CATCH:n LPAREN formal_parameter:a RPAREN block:b
            {: RESULT = parser.nf.Catch(parser.pos(n), a, b); :}
    ;
finally ::=
                    // Block
        FINALLY block:a
            {: RESULT = a; :}
    ;
labelcase_statement ::=
                    // SwitchLabel
        SWITCH LABEL:n LPAREN expression:a RPAREN LBRACE labelcases:b RBRACE
            {: RESULT = parser.nf.SwitchLabel(parser.pos(n), a, b); :}
    ;
labelcases ::=
                    // List of LabelCase
        labelcase_no_else:a
            {: List l = new TypedList(new LinkedList(), LabelCase.class, false);
               l.add(a); RESULT = l; :}
    |   labelcases:a labelcase_no_else:b
            {: RESULT = a; a.add(b); :}
    |   labelcases:a labelcase_else:b
            {: RESULT = a; a.add(b); :}
    ;
labelcase_no_else ::=
                    // List of LabelCase
        CASE:n LPAREN type:a IDENTIFIER:b RPAREN statement_no_short_if:c
            {:  if (! (a instanceof LabeledTypeNode)) parser.die(parser.pos(a));
        RESULT = parser.nf.LabelCase(parser.pos(n),
                         parser.nf.Formal(parser.pos(a),
                                             Flags.FINAL,
                                 a,
                                 b.getIdentifier()),
                         ((LabeledTypeNode) a).labelPart(),
                         c); :}
    |   CASE:n label:a statement_no_short_if:b
            {: RESULT = parser.nf.LabelCase(parser.pos(n), a, b); :}
    ;
labelcase_else ::=
        ELSE:n statement_no_short_if:a
            {: RESULT = parser.nf.LabelCase(parser.pos(n), a); :}
    ;
actsfor_statement ::=
                    // ActsFor
        ACTSFOR:n LPAREN principal:a COMMA principal:b RPAREN statement:c
            {: RESULT = parser.nf.ActsFor(parser.pos(n), a, b, c); :}
    ;
actsfor_else_statement ::=
                    // ActsFor
        ACTSFOR:n LPAREN principal:a COMMA principal:b RPAREN
            statement_no_short_if:c ELSE statement:d
            {: RESULT = parser.nf.ActsFor(parser.pos(n), a, b, c, d); :}
    ;
actsfor_else_statement_no_short_if ::=
                    // ActsFor
        ACTSFOR:n LPAREN principal:a COMMA principal:b RPAREN
            statement_no_short_if:c ELSE statement_no_short_if:d
            {: RESULT = parser.nf.ActsFor(parser.pos(n), a, b, c, d); :}
    ;
declassify_statement ::=
                    // DeclassifyStmt
        DECLASSIFY:n LPAREN label:a RPAREN statement:b
            {: RESULT = parser.nf.DeclassifyStmt(parser.pos(n),
                            parser.nf.CanonicalLabelNode(parser.pos(n), parser.ts.topLabel(parser.pos(n))),
                            a, b); :}
    |   DECLASSIFY:n LPAREN label:a COMMA label:b RPAREN statement:c
            {: RESULT = parser.nf.DeclassifyStmt(parser.pos(n), a, b, c); :}
    ;

// 19.12) Expr           // Expr
primary ::=
        primary_no_new_array:a
            {: RESULT = a; :}
    |   array_creation_expression:a
            {: RESULT = a; :}
    ;
primary_no_new_array ::=
        primary_no_array:a
            {: RESULT = a; :}
    |   array_access:a
            {: RESULT = a; :}
    ;
primary_no_array ::=
                    // Expr
        literal:a
            {: RESULT = a; :}
    |   THIS:a
            {: RESULT = parser.nf.This(parser.pos(a)); :}
    |   LPAREN expression:a RPAREN
            {: RESULT = a; :}
    |   class_instance_creation_expression:a
            {: RESULT = a; :}
    |   field_access:a
            {: RESULT = a; :}
    |   method_invocation:a
            {: RESULT = a; :}
    |   declassify:a
            {: RESULT = a; :}
/******************************* No static fields **************************
    |   primitive_type:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.pos(n), a, "class"); :}
    |   VOID:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.pos(n),
                                        parser.nf.CanonicalTypeNode(parser.pos(a),
                               parser.ts.Void()),
                                        "class"); :}
    |   primitive_array_type:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.pos(n), a, "class"); :}
    |   ambiguous:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.pos(n), a.toType(), "class"); :}
******************************** No static fields **************************/
    ;
class_instance_creation_expression ::=
                    // NewObjectExpr
        NEW simple_ambiguous:a label_opt:l LPAREN argument_list_opt:b RPAREN
            {:  TypeNode tn = a.toUnlabeledType();
		if (l != null) 
		    tn = parser.nf.LabeledTypeNode(parser.pos(a), tn, l);
		RESULT = parser.nf.New(parser.pos(a), tn, b); :}
    ;

argument_list_opt ::=
                    // List of Expr
            {: RESULT = new TypedList(new LinkedList(), Expr.class, false); :}
    |   argument_list:a
            {: RESULT = a; :}
    ;
argument_list ::=
                    // List of Expr
        expression:a
            {: List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a); RESULT = l; :}
    |   argument_list:a COMMA expression:b
            {: RESULT = a; a.add(b); :}
    ;
array_creation_expression ::=
                    // Expr
        NEW:n LABEL label:a
            {: RESULT = parser.nf.NewLabel(parser.pos(n), a); :}
    |   NEW:n primitive_type:a dim_exprs:b dims_opt:c
            {: RESULT = parser.nf.NewArray(parser.pos(n), a, b,
                                           c.intValue()); :}
    |   NEW:n simple_ambiguous:a
            {: RESULT = a.toNewArray(parser.pos(n)); :}
    |   NEW:n primitive_type:a dims:b array_initializer:c
            {: RESULT = parser.nf.NewArray(parser.pos(n), a,
                                           b.intValue(), c); :}
    |   NEW:n simple_ambiguous:a dims:b array_initializer:c
            {: RESULT = parser.nf.NewArray(parser.pos(n), a.toType(),
                                       b.intValue(), c); :}
    ;
dim_exprs ::=
                    // List of Expr
        dim_expr:a
            {: List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; :}
    |   dim_exprs:a dim_expr:b
            {: RESULT = a; a.add(b); :}
    ;
dim_expr ::=
                    // Expr
        LBRACK expression:a RBRACK
            {: RESULT = a; :}
    ;
dims_opt ::=
                    // Integer
            {: RESULT = new Integer(0); :}
    |   dims:a
            {: RESULT = a; :}
    ;
dims ::=
                    // Integer
        LBRACK RBRACK
            {: RESULT = new Integer(1); :}
    |   dims:a LBRACK RBRACK
            {: RESULT = new Integer(a.intValue() + 1); :}
    ;
field_access ::=
                    // Field
        primary_no_new_array:a DOT IDENTIFIER:b
        {: RESULT = parser.nf.Field(parser.pos(b), a,
                    b.getIdentifier()); :}
    |   SUPER:n DOT IDENTIFIER:b
            {: RESULT = parser.nf.Field(parser.pos(b),
                                        parser.nf.Super(parser.pos(n)),
                                        b.getIdentifier()); :}
    ;
method_invocation ::=
                    // MethodExpr
        ambiguous:a LPAREN argument_list_opt:b RPAREN
        {: if (! (a instanceof Name)) parser.die(parser.pos(a));
           Name n = (Name) a;
               RESULT = parser.nf.Call(parser.pos(a),
                       n.prefix == null ? null
                                                        : n.prefix.toReceiver(),
                       n.name, b); :}
    |   primary_no_new_array:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN
            {: RESULT = parser.nf.Call(parser.pos(b), a,
                                       b.getIdentifier(), c); :}
    |   SUPER:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN
            {: RESULT = parser.nf.Call(parser.pos(b),
                                       parser.nf.Super(parser.pos(a)),
                                       b.getIdentifier(), c); :}
    ;

declassify ::=
                    // DeclassifyExpr
        DECLASSIFY LPAREN expression:a COMMA label:b RPAREN
            {: RESULT = parser.nf.DeclassifyExpr(parser.pos(a), a,
                            parser.nf.CanonicalLabelNode(parser.pos(a), parser.ts.topLabel(parser.pos(a)) ),
                            b); :}
    |   DECLASSIFY LPAREN expression:a COMMA label:b COMMA label:c RPAREN
            {: RESULT = parser.nf.DeclassifyExpr(parser.pos(a), a, b, c); :}
    ;

param_or_expr_list ::=
        // List of Object (Expr or Identifier or ParamNode)
        expression:a
        {: List l = new TypedList(new LinkedList(), Object.class, false);

           if (a instanceof Wrapper) {
                Wrapper w = (Wrapper) a;

                if (w.amb instanceof Name &&
                    ((Name) w.amb).prefix == null) {
        
                    // Could be a field, local, principal, or param of the
                    // current class The last three can be used to
                    // instantiate a class.
                    l.add(w.amb);
                }
                else {
                    l.add(a);
                }
           }
           else {
                l.add(a);
           }
               
           RESULT = l; 
        :}
    |   label:a
        {: List l = new TypedList(new LinkedList(), Node.class, false);
           l.add(a);
           RESULT = l; 
        :}
    |   param_or_expr_list:a COMMA simple_name:b
        {: a.add(b);
           RESULT = a; 
        :}
    |   param_or_expr_list:a COMMA label:b
        {: a.add(b);
           RESULT = a; :}
    ;
    
simple_ambiguous ::=
        IDENTIFIER:a
            {: RESULT = new Name(parser, parser.pos(a), null,
                                 a.getIdentifier()); :}
    |   simple_ambiguous:a DOT IDENTIFIER:b
            {: RESULT = new Name(parser, parser.pos(a), a,
                                 b.getIdentifier()); :}
    |   simple_ambiguous:a LBRACK param_or_expr_list:b RBRACK
        {: if (a instanceof Access) {
                RESULT = new Access(parser, parser.pos(a), a,
                                        (Expr) b.get(0));
           }
           else {
                if (b.size() == 1) {
                    if (b.get(0) instanceof Name) {
                        Name id = (Name) b.get(0);
                        RESULT = new InstOrAccess(parser,
                                                    parser.pos(a), a, id);
                    }
                    else if (b.get(0) instanceof ParamNode) {
                        RESULT = new Inst(parser, parser.pos(a),
                                            a.toClassType(), b);
                    }
                    else {
                        RESULT = new Access(parser, parser.pos(a), a,
                                (Expr) b.get(0));
                    }
                }
                else {
                    RESULT = new Inst(parser,
                                parser.pos(a), a.toClassType(),
                                parser.toParamList(b));
                }
           } :}
    ;
    
ambiguous ::=
        IDENTIFIER:a
            {: RESULT = new Name(parser, parser.pos(a), null,
                                 a.getIdentifier()); :}
    |   ambiguous:a DOT IDENTIFIER:b
            {: RESULT = new Name(parser, parser.pos(b), a,
                                 b.getIdentifier()); :}
    |   ambiguous:a LBRACK param_or_expr_list:b RBRACK
            {:  if (a instanceof Access) {
                    RESULT = new Access(parser, parser.pos(a), a,
                                            (Expr) b.get(0));
                }
                else {
                    if (b.size() == 1) {
                        if (b.get(0) instanceof Name) {
                            Name id = (Name) b.get(0);
                            RESULT = new InstOrAccess(parser,
                                                        parser.pos(a), a, id);
                        }
                        else if (b.get(0) instanceof ParamNode) {
                            RESULT = new Inst(parser, parser.pos(a),
                                                  a.toClassType(), b);
                        }
                        else {
                            RESULT = new Access(parser, parser.pos(a), a,
                                                    (Expr) b.get(0));
                        }
                    }
                    else {
                        RESULT = new Inst(parser,
					  parser.pos(a), a.toClassType(),
					  parser.toParamList(b));
                    }
                } 
           :}
    |   ambiguous:a LBRACK RBRACK
            {: RESULT = new Array(parser, parser.pos(a), a.toType()); :}
    |   ambiguous:a label:b
            {: RESULT = new LabeledExpr(parser, parser.pos(b), a, b); :}
    ;
array_access ::=
                    // ArrayAccess
        primary_no_array:a dim_exprs:b
            {: Expr x = a;
               for (Iterator i = b.iterator(); i.hasNext(); ) {
                    Expr e = (Expr) i.next();
                    x = parser.nf.ArrayAccess(parser.pos(a), x, e);
               }
               RESULT = (ArrayAccess) x; :}
    ;
postfix_expression ::=
                    // Expr
        primary:a
            {: RESULT = a; :}
    |   ambiguous:a
            {: RESULT = a.wrap(); :}
    |   postincrement_expression:a
            {: RESULT = a; :}
    |   postdecrement_expression:a
            {: RESULT = a; :}
    ;
postincrement_expression ::=
                    // UnaryExpr
        postfix_expression:a PLUSPLUS
            {: RESULT = parser.nf.Unary(parser.pos(a), a, Unary.POST_INC); :}
    ;
postdecrement_expression ::=
                    // UnaryExpr
        postfix_expression:a MINUSMINUS
            {: RESULT = parser.nf.Unary(parser.pos(a), a, Unary.POST_DEC); :}
    ;
unary_expression ::=
                    // Expr
        preincrement_expression:a
            {: RESULT = a; :}
    |   predecrement_expression:a
            {: RESULT = a; :}
    |   PLUS unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(a), Unary.POS, a); :}
    |   MINUS unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(a), Unary.NEG, a); :}
    |   unary_expression_not_plus_minus:a
            {: RESULT = a; :}
    ;
preincrement_expression ::=
                    // UnaryExpr
        PLUSPLUS unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(a), Unary.PRE_INC, a); :}
    ;
predecrement_expression ::=
                    // UnaryExpr
        MINUSMINUS unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(a), Unary.PRE_DEC, a); :}
    ;
unary_expression_not_plus_minus ::=
                    // Expr
        postfix_expression:a
            {: RESULT = a; :}
    |   COMP unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(a), Unary.BIT_NOT, a); :}
    |   NOT unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(a), Unary.NOT, a); :}
    |   cast_expression:a
            {: RESULT = a; :}
    ;
cast_expression ::=
                    // Cast
        LPAREN labeled_primitive_type:a dims_opt:b RPAREN unary_expression:c
            {: RESULT = parser.nf.Cast(parser.pos(a),
                                   parser.array(a, b.intValue()), c); :}
    |   LPAREN expression:a RPAREN unary_expression_not_plus_minus:b
            {: RESULT = parser.nf.Cast(parser.pos(a), parser.exprToType(a), b); :}
    ;
multiplicative_expression ::=
                    // Expr
        unary_expression:a
            {: RESULT = a; :}
    |   multiplicative_expression:a MULT unary_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.MUL, b); :}
    |   multiplicative_expression:a DIV unary_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.DIV, b); :}
    |   multiplicative_expression:a MOD unary_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.MOD, b); :}
    ;
additive_expression ::=
                    // Expr
        multiplicative_expression:a
            {: RESULT = a; :}
    |   additive_expression:a PLUS multiplicative_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.ADD, b); :}
    |   additive_expression:a MINUS multiplicative_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.SUB, b); :}
    ;
shift_expression ::=
                    // Expr
        additive_expression:a
            {: RESULT = a; :}
    |   shift_expression:a LSHIFT additive_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.SHL, b); :}
    |   shift_expression:a RSHIFT additive_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.SHR, b); :}
    |   shift_expression:a URSHIFT additive_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.USHR, b); :}
    ;
relational_expression ::=
                    // Expr
        shift_expression:a
            {: RESULT = a; :}
    |   relational_expression:a LT shift_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.LT, b); :}
    |   relational_expression:a GT shift_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.GT, b); :}
    |   relational_expression:a LTEQ shift_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.LE, b); :}
    |   relational_expression:a GTEQ shift_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.GE, b); :}
    |   relational_expression:a INSTANCEOF reference_type:b
            {: RESULT = parser.nf.Instanceof(parser.pos(a), a, b); :}
    ;

equality_expression ::=
                    // Expr
        relational_expression:a
            {: RESULT = a; :}
    |   equality_expression:a EQEQ relational_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.EQ, b); :}
    |   equality_expression:a NOTEQ relational_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.NE, b); :}
    ;
and_expression ::=
                    // Expr
        equality_expression:a
            {: RESULT = a; :}
    |   and_expression:a AND equality_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.BIT_AND, b); :}
    ;
exclusive_or_expression ::=
                    // Expr
        and_expression:a
            {: RESULT = a; :}
    |   exclusive_or_expression:a XOR and_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.BIT_XOR, b); :}
    ;
inclusive_or_expression ::=
                    // Expr
        exclusive_or_expression:a
            {: RESULT = a; :}
    |   inclusive_or_expression:a OR exclusive_or_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.BIT_OR, b); :}
    ;
conditional_and_expression ::=
                    // Expr
        inclusive_or_expression:a
            {: RESULT = a; :}
    |   conditional_and_expression:a ANDAND inclusive_or_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.COND_AND, b); :}
    ;
conditional_or_expression ::=
                    // Expr
        conditional_and_expression:a
            {: RESULT = a; :}
    |   conditional_or_expression:a OROR conditional_and_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a), a, Binary.COND_OR, b); :}
    ;
conditional_expression ::=
                    // Expr
        conditional_or_expression:a
            {: RESULT = a; :}
    |   conditional_or_expression:a QUESTION expression:b
            COLON conditional_expression:c
            {: RESULT = parser.nf.Conditional(parser.pos(a), a, b, c); :}
    ;
assignment_expression ::=
                    // Expr
        conditional_expression:a
            {: RESULT = a; :}
    |   assignment:a
            {: RESULT = a; :}
    ;
assignment ::=
                    // Expr
        left_hand_side:a assignment_operator:b assignment_expression:c
            {: RESULT = parser.nf.Assign(parser.pos(a), a, b, c); :}
    ;
left_hand_side ::=
                    // Expr
        ambiguous:a
            {: RESULT = a.wrap(); :}
    |   field_access:a
            {: RESULT = a; :}
    |   array_access:a
            {: RESULT = a; :}
    ;
assignment_operator ::=
                    // Integer
        EQ
            {: RESULT = Assign.ASSIGN; :}
    |   MULTEQ
               {: RESULT = Assign.MUL_ASSIGN; :}
    |   DIVEQ
               {: RESULT = Assign.DIV_ASSIGN; :}
    |   MODEQ
               {: RESULT = Assign.MOD_ASSIGN; :}
    |   PLUSEQ
               {: RESULT = Assign.ADD_ASSIGN; :}
    |   MINUSEQ
               {: RESULT = Assign.SUB_ASSIGN; :}
    |   LSHIFTEQ
               {: RESULT = Assign.SHL_ASSIGN; :}
    |   RSHIFTEQ
               {: RESULT = Assign.SHR_ASSIGN; :}
    |   URSHIFTEQ
               {: RESULT = Assign.USHR_ASSIGN; :}
    |   ANDEQ
               {: RESULT = Assign.BIT_AND_ASSIGN; :}
    |   XOREQ
               {: RESULT = Assign.BIT_XOR_ASSIGN; :}
    |   OREQ
               {: RESULT = Assign.BIT_OR_ASSIGN; :}
    ;
expression_opt ::=
                    // Expr
            {: RESULT = null; :}
    |   expression:a
            {: RESULT = a; :}
    ;
expression ::=
                    // Expr
        assignment_expression:a
            {: RESULT = a; :}
    ;
constant_expression ::=
                    // Expr
        expression:a
            {: RESULT = a; :}
    ;
